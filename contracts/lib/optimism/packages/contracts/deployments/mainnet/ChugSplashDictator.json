{
  "address": "0xD86065136E3ab1e3FCBbf47B59404c08A431051A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract L1ChugSplashProxy",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_finalOwner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_codeHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_messengerSlotKey",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_messengerSlotVal",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_bridgeSlotKey",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_bridgeSlotVal",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "bridgeSlotKey",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bridgeSlotVal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "codeHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_code",
          "type": "bytes"
        }
      ],
      "name": "doActions",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isUpgrading",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "messengerSlotKey",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "messengerSlotVal",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "returnOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "target",
      "outputs": [
        {
          "internalType": "contract L1ChugSplashProxy",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x66aa5170e6ce4a62d40bf909c390b0263ae5df08d922b682374273b34fa03f0f",
  "receipt": {
    "to": null,
    "from": "0x0bb2cA5Ea700ba04c713008E1a3D198B4e8dA7a7",
    "contractAddress": "0xD86065136E3ab1e3FCBbf47B59404c08A431051A",
    "transactionIndex": 24,
    "gasUsed": "600228",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2fc3021674d5715905434b8544da54a0036c015f330bb803a6f6b863b7459dca",
    "transactionHash": "0x66aa5170e6ce4a62d40bf909c390b0263ae5df08d922b682374273b34fa03f0f",
    "logs": [],
    "blockNumber": 13596791,
    "cumulativeGasUsed": "3529686",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1",
    "0x9BA6e03D8B90dE867373Db8cF1A58d2F7F006b3A",
    "0x395448fabf9c422ff29a22e5b39869e32d00ca911f7553ec25591d8d47befaa1",
    "0x0000000000000000000000000000000000000000000000000000000000000000",
    "0x00000000000000000000000025ace71c97B33Cc4729CF772ae268934F7ab5fA1",
    "0x0000000000000000000000000000000000000000000000000000000000000001",
    "0x0000000000000000000000004200000000000000000000000000000000000010"
  ],
  "solcInputHash": "475653b7e5822844bbc8885f604f5e79",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract L1ChugSplashProxy\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_finalOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_codeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_messengerSlotKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_messengerSlotVal\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bridgeSlotKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bridgeSlotVal\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bridgeSlotKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeSlotVal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"codeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_code\",\"type\":\"bytes\"}],\"name\":\"doActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messengerSlotKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messengerSlotVal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"contract L1ChugSplashProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Like the AddressDictator, but specifically for the Proxy__OVM_L1StandardBridge. We're      working on a generalized version of this but this is good enough for the moment.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"ChugSplashDictator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"returnOwnership()\":{\"notice\":\"Transfers ownership of this contract to the finalOwner. Only callable by the finalOwner, which is intended to be our multisig. This function shouldn't be necessary, but it gives a sense of reassurance that we can recover if something really surprising goes wrong.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/L1/deployment/ChugSplashDictator.sol\":\"ChugSplashDictator\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"contracts/L1/deployment/ChugSplashDictator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { L1ChugSplashProxy } from \\\"../../chugsplash/L1ChugSplashProxy.sol\\\";\\nimport { iL1ChugSplashDeployer } from \\\"../../chugsplash/interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title ChugSplashDictator\\n * @dev Like the AddressDictator, but specifically for the Proxy__OVM_L1StandardBridge. We're\\n *      working on a generalized version of this but this is good enough for the moment.\\n */\\ncontract ChugSplashDictator is iL1ChugSplashDeployer {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    bool public isUpgrading = true;\\n    L1ChugSplashProxy public target;\\n    address public finalOwner;\\n    bytes32 public codeHash;\\n    bytes32 public messengerSlotKey;\\n    bytes32 public messengerSlotVal;\\n    bytes32 public bridgeSlotKey;\\n    bytes32 public bridgeSlotVal;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        L1ChugSplashProxy _target,\\n        address _finalOwner,\\n        bytes32 _codeHash,\\n        bytes32 _messengerSlotKey,\\n        bytes32 _messengerSlotVal,\\n        bytes32 _bridgeSlotKey,\\n        bytes32 _bridgeSlotVal\\n    ) {\\n        target = _target;\\n        finalOwner = _finalOwner;\\n        codeHash = _codeHash;\\n        messengerSlotKey = _messengerSlotKey;\\n        messengerSlotVal = _messengerSlotVal;\\n        bridgeSlotKey = _bridgeSlotKey;\\n        bridgeSlotVal = _bridgeSlotVal;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function doActions(bytes memory _code) external {\\n        require(keccak256(_code) == codeHash, \\\"ChugSplashDictator: Incorrect code hash.\\\");\\n\\n        target.setCode(_code);\\n        target.setStorage(messengerSlotKey, messengerSlotVal);\\n        target.setStorage(bridgeSlotKey, bridgeSlotVal);\\n        target.setOwner(finalOwner);\\n    }\\n\\n    /**\\n     * Transfers ownership of this contract to the finalOwner.\\n     * Only callable by the finalOwner, which is intended to be our multisig.\\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can\\n     * recover if something really surprising goes wrong.\\n     */\\n    function returnOwnership() external {\\n        require(msg.sender == finalOwner, \\\"ChugSplashDictator: only callable by finalOwner\\\");\\n\\n        target.setOwner(finalOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xd6b7d80400d6cafd7d65c00715f3f03305537e96b25ff75f13f5c3163e81256c\",\"license\":\"MIT\"},\"contracts/chugsplash/L1ChugSplashProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport { iL1ChugSplashDeployer } from \\\"./interfaces/iL1ChugSplashDeployer.sol\\\";\\n\\n/**\\n * @title L1ChugSplashProxy\\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\\n *\\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\\n * you're doing. Anything public can potentially have a function signature that conflicts with a\\n * signature attached to the implementation contract. Public functions SHOULD always have the\\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\\n */\\ncontract L1ChugSplashProxy {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\\n    // appended bytecode will be deployed as given.\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _owner Address of the initial contract owner.\\n     */\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Blocks a function from being called when the parent signals that the system should be paused\\n     * via an isUpgrading function.\\n     */\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /**\\n     * Makes a proxy call instead of triggering the given function when the caller is either the\\n     * owner or the zero address. Caller can only ever be the zero address if this function is\\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\\n     * and the proxy function ends up being called instead of the implementation one.\\n     *\\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\\n     * because the owner address can be changed dynamically and we do not want clients to have to\\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\\n     * proxied contract.\\n     */\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /*********************\\n     * Fallback Function *\\n     *********************/\\n\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\\n     * different from the standard proxy scheme where one would typically deploy the code\\n     * separately and then set the implementation address. We're doing it this way because it gives\\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\\n     * @param _code New contract code to run inside this contract.\\n     */\\n    function setCode(bytes memory _code) public proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed.\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /**\\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\\n     * upgrades in a more transparent way. Only callable by the owner.\\n     * @param _key Storage key to modify.\\n     * @param _value New value for the storage key.\\n     */\\n    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract. Only callable by the owner.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function setOwner(address _owner) public proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Owner address.\\n     */\\n    function getOwner() public proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * Queries the implementation address. Can only be called by the owner OR by making an\\n     * eth_call and setting the \\\"from\\\" address to address(0).\\n     * @return Implementation address.\\n     */\\n    function getImplementation() public proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Sets the implementation address.\\n     * @param _implementation New implementation address.\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /**\\n     * Queries the implementation address.\\n     * @return Implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /**\\n     * Changes the owner of the proxy contract.\\n     * @param _owner New owner of the proxy contract.\\n     */\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /**\\n     * Queries the owner of the proxy contract.\\n     * @return Owner address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * Gets the code hash for a given account.\\n     * @param _account Address of the account to get a code hash for.\\n     * @return Code hash for the account.\\n     */\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n\\n    /**\\n     * Performs the proxy call via a delegatecall.\\n     */\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc30cc735cf86431bd2234a3689d536aa76e5765522ff9f5b7c160deed85fa099\",\"license\":\"MIT\"},\"contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title iL1ChugSplashDeployer\\n */\\ninterface iL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9a496d99f111c1091f0c33d6bfc7802a522baa7235614b0014f35e4bbe280e57\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526000805460ff1916600117905534801561001d57600080fd5b5060405161088338038061088383398101604081905261003c916100a8565b60008054610100600160a81b0319166101006001600160a01b03998a1602179055600180546001600160a01b031916969097169590951790955560029290925560035560045560059190915560065561010f565b6001600160a01b03811681146100a557600080fd5b50565b600080600080600080600060e0888a0312156100c357600080fd5b87516100ce81610090565b60208901519097506100df81610090565b604089015160608a015160808b015160a08c015160c0909c01519a9d939c50919a90999198509650945092505050565b6107658061011e6000396000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c8063708518de11610076578063a3b2d8a51161005b578063a3b2d8a51461015c578063b794726214610165578063d4b839921461018257600080fd5b8063708518de1461014a578063907023dd1461015357600080fd5b806318edaaf2116100a757806318edaaf214610122578063297d1a34146101395780635307023b1461014157600080fd5b80630bf56f21146100c357806317ad94ec146100d8575b600080fd5b6100d66100d13660046105ed565b6101a7565b005b6001546100f89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61012b60025481565b604051908152602001610119565b6100d6610489565b61012b60045481565b61012b60035481565b61012b60065481565b61012b60055481565b6000546101729060ff1681565b6040519015158152602001610119565b6000546100f890610100900473ffffffffffffffffffffffffffffffffffffffff1681565b6002548151602083012014610243576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4368756753706c6173684469637461746f723a20496e636f727265637420636f60448201527f646520686173682e00000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b6000546040517f6c5d4ad000000000000000000000000000000000000000000000000000000000815261010090910473ffffffffffffffffffffffffffffffffffffffff1690636c5d4ad09061029d9084906004016106bc565b600060405180830381600087803b1580156102b757600080fd5b505af11580156102cb573d6000803e3d6000fd5b5050600054600354600480546040517f9b0b0fda00000000000000000000000000000000000000000000000000000000815291820192909252602481019190915261010090910473ffffffffffffffffffffffffffffffffffffffff169250639b0b0fda9150604401600060405180830381600087803b15801561034e57600080fd5b505af1158015610362573d6000803e3d6000fd5b50506000546005546006546040517f9b0b0fda0000000000000000000000000000000000000000000000000000000081526004810192909252602482015261010090910473ffffffffffffffffffffffffffffffffffffffff169250639b0b0fda9150604401600060405180830381600087803b1580156103e257600080fd5b505af11580156103f6573d6000803e3d6000fd5b50506000546001546040517f13af403500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201526101009092041692506313af40359150602401600060405180830381600087803b15801561046e57600080fd5b505af1158015610482573d6000803e3d6000fd5b5050505050565b60015473ffffffffffffffffffffffffffffffffffffffff163314610530576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4368756753706c6173684469637461746f723a206f6e6c792063616c6c61626c60448201527f652062792066696e616c4f776e65720000000000000000000000000000000000606482015260840161023a565b6000546001546040517f13af403500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff918216600482015261010090920416906313af403590602401600060405180830381600087803b1580156105a457600080fd5b505af11580156105b8573d6000803e3d6000fd5b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000602082840312156105ff57600080fd5b813567ffffffffffffffff8082111561061757600080fd5b818401915084601f83011261062b57600080fd5b81358181111561063d5761063d6105be565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610683576106836105be565b8160405282815287602084870101111561069c57600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208083528351808285015260005b818110156106e9578581018301518582016040015282016106cd565b818111156106fb576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01692909201604001939250505056fea2646970667358221220ea63e0ffbf6691431ee73a4c29831d3972b1c90e51eb75830c3242850fd79a1c64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100be5760003560e01c8063708518de11610076578063a3b2d8a51161005b578063a3b2d8a51461015c578063b794726214610165578063d4b839921461018257600080fd5b8063708518de1461014a578063907023dd1461015357600080fd5b806318edaaf2116100a757806318edaaf214610122578063297d1a34146101395780635307023b1461014157600080fd5b80630bf56f21146100c357806317ad94ec146100d8575b600080fd5b6100d66100d13660046105ed565b6101a7565b005b6001546100f89073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61012b60025481565b604051908152602001610119565b6100d6610489565b61012b60045481565b61012b60035481565b61012b60065481565b61012b60055481565b6000546101729060ff1681565b6040519015158152602001610119565b6000546100f890610100900473ffffffffffffffffffffffffffffffffffffffff1681565b6002548151602083012014610243576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4368756753706c6173684469637461746f723a20496e636f727265637420636f60448201527f646520686173682e00000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b6000546040517f6c5d4ad000000000000000000000000000000000000000000000000000000000815261010090910473ffffffffffffffffffffffffffffffffffffffff1690636c5d4ad09061029d9084906004016106bc565b600060405180830381600087803b1580156102b757600080fd5b505af11580156102cb573d6000803e3d6000fd5b5050600054600354600480546040517f9b0b0fda00000000000000000000000000000000000000000000000000000000815291820192909252602481019190915261010090910473ffffffffffffffffffffffffffffffffffffffff169250639b0b0fda9150604401600060405180830381600087803b15801561034e57600080fd5b505af1158015610362573d6000803e3d6000fd5b50506000546005546006546040517f9b0b0fda0000000000000000000000000000000000000000000000000000000081526004810192909252602482015261010090910473ffffffffffffffffffffffffffffffffffffffff169250639b0b0fda9150604401600060405180830381600087803b1580156103e257600080fd5b505af11580156103f6573d6000803e3d6000fd5b50506000546001546040517f13af403500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201526101009092041692506313af40359150602401600060405180830381600087803b15801561046e57600080fd5b505af1158015610482573d6000803e3d6000fd5b5050505050565b60015473ffffffffffffffffffffffffffffffffffffffff163314610530576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4368756753706c6173684469637461746f723a206f6e6c792063616c6c61626c60448201527f652062792066696e616c4f776e65720000000000000000000000000000000000606482015260840161023a565b6000546001546040517f13af403500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff918216600482015261010090920416906313af403590602401600060405180830381600087803b1580156105a457600080fd5b505af11580156105b8573d6000803e3d6000fd5b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000602082840312156105ff57600080fd5b813567ffffffffffffffff8082111561061757600080fd5b818401915084601f83011261062b57600080fd5b81358181111561063d5761063d6105be565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610683576106836105be565b8160405282815287602084870101111561069c57600080fd5b826020860160208301376000928101602001929092525095945050505050565b600060208083528351808285015260005b818110156106e9578581018301518582016040015282016106cd565b818111156106fb576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01692909201604001939250505056fea2646970667358221220ea63e0ffbf6691431ee73a4c29831d3972b1c90e51eb75830c3242850fd79a1c64736f6c63430008090033",
  "devdoc": {
    "details": "Like the AddressDictator, but specifically for the Proxy__OVM_L1StandardBridge. We're      working on a generalized version of this but this is good enough for the moment.",
    "kind": "dev",
    "methods": {},
    "title": "ChugSplashDictator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "returnOwnership()": {
        "notice": "Transfers ownership of this contract to the finalOwner. Only callable by the finalOwner, which is intended to be our multisig. This function shouldn't be necessary, but it gives a sense of reassurance that we can recover if something really surprising goes wrong."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "isUpgrading",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 14,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "target",
        "offset": 1,
        "slot": "0",
        "type": "t_contract(L1ChugSplashProxy)420"
      },
      {
        "astId": 16,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "finalOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 18,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "codeHash",
        "offset": 0,
        "slot": "2",
        "type": "t_bytes32"
      },
      {
        "astId": 20,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "messengerSlotKey",
        "offset": 0,
        "slot": "3",
        "type": "t_bytes32"
      },
      {
        "astId": 22,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "messengerSlotVal",
        "offset": 0,
        "slot": "4",
        "type": "t_bytes32"
      },
      {
        "astId": 24,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "bridgeSlotKey",
        "offset": 0,
        "slot": "5",
        "type": "t_bytes32"
      },
      {
        "astId": 26,
        "contract": "contracts/L1/deployment/ChugSplashDictator.sol:ChugSplashDictator",
        "label": "bridgeSlotVal",
        "offset": 0,
        "slot": "6",
        "type": "t_bytes32"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(L1ChugSplashProxy)420": {
        "encoding": "inplace",
        "label": "contract L1ChugSplashProxy",
        "numberOfBytes": "20"
      }
    }
  }
}