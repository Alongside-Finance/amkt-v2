{
  "language": "Solidity",
  "sources": {
    "contracts/chugsplash/interfaces/iL1ChugSplashDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x80fa3b4a(bytes32 c__0x80fa3b4a) pure {}\n\n\n/**\n * @title iL1ChugSplashDeployer\n */\ninterface iL1ChugSplashDeployer {\n    function isUpgrading() external view returns (bool);\n}\n"
    },
    "contracts/L1/deployment/ChugSplashDictator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x515278bc(bytes32 c__0x515278bc) pure {}\n\n\nimport { L1ChugSplashProxy } from \"../../chugsplash/L1ChugSplashProxy.sol\";\nimport { iL1ChugSplashDeployer } from \"../../chugsplash/interfaces/iL1ChugSplashDeployer.sol\";\n\n/**\n * @title ChugSplashDictator\n * @dev Like the AddressDictator, but specifically for the Proxy__OVM_L1StandardBridge. We're\n *      working on a generalized version of this but this is good enough for the moment.\n */\ncontract ChugSplashDictator is iL1ChugSplashDeployer {\nfunction c_0xf98cc2e1(bytes32 c__0xf98cc2e1) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    // slither-disable-next-line constable-states\n    bool public isUpgrading = true;\n    L1ChugSplashProxy public target;\n    address public finalOwner;\n    bytes32 public codeHash;\n    bytes32 public messengerSlotKey;\n    bytes32 public messengerSlotVal;\n    bytes32 public bridgeSlotKey;\n    bytes32 public bridgeSlotVal;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        L1ChugSplashProxy _target,\n        address _finalOwner,\n        bytes32 _codeHash,\n        bytes32 _messengerSlotKey,\n        bytes32 _messengerSlotVal,\n        bytes32 _bridgeSlotKey,\n        bytes32 _bridgeSlotVal\n    ) {c_0xf98cc2e1(0x1d0b68705bc7efab6b2054f9aa4871122b9d6b60c4669880544763e539b98bb7); /* function */ \n\nc_0xf98cc2e1(0xa5d9991c3fd24b353b6d45d358053d41ea0c8563fa05c1176947fca9f34ad266); /* line */ \n        c_0xf98cc2e1(0x57bb807b281179147c07eeff356ad649940d56e05f77e18fd5710b06993a8b24); /* statement */ \ntarget = _target;\nc_0xf98cc2e1(0x92ff5361a0fa2d54e14e8d72e96f79617b18dc4a766359648764eda6bdc9a967); /* line */ \n        c_0xf98cc2e1(0xb18e3544c11f46b054d8bff4cb8ca6e8770d703e3b714f8854ceaae2ef21b1ad); /* statement */ \nfinalOwner = _finalOwner;\nc_0xf98cc2e1(0xf217230633366dfdf3e1a526999b2885fdd0e79d95fe6632e49b1a107476c092); /* line */ \n        c_0xf98cc2e1(0x9b32e82a88a60196a3cc2e73f436afad31e37273d99bdf9f0f2851d4c44026da); /* statement */ \ncodeHash = _codeHash;\nc_0xf98cc2e1(0x75847bb1952ba944ee2f2ae488cd05de54786d12bc279245f1d6652927264382); /* line */ \n        c_0xf98cc2e1(0x42b4dcb68892483a190f0c365b578afcb1f51c3d94c99edf852c96ea336f109f); /* statement */ \nmessengerSlotKey = _messengerSlotKey;\nc_0xf98cc2e1(0x89d2227adbbb035e2599ff10b2af5a9dd126695b564e0ccce35ce29f661e2c41); /* line */ \n        c_0xf98cc2e1(0x77c41c03cc78e27a6bbb4e1ff95d8edfdec222c19f5c611611586000c64de4bb); /* statement */ \nmessengerSlotVal = _messengerSlotVal;\nc_0xf98cc2e1(0x9178952a778390ee79a20f3369dc77143d249c0d559174d8f69ed39d913cf32d); /* line */ \n        c_0xf98cc2e1(0x2f4421726e254373dca32661e727792bf3760670d20e08a7513f2a207e71f252); /* statement */ \nbridgeSlotKey = _bridgeSlotKey;\nc_0xf98cc2e1(0xfaef022058208fa21d0fd73194a014562a0dfea2535ac9dc62613431e859cf2d); /* line */ \n        c_0xf98cc2e1(0xedd9d0a0474ae67478d392fbdede774412fc4259289d48ce778338ea844324d4); /* statement */ \nbridgeSlotVal = _bridgeSlotVal;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function doActions(bytes memory _code) external {c_0xf98cc2e1(0x4205784bea257c222f41697705b1666f0e950afdb5e7e9e07aa207ee987c0e29); /* function */ \n\nc_0xf98cc2e1(0x71ff5f49587781ad286da95e823343f099778c4aa942cff70249cedb45abcc79); /* line */ \n        c_0xf98cc2e1(0xab96ad611f9477ce138ce7716447d431adc4290db15291a85601e55f68a98807); /* requirePre */ \nc_0xf98cc2e1(0xc4c49ba17686dc669002cb54f5fe4bd2789a9ab2b2aff7aeae326ac684ae9872); /* statement */ \nrequire(keccak256(_code) == codeHash, \"ChugSplashDictator: Incorrect code hash.\");c_0xf98cc2e1(0x9f006c1a0dee13fda977fb6691cb3a4d93918298065bab5259073d42ed41b170); /* requirePost */ \n\n\nc_0xf98cc2e1(0x8bec52fcb14e94a7dc80c82ac7fb2510e6ebe961623fcc0a22ed10b45bf8b42f); /* line */ \n        c_0xf98cc2e1(0xf3dc694ba89608f2e4361d72616f49a32eb3596514a71ce8c13e30c7f1e56f2d); /* statement */ \ntarget.setCode(_code);\nc_0xf98cc2e1(0xdffe048154a87cd8531bcf830394170c85f2c55a01d2fabbfa25acffde1b3676); /* line */ \n        c_0xf98cc2e1(0x928e6147e880a994fd96c0dcfa3eb06bfbe8308bdb80b31463760d1621f5befe); /* statement */ \ntarget.setStorage(messengerSlotKey, messengerSlotVal);\nc_0xf98cc2e1(0x136a42a32fa1cb4c8cb1b814a2db18166ba7d567904967e3aff5fad39c6b664c); /* line */ \n        c_0xf98cc2e1(0x41c319ad240ac8bb0c005cad8def96f9b97884f4d8c30f75d9ceaa87ba6a8cdc); /* statement */ \ntarget.setStorage(bridgeSlotKey, bridgeSlotVal);\nc_0xf98cc2e1(0x24007020bb25179d3e6899974831402d3e28a3ace2618c8d75d418df1832305a); /* line */ \n        c_0xf98cc2e1(0x59054bd13167a960923d21759bf1d3efc0e838747a39ab6716b3dd407d0a921f); /* statement */ \ntarget.setOwner(finalOwner);\n    }\n\n    /**\n     * Transfers ownership of this contract to the finalOwner.\n     * Only callable by the finalOwner, which is intended to be our multisig.\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can\n     * recover if something really surprising goes wrong.\n     */\n    function returnOwnership() external {c_0xf98cc2e1(0x8696455f5c975b93e69ccbf9cfcc269adbcdd668ccf3a5c263e59553eedc164b); /* function */ \n\nc_0xf98cc2e1(0x437c2d52bbf34ada79e30cb3b92b893f06d6072bf75c1ffb81f41c0dc8a9c0fc); /* line */ \n        c_0xf98cc2e1(0xc259e2e1b7c664f095dbd3b23f0d0d95b0c97b6ec740b6564929e81f309edcce); /* requirePre */ \nc_0xf98cc2e1(0xddae5930b6d10fa021ab8c76950e1fa8ba6ed95529375730f1b845b13a0d357c); /* statement */ \nrequire(msg.sender == finalOwner, \"ChugSplashDictator: only callable by finalOwner\");c_0xf98cc2e1(0x3fcd393e462b554f97625fbefff9bd809ad9fdde0d5011e03b476105a3a17dba); /* requirePost */ \n\n\nc_0xf98cc2e1(0x32e790f61fbd9ac3070e5ef21a6cd2691adde24866e946b77899fd9943cf0ec9); /* line */ \n        c_0xf98cc2e1(0x267fe1d6d9bc2e9190679a2cf87f64c143ec06dc15866770794d3622371dfe1d); /* statement */ \ntarget.setOwner(finalOwner);\n    }\n}\n"
    },
    "contracts/chugsplash/L1ChugSplashProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xaf2bcf1a(bytes32 c__0xaf2bcf1a) pure {}\n\n\nimport { iL1ChugSplashDeployer } from \"./interfaces/iL1ChugSplashDeployer.sol\";\n\n/**\n * @title L1ChugSplashProxy\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\n *\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\n * you're doing. Anything public can potentially have a function signature that conflicts with a\n * signature attached to the implementation contract. Public functions SHOULD always have the\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\n */\ncontract L1ChugSplashProxy {\nfunction c_0x776ce5ce(bytes32 c__0x776ce5ce) public pure {}\n\n    /*************\n     * Constants *\n     *************/\n\n    // \"Magic\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\n    // appended bytecode will be deployed as given.\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address of the initial contract owner.\n     */\n    constructor(address _owner) {c_0x776ce5ce(0xf18bd7a0361a9c9dfc72193111d67f051ad1a3baba62e5657901688d0330b7c1); /* function */ \n\nc_0x776ce5ce(0xdd78c192c2304bfe69535c394b33d4ad18c46f2a7f9f708bbf235ffda8f9c941); /* line */ \n        c_0x776ce5ce(0xe9e1bd6203985ab840a07650499bed5245e07a1e4841ad964de687401e1d2bc5); /* statement */ \n_setOwner(_owner);\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Blocks a function from being called when the parent signals that the system should be paused\n     * via an isUpgrading function.\n     */\n    modifier onlyWhenNotPaused() {c_0x776ce5ce(0xeaeb910faab96acfd3cfc505ecf4231b764265e34dee493424f707c77c33b3e1); /* function */ \n\nc_0x776ce5ce(0xe11d50a5c024e880a629d4c05810d41be2dba42cf84fffd885291ba51601104f); /* line */ \n        c_0x776ce5ce(0x45540f4a74742d53b5228fb5bf79572dc66c5b0c06478f6afd7a016137773cd5); /* statement */ \naddress owner = _getOwner();\n\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\n        // it turns out that it isn't the right type of contract.\nc_0x776ce5ce(0x3df4c1fafea61cdcf0162d953dfcb87472f8fec767f91012938feb80a5588e92); /* line */ \n        c_0x776ce5ce(0x589e8a70a4b64154d99e5fb0def4d6827b773395ded5ff033cf93e8e101892de); /* statement */ \n(bool success, bytes memory returndata) = owner.staticcall(\n            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)\n        );\n\n        // If the call was unsuccessful then we assume that there's no \"isUpgrading\" method and we\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\n        // long. If this isn't the case then we can safely ignore the result.\nc_0x776ce5ce(0xcaa31124022b8b62bf3e444a7a77659e0017df940d45e848bc7c6b5061ff4c04); /* line */ \n        c_0x776ce5ce(0xb1e9baa43a131216a9d3ddc7ff8476894e3e45d15e1dc08dab54848af434579e); /* statement */ \nif (success && returndata.length == 32) {c_0x776ce5ce(0x629616de25aa313c34fc10c054338ca18ca59338ef96767af971bf3da152d00f); /* branch */ \n\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\n            // really care about the case where this value is 0 (= false).\nc_0x776ce5ce(0xc271abd8218e49e94b3c08feb5a57645e49d463542e4c661f11f436607770350); /* line */ \n            c_0x776ce5ce(0xca3e538519441ad252e70d079de0024b874a8fbe6138ec066fab8543c256daba); /* statement */ \nuint256 ret = abi.decode(returndata, (uint256));\nc_0x776ce5ce(0x06e1495f51a48644028e2b6c600336d71ee832572b2af1492b7f64c19d7eb27c); /* line */ \n            c_0x776ce5ce(0xf00d0a22d78d6a6f5822af8c18ee515b7c57a8dd369f54a15a5869a7910e64ab); /* requirePre */ \nc_0x776ce5ce(0xbec46fd7f89655f2a819d4daec63d07fdd419de09961fcff5dac7ab736668e11); /* statement */ \nrequire(ret == 0, \"L1ChugSplashProxy: system is currently being upgraded\");c_0x776ce5ce(0x9434aa2246a02013d519dc686955febdfe9f024fb1c6d4075c46c76b6e25e58a); /* requirePost */ \n\n        }else { c_0x776ce5ce(0xa5dc433d8b5ee45b7409c9cd9b14b0aef120825d3b3d5ce589487e7819737603); /* branch */ \n}\n\nc_0x776ce5ce(0xb1a0ec63f600b19b00bcc37a52b3a316802ae9eadfafa233588319d7dfc31833); /* line */ \n        _;\n    }\n\n    /**\n     * Makes a proxy call instead of triggering the given function when the caller is either the\n     * owner or the zero address. Caller can only ever be the zero address if this function is\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\n     * and the proxy function ends up being called instead of the implementation one.\n     *\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\n     * because the owner address can be changed dynamically and we do not want clients to have to\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\n     * proxied contract.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier proxyCallIfNotOwner() {c_0x776ce5ce(0x72253dbfbee59e81b4c24e8f21219316b5b2ddad5817b44ced534e20d94e9cf4); /* function */ \n\nc_0x776ce5ce(0xdf3d4a4d8f1b7c06656bc1cb483ce8923212e34ad0581f1488e169dfcb50acfe); /* line */ \n        c_0x776ce5ce(0xed95b28ef002da0975578c78077662bd76e0613c24aab84fa0f4cedf22da9027); /* statement */ \nif (msg.sender == _getOwner() || msg.sender == address(0)) {c_0x776ce5ce(0x8bd5f62b2e2d7f775413ddb01d381491fbedbd85e3f1fa54ec364b03ce1d709e); /* branch */ \n\nc_0x776ce5ce(0x9208260574b05c5a50f8c0921d7ab1f1381601dc691947ee7d01a3411e82df4e); /* line */ \n            _;\n        } else {c_0x776ce5ce(0xdf78938e13ba77156833555f0bad5ec656e803720fb81cfbbad691418e332a19); /* branch */ \n\n            // This WILL halt the call frame on completion.\nc_0x776ce5ce(0x7c5b4d6fee1c4f28538b768d5d3ecfe9ea08e424f1aa7bc9cafdf16cb089c7bf); /* line */ \n            c_0x776ce5ce(0x873384adae5218e53ecf68d9d13173e91a6206461949ecb48bf46dfb29c3bc42); /* statement */ \n_doProxyCall();\n        }\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {c_0x776ce5ce(0x90d413e6da4330711636e8bc4edde8eedcfd01db222adc447d28e55aef9c8fed); /* function */ \n\n        // Proxy call by default.\nc_0x776ce5ce(0x9ed2262eddf26df479ff88bca17a60cc4360e37e102f84ff0c548a1a7e982ff9); /* line */ \n        c_0x776ce5ce(0x2ae09645384908abfd33c15f930bf06cdb9e8da8e0f4889da6c3a78d75837123); /* statement */ \n_doProxyCall();\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\n     * different from the standard proxy scheme where one would typically deploy the code\n     * separately and then set the implementation address. We're doing it this way because it gives\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\n     * @param _code New contract code to run inside this contract.\n     */\n    // slither-disable-next-line external-function\n    function setCode(bytes memory _code) public proxyCallIfNotOwner {c_0x776ce5ce(0x1df52813bbf9f591224f66041bccb0a4a70eafb230b94acc0814ac2c3bd94f6f); /* function */ \n\n        // Get the code hash of the current implementation.\nc_0x776ce5ce(0xd0ec1143c6e854d8a9ae19e4e52c54c75472fd7dff6dc44c99d48c12f38faaeb); /* line */ \n        c_0x776ce5ce(0x6ff92d07adf0ddf516553e0dfec7559f80f07f12153217d00b18eda630a4d0d4); /* statement */ \naddress implementation = _getImplementation();\n\n        // If the code hash matches the new implementation then we return early.\nc_0x776ce5ce(0x360b5c5f9025869ef97a54bc3dbed512c13178ccd258369f1ad88996cb2206be); /* line */ \n        c_0x776ce5ce(0xdbc3cd7d201f9fabba7c2672096189e805db6e9948cd70fd18f0fc13eb0a6134); /* statement */ \nif (keccak256(_code) == _getAccountCodeHash(implementation)) {c_0x776ce5ce(0x19f63f918f8dcf2e36fb92cb4ed3c82f3c03b32815f491e4943285f3be5cdeb5); /* branch */ \n\nc_0x776ce5ce(0xa70fcc909fd1d6cfbb89ba77539cc77a6764aa5def47780d6f6624722d9a1842); /* line */ \n            c_0x776ce5ce(0xff8dd78d4e91a3ca502da374640b98c1d41580eff6613720a7d33558e0cd8ef2); /* statement */ \nreturn;\n        }else { c_0x776ce5ce(0x9dc6764c6bd30969cfa7868c04fa98cab24d95e3929b81d367594b8551abdefd); /* branch */ \n}\n\n        // Create the deploycode by appending the magic prefix.\nc_0x776ce5ce(0x23cbba8401143d8678d8889338164af14930209f5fad6a8f1bdcb2adb2cf47ef); /* line */ \n        c_0x776ce5ce(0xd368e944fac9dffb2b2a04da038d4c309e8dc484662c0f06a8a5bf17af71d2d5); /* statement */ \nbytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\n\n        // Deploy the code and set the new implementation address.\nc_0x776ce5ce(0xe87646687cba84be969db5de1321a7a34ba6988257d4ed5edebc3f69c5103a63); /* line */ \n        c_0x776ce5ce(0x66bd558718a2464c3c1becb9a956413d13c7d49ac32751e5e5034166d54486dd); /* statement */ \naddress newImplementation;\nc_0x776ce5ce(0x23339d027123784aff58b3acd2f4cb4e0a781889e0e4dc98256abb7de2e561a3); /* line */ \n        assembly {\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\n        }\n\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\n        // actually fail this check. Should only happen if the contract creation from above runs\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\n        // should be doing this check anyway though.\nc_0x776ce5ce(0xdf95992fd046756bba921f3abbf4448cbed81a0f9cf0781824fb89c5d420ed8b); /* line */ \n        c_0x776ce5ce(0xa3a612446b19f76f6459b08a9a8dbcbfe3aa459bf30bb0903c2134d462518f98); /* requirePre */ \nc_0x776ce5ce(0x38252bb1d52f509fc9b96b19d900702579810474eabea273b48574154d26d844); /* statement */ \nrequire(\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\n            \"L1ChugSplashProxy: code was not correctly deployed.\"\n        );c_0x776ce5ce(0x02c3288fd880c9c536b883c8d31572188158479ab9d47d217d95843ff2515556); /* requirePost */ \n\n\nc_0x776ce5ce(0x9793ed299829057ef86a4d8cf589e51db8e1926a4f87586ec460111c464effd0); /* line */ \n        c_0x776ce5ce(0x110773373450862ea55838a9ac7407d174e3ba1aa74be1147d2d301dd0ec10dc); /* statement */ \n_setImplementation(newImplementation);\n    }\n\n    /**\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\n     * upgrades in a more transparent way. Only callable by the owner.\n     * @param _key Storage key to modify.\n     * @param _value New value for the storage key.\n     */\n    // slither-disable-next-line external-function\n    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {c_0x776ce5ce(0xb2c2fd7d7c4ecc3d4c846b46e02ac4b02ffb85b67bc9351eac4f6c9794e3b520); /* function */ \n\nc_0x776ce5ce(0x1a0dbdcd53acad027da057b5fe8cbb34a8959e0fb0a82d5ca12f91d517cf049a); /* line */ \n        assembly {\n            sstore(_key, _value)\n        }\n    }\n\n    /**\n     * Changes the owner of the proxy contract. Only callable by the owner.\n     * @param _owner New owner of the proxy contract.\n     */\n    // slither-disable-next-line external-function\n    function setOwner(address _owner) public proxyCallIfNotOwner {c_0x776ce5ce(0x6943061e943a5ce2c1bb0ece11e151776b5224d753cda5aa6dff8cbd8bd28dbf); /* function */ \n\nc_0x776ce5ce(0x2d4ff11be4efaca0f6899bb7fa63e64a3131ed693027802d83ad2ee5b5131caa); /* line */ \n        c_0x776ce5ce(0x5833940dbc7baf62ac66c52ef813dd92a0b61e92f96f83df796b79df55dfd3e0); /* statement */ \n_setOwner(_owner);\n    }\n\n    /**\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Owner address.\n     */\n    // slither-disable-next-line external-function\n    function getOwner() public proxyCallIfNotOwner returns (address) {c_0x776ce5ce(0x8b05d0c33b57d8e7a6fb29ccd0134359fb727f35706aabc7790ca1f27753fd6f); /* function */ \n\nc_0x776ce5ce(0xaaf47b79b24dbee63081dd75f7fa659bda230c2f182f1a397c122f6705c63ab6); /* line */ \n        c_0x776ce5ce(0x38fa29d5a03ce14d58cca314f0d7a8e4c4bed3fa7abeabc1523a2ed16b05fd0a); /* statement */ \nreturn _getOwner();\n    }\n\n    /**\n     * Queries the implementation address. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Implementation address.\n     */\n    // slither-disable-next-line external-function\n    function getImplementation() public proxyCallIfNotOwner returns (address) {c_0x776ce5ce(0xd04b11b4bb8a4e0bb60de2617e479e4f90b3476c6dac9bc84dbb3a193e16a6f1); /* function */ \n\nc_0x776ce5ce(0xcc1f0ecfaa1aec5455db029c9a24a0fcac8b73e50e41b3564ad286b64dd8d8f3); /* line */ \n        c_0x776ce5ce(0xd0cbc4cb254f3ea90267bed9c2efd048767b179a756923d604d63d7be98a3325); /* statement */ \nreturn _getImplementation();\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Sets the implementation address.\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {c_0x776ce5ce(0xa9e8fc9d956ae2195261cf2546af449815ad19b1b8b6ca3fafc6aaef9aee21b8); /* function */ \n\nc_0x776ce5ce(0x86ddfcf6c02496924c08a32a5903539dc865f864059e4e1825749c96e178211e); /* line */ \n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n    }\n\n    /**\n     * Queries the implementation address.\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {c_0x776ce5ce(0x09e4e611476c30953563611a30e2d8009e0918366cbff55bf69b36b292f566e6); /* function */ \n\nc_0x776ce5ce(0x498d532dd96a2991dee6e6e7c1e2a650c2e4473c675c0666382e2753586cb956); /* line */ \n        c_0x776ce5ce(0xd4f7cf2f296a8600e47f4f1f9e772338a1288910516a4b7e78c4da571b738cde); /* statement */ \naddress implementation;\nc_0x776ce5ce(0xde506bd03a4d5270e9e3c082be5adc3b70747eaf3f2f218ce5b091127ad981b6); /* line */ \n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\nc_0x776ce5ce(0x42310a03d964141f187387eb2410cbdd966ce7c27eaaff70ef6d82928b435a0d); /* line */ \n        c_0x776ce5ce(0x661438d03073ada2d90965ad206ffe5de1ed5236a5ebaa1c1e0c8926575471aa); /* statement */ \nreturn implementation;\n    }\n\n    /**\n     * Changes the owner of the proxy contract.\n     * @param _owner New owner of the proxy contract.\n     */\n    function _setOwner(address _owner) internal {c_0x776ce5ce(0xdc6c9e8637ba0f076d2f05dcee0017433b2a98161bcdef79d92b02dcf65c2694); /* function */ \n\nc_0x776ce5ce(0x67c2465124a9e24523c645b3553f9c2ca66268d871af0078a752b1dd4bdf1c96); /* line */ \n        assembly {\n            sstore(OWNER_KEY, _owner)\n        }\n    }\n\n    /**\n     * Queries the owner of the proxy contract.\n     * @return Owner address.\n     */\n    function _getOwner() internal view returns (address) {c_0x776ce5ce(0x0aa766e1c766e8d11ccf6ae40e85ec81fbe78dfcb4586e54f92d6fde73015989); /* function */ \n\nc_0x776ce5ce(0x0ac536864eaec38adc9fa60aae666aff848b62b43dfaad6ba5277dd4a83d6617); /* line */ \n        c_0x776ce5ce(0x2c26399eea9164d22d28af5bfe0e72088e2cb734a3a7819424ac98fa91c8a854); /* statement */ \naddress owner;\nc_0x776ce5ce(0xcbe63a6ec04b598e12bd1e3535777306ac0a6fcb5e095fa8cdbe5efce62a39ce); /* line */ \n        assembly {\n            owner := sload(OWNER_KEY)\n        }\nc_0x776ce5ce(0x047cf34423675d31c200ba325266b225e826a8624cdb2ec4d088a51c53bbe339); /* line */ \n        c_0x776ce5ce(0x529e84bf015e042e2a39afb9b9a754a51f3419179dddf5b0376432bf5a7bd2f0); /* statement */ \nreturn owner;\n    }\n\n    /**\n     * Gets the code hash for a given account.\n     * @param _account Address of the account to get a code hash for.\n     * @return Code hash for the account.\n     */\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {c_0x776ce5ce(0xec4fdc82292010eeb8e5e81cac226b16c25e0eeff4d25e53be74c1da4be27669); /* function */ \n\nc_0x776ce5ce(0xd69c56377bec237e8021cbc78c03d45579945b60ea2b0fd4c92d0d0991b40604); /* line */ \n        c_0x776ce5ce(0x40f4055c04074b2729605fd24aa25197bbc299427bd9abfea807dc82c43a56e1); /* statement */ \nbytes32 codeHash;\nc_0x776ce5ce(0xcd62849b974136bb7264f34f1258b7e8358fc5ea66180819d0634d05affea177); /* line */ \n        assembly {\n            codeHash := extcodehash(_account)\n        }\nc_0x776ce5ce(0x7278093cb6f1a2d8e3b0bb0f55b9cd9c25e801c61aeccd70bfec3cf59b14eb5a); /* line */ \n        c_0x776ce5ce(0xb1dba9d719b5ff69b96e34fa07c322143954fe955537302d6cd4bbede483339a); /* statement */ \nreturn codeHash;\n    }\n\n    /**\n     * Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal onlyWhenNotPaused {c_0x776ce5ce(0x9f85fcede76c0632212d7044385b80229f6995cc9f56da681b7ab0d067993123); /* function */ \n\nc_0x776ce5ce(0x25398881b0f6a814e6c6357f4b7251ac1f2fbb723887960634ae71c1f306e340); /* line */ \n        c_0x776ce5ce(0x0c3cba1b67f1bcc045070414ce744af6199f0f16604a6bb566057c1c9543cd7d); /* statement */ \naddress implementation = _getImplementation();\n\nc_0x776ce5ce(0xb50675efa6b8b4ec175af676d45ce86d3094c562ad91d12f8442a77b26fbb410); /* line */ \n        c_0x776ce5ce(0xd60dbc8c82be662d9bfff6512f88360a37a7ae31670e44e38af5fbd2cb28cb2a); /* requirePre */ \nc_0x776ce5ce(0xf3bf402f758fa5f81f93f7c72304232eb80eea1754402f71a84c40ba26794313); /* statement */ \nrequire(implementation != address(0), \"L1ChugSplashProxy: implementation is not set yet\");c_0x776ce5ce(0x046678df9d0490d463907aca66a0bd30c725de87fb13481fb35cd8f4dd38fb60); /* requirePost */ \n\n\nc_0x776ce5ce(0xbc9fb90884c7dd6e18b760de14f69540ea7425af4b01a1cbfeb1ed2f00a87bc3); /* line */ \n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/L1/deployment/AddressDictator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x75f31252(bytes32 c__0x75f31252) pure {}\n\n\nimport { Lib_AddressManager } from \"../../libraries/resolver/Lib_AddressManager.sol\";\n\n/**\n * @title AddressDictator\n * @dev The AddressDictator (glory to Arstotzka) is a contract that allows us to safely manipulate\n *      many different addresses in the AddressManager without transferring ownership of the\n *      AddressManager to a hot wallet or hardware wallet.\n */\ncontract AddressDictator {\nfunction c_0x59a12b1b(bytes32 c__0x59a12b1b) public pure {}\n\n    /*********\n     * Types *\n     *********/\n\n    struct NamedAddress {\n        string name;\n        address addr;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    Lib_AddressManager public manager;\n    address public finalOwner;\n    NamedAddress[] namedAddresses;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _manager Address of the AddressManager contract.\n     * @param _finalOwner Address to transfer AddressManager ownership to afterwards.\n     * @param _names Array of names to associate an address with.\n     * @param _addresses Array of addresses to associate with the name.\n     */\n    constructor(\n        Lib_AddressManager _manager,\n        address _finalOwner,\n        string[] memory _names,\n        address[] memory _addresses\n    ) {c_0x59a12b1b(0x0467f9175349172ef5685a5bd83da7e26d92cbde7f360d6e9a6c7ea20fd505a5); /* function */ \n\nc_0x59a12b1b(0xd903096fcbb3f53ed91675753dc0ebd7b02fbc051f650be91be2c402e02b2806); /* line */ \n        c_0x59a12b1b(0xa0f106c14795def2a7c7f3b5c5d41791ec280d9b289b9af9b075a1f67fed8ab2); /* statement */ \nmanager = _manager;\nc_0x59a12b1b(0x127aad1f181e4960d8dd9bd5a248909b7bc23caa8f2dcbb5e7aab2875340fb47); /* line */ \n        c_0x59a12b1b(0x40ec899b7cc6499a1242465964ce2c92055c52a14e53b9ad3e86e39850249f61); /* statement */ \nfinalOwner = _finalOwner;\nc_0x59a12b1b(0xa8b9aef678938e56f788cef7293619607763e4a4f5a40eae016fe077b1c7fb64); /* line */ \n        c_0x59a12b1b(0x71ff790d5dda8bce0ca03d918d4b5bf0ed5f9b5f06eadd8127bf406641e231f2); /* requirePre */ \nc_0x59a12b1b(0x2394e154ee0c187966bf9710e1e29a57e64d96991f2372d4e159b45fe22a4a82); /* statement */ \nrequire(\n            _names.length == _addresses.length,\n            \"AddressDictator: Must provide an equal number of names and addresses.\"\n        );c_0x59a12b1b(0xe8d065e59ea4b2dd9bf5eca0b9c241a44b84a3502119a6e361aa322b0b8010cb); /* requirePost */ \n\nc_0x59a12b1b(0xfdfb36761bd875985c7387355227e73908ce02c714fe6bcf29fb5a5fc6d573b1); /* line */ \n        c_0x59a12b1b(0x56cbd9b39efc4ffce9bc24dda24cac3d085ba41def747d4697d2d2e7bc0764f1); /* statement */ \nfor (uint256 i = 0; i < _names.length; i++) {\nc_0x59a12b1b(0xccd5ad930a6ff2bf240e10bd4ad8c0afb9836b660d7801fdbe4e47a21dec4488); /* line */ \n            c_0x59a12b1b(0x77ad08aa9437529706c193c4db62b61a8bbcf741eab875c6bc1971aedfad440d); /* statement */ \nnamedAddresses.push(NamedAddress({ name: _names[i], addr: _addresses[i] }));\n        }\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Called to finalize the transfer, this function is callable by anyone, but will only result in\n     * an upgrade if this contract is the owner Address Manager.\n     */\n    // slither-disable-next-line calls-loop\n    function setAddresses() external {c_0x59a12b1b(0x18729038b856b386f2554c433240f4f4924ee277cdc3728d205140ba2e549286); /* function */ \n\nc_0x59a12b1b(0x2bb655ecf36101d67facc13b3c92b0c710c8d304f65e07095065ba9c47720b13); /* line */ \n        c_0x59a12b1b(0x046ec7b45dc4b1762635fefb0adbf4d3612ea01ba27226642d6bf556be9a14af); /* statement */ \nfor (uint256 i = 0; i < namedAddresses.length; i++) {\nc_0x59a12b1b(0x38063f6e25005836a47c8e629f38c9dbd28f4d8d1d0e00a2e5373160dc67130f); /* line */ \n            c_0x59a12b1b(0x9c90b1f0929382099d86c5105c2fdaf200c2177933446471489550bad6de98f5); /* statement */ \nmanager.setAddress(namedAddresses[i].name, namedAddresses[i].addr);\n        }\n        // note that this will revert if _finalOwner == currentOwner\nc_0x59a12b1b(0xdd784a18f1b3d4f6acd86e8e99b5f680d1b48a7908a69a2649d164cfc84cf5fd); /* line */ \n        c_0x59a12b1b(0xce62afe387a3c4773329008073f8578cf8a3cf65d18047a005b8778253c4b4ad); /* statement */ \nmanager.transferOwnership(finalOwner);\n    }\n\n    /**\n     * Transfers ownership of this contract to the finalOwner.\n     * Only callable by the Final Owner, which is intended to be our multisig.\n     * This function shouldn't be necessary, but it gives a sense of reassurance that we can recover\n     * if something really surprising goes wrong.\n     */\n    function returnOwnership() external {c_0x59a12b1b(0x695c9b22f126788e52572f83e21870302ae7768b9fe09bec6152ba59a55be24c); /* function */ \n\nc_0x59a12b1b(0x79427e00dacd99110829d17cd5cad230dc4b36c1ea40574edf093aee6b3cd0f5); /* line */ \n        c_0x59a12b1b(0xc824a3ff23289025f6830bdd34838ebae692c40655c249e0497567f3dc62a2ce); /* requirePre */ \nc_0x59a12b1b(0x23daf5575ad1e8f8020b38d8847aacfbffd15a698ffbb577530a4ae481637977); /* statement */ \nrequire(msg.sender == finalOwner, \"AddressDictator: only callable by finalOwner\");c_0x59a12b1b(0xb8cfc98081574556562d3efb6eecc88afcc5144523895d0559a50182c5900c7c); /* requirePost */ \n\nc_0x59a12b1b(0x21211677884d1923ad5e74adad1217423a5adff749b0c02dd2482a6911f23ee4); /* line */ \n        c_0x59a12b1b(0xc49c401422dcb743d5eb50e9fbefc109c445299b4b81ec17189272ad8ddd7f8b); /* statement */ \nmanager.transferOwnership(finalOwner);\n    }\n\n    /******************\n     * View Functions *\n     ******************/\n\n    /**\n     * Returns the full namedAddresses array.\n     */\n    function getNamedAddresses() external view returns (NamedAddress[] memory) {c_0x59a12b1b(0x6a49c412df0d5201327a6bd2bed04ce188935a77795c9dc5334ece755ecbe376); /* function */ \n\nc_0x59a12b1b(0x053ffb52081cd7fbce3826a62c9fbba8f6fa31bb0da935c99e1fa2536e80b82f); /* line */ \n        c_0x59a12b1b(0x417dc35ee28661ccb7aa2c1249ca5fea9cae6027d30bb9011aadd27c4936f029); /* statement */ \nreturn namedAddresses;\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xbd50509b(bytes32 c__0xbd50509b) pure {}\n\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\nfunction c_0x1dd4f360(bytes32 c__0x1dd4f360) public pure {}\n\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => address) private addresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the address associated with a particular name.\n     * @param _name String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {c_0x1dd4f360(0x12ebe113f9ef1ead08a337532e4d5291ced9b31fd792f055be89a62996c5a776); /* function */ \n\nc_0x1dd4f360(0x4367f4a633acb3b6497d09af4a035e949e117b238c510194818485d355b206cf); /* line */ \n        c_0x1dd4f360(0x0b85ea11926e747eca9323fd945ee9ecb5ae5339fc7318326ba722d5528711b1); /* statement */ \nbytes32 nameHash = _getNameHash(_name);\nc_0x1dd4f360(0xc567908291d610cd6df753e04212914994c2df4ff8c7f1aa3b7129d1fff698f9); /* line */ \n        c_0x1dd4f360(0x22c03bed91901289d90f106da137b11a2576ac157f18574047b1e75226d80e53); /* statement */ \naddress oldAddress = addresses[nameHash];\nc_0x1dd4f360(0xab879bb4ebfe32baf3f11253e9702fb1e78b33058df0c4e385ac908f5f782d7c); /* line */ \n        c_0x1dd4f360(0x4bf5abd0f45e4586771ca825e4c1efa6f9bd6a7a5c5e85959fb1a5404e12147f); /* statement */ \naddresses[nameHash] = _address;\n\nc_0x1dd4f360(0x1f68ee0f52f6dae021297a9d916c8f85cb4344169b952725fb0e7d7ccb22afd8); /* line */ \n        c_0x1dd4f360(0x2fd5d7a59018acde2c14f90d2bd572fe826af96b46cac08338c4083c39a20fff); /* statement */ \nemit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * Retrieves the address associated with a given name.\n     * @param _name Name to retrieve an address for.\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {c_0x1dd4f360(0xbf33d11f9ac98eff64382cc20ec33abfcb2ee01e29947827c52b23f822ab0b7d); /* function */ \n\nc_0x1dd4f360(0x1315a04fbd805de2ee41edeeec0229003c1c051b2e6cf5613ad86faa0b6f42da); /* line */ \n        c_0x1dd4f360(0x5e831366e28ec516efd9c91105287c0268b5b3b239f626967f6b71bdefa03bb0); /* statement */ \nreturn addresses[_getNameHash(_name)];\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Computes the hash of a name.\n     * @param _name Name to compute a hash for.\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {c_0x1dd4f360(0x4791a0c8c1b4cdbc7299d8832ad35308d42ec4b2f0dc1daabe85de499203e89b); /* function */ \n\nc_0x1dd4f360(0xbd8948a0975d500bce7c97ecf5e11e5bcc8b2cb53d6e4179df65e6ba95fcea08); /* line */ \n        c_0x1dd4f360(0x7610f3bb2795360354031993b5d920984f5372eac8b2f107a382a5780f3f1713); /* statement */ \nreturn keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_ResolvedDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x2c33acb6(bytes32 c__0x2c33acb6) pure {}\n\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_ResolvedDelegateProxy\n */\ncontract Lib_ResolvedDelegateProxy {\nfunction c_0xf5dcb978(bytes32 c__0xf5dcb978) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    // Using mappings to store fields to avoid overwriting storage slots in the\n    // implementation contract. For example, instead of storing these fields at\n    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.\n    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html\n    // NOTE: Do not use this code in your own contract system.\n    //      There is a known flaw in this contract, and we will remove it from the repository\n    //      in the near future. Due to the very limited way that we are using it, this flaw is\n    //      not an issue in our system.\n    mapping(address => string) private implementationName;\n    mapping(address => Lib_AddressManager) private addressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     * @param _implementationName implementationName of the contract to proxy to.\n     */\n    constructor(address _libAddressManager, string memory _implementationName) {c_0xf5dcb978(0xf569e9c3723ea747c921d52f94625b6fd5e8e73dc2a9980277e2fdc3c4f3eac9); /* function */ \n\nc_0xf5dcb978(0x64d9fd78cf4c8b0e8eb8d198eaaee6808cd2b4826373c14699b726d6f36ada3f); /* line */ \n        c_0xf5dcb978(0x31236ac2ea8c7413d3cc163ce1684897542a558a03fe1cc1d2ee9ac27dbfca9a); /* statement */ \naddressManager[address(this)] = Lib_AddressManager(_libAddressManager);\nc_0xf5dcb978(0x1a04c020d454544f2622c32c66e944cd7b615ceb451a6b9b71050e8e7e5712bb); /* line */ \n        c_0xf5dcb978(0x5ebb98323d8060991ebb3b2d05e87d1b1d4895e2e2b5b7afb44ff600eaa1793d); /* statement */ \nimplementationName[address(this)] = _implementationName;\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback() external payable {c_0xf5dcb978(0x941bf95c7048dc3f4b84e8db3e8d17b36ec8d9ad3029192d1c2fdf77365c0443); /* function */ \n\nc_0xf5dcb978(0x843782d71d8e7dd22522804d2453cc3a2638e20244282978106b919d14063020); /* line */ \n        c_0xf5dcb978(0x07f0a39e630cd393768cc30d90ff20c4d4af9ea1c209c21c39e1283c9cd9fafc); /* statement */ \naddress target = addressManager[address(this)].getAddress(\n            (implementationName[address(this)])\n        );\n\nc_0xf5dcb978(0x053fb25459143065bbef3f52c22134aa0180471ea690662e35c9b3ead589ba8e); /* line */ \n        c_0xf5dcb978(0x704eca6b5ac40140d26c4866d58fe35da19db16065495972d01957266ec8e3af); /* requirePre */ \nc_0xf5dcb978(0x5b6378a2a00415ea37f30dde4eab129ccc5c5f200605f3d0efb63f43b58ce557); /* statement */ \nrequire(target != address(0), \"Target address must be initialized.\");c_0xf5dcb978(0xdd79e6784133dd41e9b3ca642675c60978899d31f8902040c3aa88053c53232f); /* requirePost */ \n\n\n        // slither-disable-next-line controlled-delegatecall\nc_0xf5dcb978(0xfdd6bc1ccdf239a47332b5c798e1c7c65297f12abbaf10188870c47b52f777b2); /* line */ \n        c_0xf5dcb978(0xb902afc8be3aebc4868db480ca9d91a99863c9da3b4516c5fcc22892c467c2b1); /* statement */ \n(bool success, bytes memory returndata) = target.delegatecall(msg.data);\n\nc_0xf5dcb978(0xae3c7bfa1936a1dcc1a594a0bcf48352677c2039e1e72058bfc702c2bd74daa3); /* line */ \n        c_0xf5dcb978(0x2e1229538617dd4cc2bb383f079bb7d88e69f857da393e35c273671fe3fbecb1); /* statement */ \nif (success == true) {c_0xf5dcb978(0x63bcb4149ff0b6c4b800f7d655999b02a2f2242e0ce121da2cf6f76573926cdf); /* branch */ \n\nc_0xf5dcb978(0x3972e50871bede8da885564517b8ca8c077afa5b88e6c8d02e713f57be952844); /* line */ \n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {c_0xf5dcb978(0x2147fe3f05369c955cc7ea0f847fab274666c1cd5b4b2cadca94ab486d6a09ad); /* branch */ \n\nc_0xf5dcb978(0x701312fa525230e08bbe6c999ee738fbb66fbe411d769ab04c60e79ab6be4e4a); /* line */ \n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/resolver/Lib_AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xc4cb528d(bytes32 c__0xc4cb528d) pure {}\n\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_AddressResolver\n */\nabstract contract Lib_AddressResolver {\nfunction c_0xb9519e7a(bytes32 c__0xb9519e7a) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    Lib_AddressManager public libAddressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     */\n    constructor(address _libAddressManager) {c_0xb9519e7a(0x7a3ee2a653c72c0b72b68711e7f7ffcf1a3eb635953605c605b372ee6a2005e4); /* function */ \n\nc_0xb9519e7a(0x35770e5a78931ec8bd61bcf5f4da8d4e19cab3478baf3c8db5b9532650e19c25); /* line */ \n        c_0xb9519e7a(0xc4ce4c18ac40ec5999cad1429c3cb45b721ddce87a291561b3c6cb13c8083cc6); /* statement */ \nlibAddressManager = Lib_AddressManager(_libAddressManager);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Resolves the address associated with a given name.\n     * @param _name Name to resolve an address for.\n     * @return Address associated with the given name.\n     */\n    function resolve(string memory _name) public view returns (address) {c_0xb9519e7a(0x870b80a72545558744eff9eae609d965f39921e5edae29e858b111f897e9458c); /* function */ \n\nc_0xb9519e7a(0xe92c3d12eaa9298a7fbe927edbaa765ec50f5d19dbf59f4f4afe93fe71079857); /* line */ \n        c_0xb9519e7a(0x5211e76e7d9faba1bdef00997bd8e24bd17b8c8d256e2a6e2b768a1898d62720); /* statement */ \nreturn libAddressManager.getAddress(_name);\n    }\n}\n"
    },
    "contracts/L1/verification/BondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x7cdc76f3(bytes32 c__0x7cdc76f3) pure {}\n\n\n/* Interface Imports */\nimport { IBondManager } from \"./IBondManager.sol\";\n\n/* Contract Imports */\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/**\n * @title BondManager\n * @dev This contract is, for now, a stub of the \"real\" BondManager that does nothing but\n * allow the \"OVM_Proposer\" to submit state root batches.\n *\n */\ncontract BondManager is IBondManager, Lib_AddressResolver {\nfunction c_0xaff0b0c8(bytes32 c__0xaff0b0c8) public pure {}\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(address _libAddressManager) Lib_AddressResolver(_libAddressManager) {c_0xaff0b0c8(0x015aabb58c6263893d5df1d2b1d33697b63f4ebae86d8fa64e0c2a2b6aa1c686); /* function */ \n}\n\n    /**\n     * Checks whether a given address is properly collateralized and can perform actions within\n     * the system.\n     * @param _who Address to check.\n     * @return true if the address is properly collateralized, false otherwise.\n     */\n    // slither-disable-next-line external-function\n    function isCollateralized(address _who) public view returns (bool) {c_0xaff0b0c8(0x123b0d0096998cd5695a6462bcfc2dbff1d822c01cf8594bf6b77c91909bbf3c); /* function */ \n\n        // Only authenticate sequencer to submit state root batches.\nc_0xaff0b0c8(0x1857e3bedbcf8eebba310e69b8aca76d8887320b5c841814ad67925b14bc8923); /* line */ \n        c_0xaff0b0c8(0x9fc6575d2d37031ec3da1a5a7adf47aab6349e63a5010127eaa97428727a22ab); /* statement */ \nreturn _who == resolve(\"OVM_Proposer\");\n    }\n}\n"
    },
    "contracts/L1/verification/IBondManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x0e5489ef(bytes32 c__0x0e5489ef) pure {}\n\n\n/**\n * @title IBondManager\n */\ninterface IBondManager {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function isCollateralized(address _who) external view returns (bool);\n}\n"
    },
    "contracts/L1/rollup/StateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x2100e9dd(bytes32 c__0x2100e9dd) pure {}\n\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\n\n/* Interface Imports */\nimport { IStateCommitmentChain } from \"./IStateCommitmentChain.sol\";\nimport { ICanonicalTransactionChain } from \"./ICanonicalTransactionChain.sol\";\nimport { IBondManager } from \"../verification/IBondManager.sol\";\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title StateCommitmentChain\n * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which\n * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).\n * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique\n * state root calculated off-chain by applying the canonical transactions one by one.\n *\n */\ncontract StateCommitmentChain is IStateCommitmentChain, Lib_AddressResolver {\nfunction c_0x65cecced(bytes32 c__0x65cecced) public pure {}\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 public FRAUD_PROOF_WINDOW;\n    uint256 public SEQUENCER_PUBLISH_WINDOW;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager,\n        uint256 _fraudProofWindow,\n        uint256 _sequencerPublishWindow\n    ) Lib_AddressResolver(_libAddressManager) {c_0x65cecced(0xd3fca0d54be1e9b029421c887ba2ee96be7e5a6c945d06cf06e51f9879d01b9b); /* function */ \n\nc_0x65cecced(0xc10d2ef6d90248ae6cbe3b31565a747e5ad5ad35767ca35aaa5e07bcbab89f23); /* line */ \n        c_0x65cecced(0xc512ba9120ce7138f0785ca4431560c0c18851bbb37407187f898b562d11fcb5); /* statement */ \nFRAUD_PROOF_WINDOW = _fraudProofWindow;\nc_0x65cecced(0x58dcf8e6e657e0d0adb98a8e0490a09b05acb527075c9e3c4caa0a3ebb12318f); /* line */ \n        c_0x65cecced(0x547f98e53b36f66e00322eddce8ad27b9dc6137699168a3035a6333116e974ad); /* statement */ \nSEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() public view returns (IChainStorageContainer) {c_0x65cecced(0xb85381407f77ada7c4725bfdab437d949c27a498bf2d0154abf68e98a912afe6); /* function */ \n\nc_0x65cecced(0x5bb3a8725ae0776b9f08c21133251b30064b579415bf401f2711be3d40ed9e45); /* line */ \n        c_0x65cecced(0x6099fe0d373807e0ae6b22bd6119ff8790ac2d4c8151f711e037eb087363ba0b); /* statement */ \nreturn IChainStorageContainer(resolve(\"ChainStorageContainer-SCC-batches\"));\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function getTotalElements() public view returns (uint256 _totalElements) {c_0x65cecced(0x0752aa0838943cc6fcdf3ccb64a4fda449da079d38318c04650b98e8f6692ec7); /* function */ \n\nc_0x65cecced(0xa96476f174990da2432a712e2357845a9646262e7ed995c43b70b33e8aaa3616); /* line */ \n        c_0x65cecced(0x3b260d4d4d6ead3d0199371a81f2750ac0b7d61d426796242355f1707955488e); /* statement */ \n(uint40 totalElements, ) = _getBatchExtraData();\nc_0x65cecced(0x99a5e8363718e6be5556c7d4511235a75ab0657eb7a88d0a993a6cdfe23c01f6); /* line */ \n        c_0x65cecced(0x159b02ebf5c0d48e7b49346eb5af423d8ff4c019348ea238ac98b43ebc180249); /* statement */ \nreturn uint256(totalElements);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function getTotalBatches() public view returns (uint256 _totalBatches) {c_0x65cecced(0x11f9eb5a4a9b232a4e3259b8e69a9a169de20ce5dc13b6fc10f533bf5375e23a); /* function */ \n\nc_0x65cecced(0xe3fa7a38c197dcb8fc8dbfb788f732939cf2811b7c3e9cbf920e8bc48f3a9620); /* line */ \n        c_0x65cecced(0x51c65e6f6301858add7f62d797b7911119dda660eab1dede1be7d38b70af4ebd); /* statement */ \nreturn batches().length();\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function getLastSequencerTimestamp() public view returns (uint256 _lastSequencerTimestamp) {c_0x65cecced(0x5f9e24edee9e33417506e40d16a45524d23696a43415ed6de59b173ba7a4bd35); /* function */ \n\nc_0x65cecced(0x55d016680bfc8558052c7bed366e7b2be4100b26aa57f0ee5f9e260402b8a7e9); /* line */ \n        c_0x65cecced(0x4797a22c7da63bb072f99853e24ba60316ca15fe87382dfaa2521ea4063c69be); /* statement */ \n(, uint40 lastSequencerTimestamp) = _getBatchExtraData();\nc_0x65cecced(0xaca4ddc056ffefe722a994df423012e60e6ba954243f3c6010cb7135a23060ab); /* line */ \n        c_0x65cecced(0xacbbf183b1029da0b10369645aaa65c25c8a8a9e3823bb9526323b1d17d5c4db); /* statement */ \nreturn uint256(lastSequencerTimestamp);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {c_0x65cecced(0xbeec219d56c84df6a87afc999dd1e8a7ab133439c9fefd15cebbf3f72be33b39); /* function */ \n\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\nc_0x65cecced(0xb6983c85bcd56019d18cf870479d24183bdfa2302490e642b2362c025f59f5a2); /* line */ \n        c_0x65cecced(0x1f280e2ee19c4902ece4f6da1cde2066da54f92664745d0de0af73acefae5ee2); /* requirePre */ \nc_0x65cecced(0x28785c9c09f60fae1f2bcd264e832a9c989d4f20912d9f9a85925c4e2db0ac0b); /* statement */ \nrequire(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );c_0x65cecced(0x236512a57f6640b03e9af4c07bfd618dcacc42003ea062cd4f894a96b562aee5); /* requirePost */ \n\n\n        // Proposers must have previously staked at the BondManager\nc_0x65cecced(0x80a35ea589d8a2b9fdf8b97d5410d8ee6cf99acc31fcccdf445266dc410f00ea); /* line */ \n        c_0x65cecced(0x74cc508f43cf68181c0faebf34c7244d00cb3b4d7e777147303f11605c22e1b2); /* requirePre */ \nc_0x65cecced(0x443db77e7b3de6de7aac45a5f19a96e3999846f3d0efa44561da927273cf100c); /* statement */ \nrequire(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );c_0x65cecced(0x43c59a99f64504e7fd5e1600dab27970df683f62c5979af7429dd0f0e37bd805); /* requirePost */ \n\n\nc_0x65cecced(0x7a694f98c8cb4cd2a171c6cc418141fcfdc8a1b0651da8cf158da2d66feda839); /* line */ \n        c_0x65cecced(0xca6935cef4c6bff38a261bc7ceca48a292f5a56d26542009a226001f2d62d4ef); /* requirePre */ \nc_0x65cecced(0x551c1d50b5c91e8016951258910d09e0051973224f32fbb63890da91336bb6eb); /* statement */ \nrequire(_batch.length > 0, \"Cannot submit an empty state batch.\");c_0x65cecced(0x6c4e74401dbc5cdd0c1f234ed27159ca15e3c7ea16fde357ccbfe70f66ce0942); /* requirePost */ \n\n\nc_0x65cecced(0x00d9894575be5a841bf165c42517393e3f7aeb7cdbdf47c328e62ae27a7fc8b1); /* line */ \n        c_0x65cecced(0x5e55d3560343db2a04b48dbfdf2ed7825749de606c8d46d1a2053e95d48ee209); /* requirePre */ \nc_0x65cecced(0x0cd90ec2a4b917eddafc7cf6643946e70ed330358edc149676c48e80634b91f0); /* statement */ \nrequire(\n            getTotalElements() + _batch.length <=\n                ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );c_0x65cecced(0x975463b6993d7425fd773c2d06fcfd384481976385c016eb06db5461dbda16de); /* requirePost */ \n\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\nc_0x65cecced(0x8ebbad33ced4e63925878ef4faeef19b9b81bdbc8f856f32de886c402249ccea); /* line */ \n        c_0x65cecced(0x9b700c45bbb9c0a11c4f30f6844e5c0cf74aeb02b1fb4adf593aa12c79bb207a); /* statement */ \n_appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {c_0x65cecced(0x3fc5408f89de1688a912af7bd8915ccaff144934170c7a5a84a11bcd67203310); /* function */ \n\nc_0x65cecced(0x647dd94525750765b66efefa65149146ce5b9097e6e6ae3b18639aa7476b97a9); /* line */ \n        c_0x65cecced(0x40d3228fd8b22e1124c4177f7debfad6c5639bc85c4feb96e742b150eef6c4b0); /* requirePre */ \nc_0x65cecced(0x99fd7b05aedd9f5427404ea83611cd2e319cff2c3c2fd5dda1531c07168fa959); /* statement */ \nrequire(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );c_0x65cecced(0x85a1d93da4c71422eb2078a6e1d02d206caa38655a148fe210ba86a41bff91ae); /* requirePost */ \n\n\nc_0x65cecced(0x4e4b394f000b117830b447eeab67c3421dbdec973942d7f8ba86745d6c1c035a); /* line */ \n        c_0x65cecced(0xbf6e1003484020c83f0305fad036d2ddbff06bc63953f0bddac2e15cc41bf8e7); /* requirePre */ \nc_0x65cecced(0x4efcf5408e710273c1d9da4dd3c4e3e400ba800e35c19b5072bc64b512fda65d); /* statement */ \nrequire(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");c_0x65cecced(0xea4a464c2d4b2cab554023b8af798a913bc4b495c4030f06c3505d6ca67bfbb2); /* requirePost */ \n\n\nc_0x65cecced(0x7851193d8740da3efb157f99fa04a6d9ceedc3baf7765f40c21138e7a302a01a); /* line */ \n        c_0x65cecced(0x5bced9a1b0b554f31d1f1d3e5a90d6da7a4ee3dfb83900e10b148ec183a93c66); /* requirePre */ \nc_0x65cecced(0x1250ba00873add97d2da1ad8a9f905244d5a6f5b1d24156426415ce3587cc330); /* statement */ \nrequire(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );c_0x65cecced(0x7201693a06f97dd678865a8eb91a4afabf82ec87935c8321db60b6a862c4486a); /* requirePost */ \n\n\nc_0x65cecced(0x4f90c09cc9defe809971a8120770c63dbcfc02316d30361f41ed9d8e3ea6420f); /* line */ \n        c_0x65cecced(0x95e60abcad28458e2779d1e8ed31bf4fab24176b85cb2957c4cb58413acadb9a); /* statement */ \n_deleteBatch(_batchHeader);\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    // slither-disable-next-line external-function\n    function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    ) public view returns (bool) {c_0x65cecced(0xce6a49545514b88ac3fe1874eb7e9ce660bd8812083fe44f294dbb86c6889e0e); /* function */ \n\nc_0x65cecced(0xf70af578d880c5941f1a45da1dbf3198237fa3c0d090f8c3816f6dd7c55f441a); /* line */ \n        c_0x65cecced(0x5a8a256edc748c12e98a2e7d490b8702e1f1e9bb13cedf9ce442afbda365b1cf); /* requirePre */ \nc_0x65cecced(0x55a78cd5c3ec626e49315ba6c3271f60c2e94aeca14735568b6eec004ee6b645); /* statement */ \nrequire(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");c_0x65cecced(0xddedf2f387c4f76ddca107d7ca3d4678a8c1ee14aeae553cc8fb97ed06b4b3cf); /* requirePost */ \n\n\nc_0x65cecced(0xcf325ebbacc95b0aaee626bf2145980ac065904a45049be433321bebad3bef13); /* line */ \n        c_0x65cecced(0xe8f3b9c9c29430d5951a1160d501ffd20cda7ea4b6c89f3f556fb3075c4dafb1); /* requirePre */ \nc_0x65cecced(0xd10d898e25725079324eb0385365ed86130132266dc017a09d64c94df0a8ab7a); /* statement */ \nrequire(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );c_0x65cecced(0xfeb0dbd7b44c5e944a1789162d9c9630b32320076228f1387148cc743b44f642); /* requirePost */ \n\n\nc_0x65cecced(0x0c444caf35508c661da99dd1cde153be41ad77be20648642dfb5045571df8c03); /* line */ \n        c_0x65cecced(0x7920508f5d262df47fb0157958dcad357d67c7b5abcaa56dee6c8a8e3d6a8c81); /* statement */ \nreturn true;\n    }\n\n    /**\n     * @inheritdoc IStateCommitmentChain\n     */\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n        public\n        view\n        returns (bool _inside)\n    {c_0x65cecced(0xdc07713676cfd1cda13642694caef71a67f0f2ac47791673d0004d082189dae5); /* function */ \n\nc_0x65cecced(0xa6d76bd0c7d8567af1f51106afbfef0411ddda0523c75fef1ce92034872d949c); /* line */ \n        c_0x65cecced(0x86af45b8bd9caf534a4ed60724296eb75298a2882a498bdcd50bd1ab4a54d731); /* statement */ \n(uint256 timestamp, ) = abi.decode(_batchHeader.extraData, (uint256, address));\n\nc_0x65cecced(0x63e9ab2c6d9a6407d65a85c9d94cf3597708f5a848354b56dda74886446bf7f4); /* line */ \n        c_0x65cecced(0x1ac901514a349ba1d169f32e1969edb9518b27748cb1dda4e5dcf2f9d65cea0f); /* requirePre */ \nc_0x65cecced(0x030e86a1e16c5677aa44c0d1fff1923eb6452d5a7f334f65f5e68a883714406a); /* statement */ \nrequire(timestamp != 0, \"Batch header timestamp cannot be zero\");c_0x65cecced(0xf3b3739e6f52a9924b279babedb22bcb87afcb98704927e18e043e785bf61c25); /* requirePost */ \n\nc_0x65cecced(0x7581271d0e40e012db35099333a558bd0d51310ee8a37318fba59c98cd903e8e); /* line */ \n        c_0x65cecced(0x83716f221d6d361d3ac0512b81b915a63c9ccd987cf94a40d95756f03b230958); /* statement */ \nreturn (timestamp + FRAUD_PROOF_WINDOW) > block.timestamp;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Timestamp of the last batch submitted by the sequencer.\n     */\n    function _getBatchExtraData() internal view returns (uint40, uint40) {c_0x65cecced(0x27f5eec5e77a3b7212dd03d7e3c3998c2ecb2cdee3922449e1d526278125beb7); /* function */ \n\nc_0x65cecced(0x522a8380d95c9240f614c58f7979bda0f950ffdadba141f90a6adc0dc04cca56); /* line */ \n        c_0x65cecced(0x454173c9026c9901f8d84e45d297a339cab8360658614e1681b43c32e9ae6e40); /* statement */ \nbytes27 extraData = batches().getGlobalMetadata();\n\n        // solhint-disable max-line-length\nc_0x65cecced(0x29e7446dab939564f6bab6d488ba79a2d7da1a9fd97a3cb082cbc54f53ecf674); /* line */ \n        c_0x65cecced(0xd17bfe4c1aa3d8853b11491141584af694a9093f0598ff0b5f0d3b8fb2149047); /* statement */ \nuint40 totalElements;\nc_0x65cecced(0x4c5b383a574a57dbb2faff8ca97acf9e8db945e2d5da2007e40e237e83c21945); /* line */ \n        c_0x65cecced(0x5fc2f8d41f71c5519ab36452854bda9165fb55cc7d73f8784666ba4f20838834); /* statement */ \nuint40 lastSequencerTimestamp;\nc_0x65cecced(0x86859b56ccfa75ce19593680d4b1e7b07b9b4a05ee70ef6235b98ac70b5b7050); /* line */ \n        assembly {\n            extraData := shr(40, extraData)\n            totalElements := and(\n                extraData,\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            lastSequencerTimestamp := shr(\n                40,\n                and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)\n            )\n        }\n        // solhint-enable max-line-length\n\nc_0x65cecced(0x9ff17e2f10a4272474d3c73845756ede61c5ee67a136280bd4e14dac88dfefeb); /* line */ \n        c_0x65cecced(0x55378180563bc030596dff275e8f77103e515db09b18b34fbe3dda112bfc3b01); /* statement */ \nreturn (totalElements, lastSequencerTimestamp);\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(uint40 _totalElements, uint40 _lastSequencerTimestamp)\n        internal\n        pure\n        returns (bytes27)\n    {c_0x65cecced(0xf6251a0d062b1bc349f4f7db739ea08068437e5225bf4edd3fde85af21b32b8e); /* function */ \n\nc_0x65cecced(0xa4bc207922ab6f7c1ab97b8892cc007fcdb6363c4fbed225d04375f992b2f7d3); /* line */ \n        c_0x65cecced(0x87a27c95358bb0d1447aa72d4037b83741c617ae50363fd1aeb01e5fb23fa061); /* statement */ \nbytes27 extraData;\nc_0x65cecced(0x72f71e7a5e999f3ea2a16f6aadc5f28c87d1b9127bfda14493f1e5bed91fd68b); /* line */ \n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\n            extraData := shl(40, extraData)\n        }\n\nc_0x65cecced(0x55ad5db4b1ea62acc988eb177bedf29ec7ba64b457612baf3d027cbd3b4129e3); /* line */ \n        c_0x65cecced(0x787398313191de246830525157f8d62246f91a551f3b7d9951371a8cd8e42381); /* statement */ \nreturn extraData;\n    }\n\n    /**\n     * Appends a batch to the chain.\n     * @param _batch Elements within the batch.\n     * @param _extraData Any extra data to append to the batch.\n     */\n    function _appendBatch(bytes32[] memory _batch, bytes memory _extraData) internal {c_0x65cecced(0xf3c92ff03193a3329a5c55a663e5472bba837824cd6d6387b368db3fd050d351); /* function */ \n\nc_0x65cecced(0xf5af89c57a7870eb0e49c30e286449bed0d4fbcc25bb94e32fa9d51732897db5); /* line */ \n        c_0x65cecced(0xca8f198e4864054f2a08dd3358eb7038fbc21480eba431ab610fad17e4c6ceeb); /* statement */ \naddress sequencer = resolve(\"OVM_Proposer\");\nc_0x65cecced(0xc50139458b20980f3a7130cd2c107aa88e7ba4563a7dbfd0855a4e48bee43b23); /* line */ \n        c_0x65cecced(0x4abade5ad2375ebd17ace9880523b7efea7879a1c0945115abc9c1538aff35ce); /* statement */ \n(uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraData();\n\nc_0x65cecced(0x6c94ad53a63a673a8c5943112ab7b1430529a32652e9f9d056c3c6b38e122956); /* line */ \n        c_0x65cecced(0x1aef95a40eef82137ca7e579a55193e3735ceed15c191364e7b8672bb50d67e1); /* statement */ \nif (msg.sender == sequencer) {c_0x65cecced(0x193149f493ca708ef73ef77f6b743b1e9042578fde5fd733b1b0e7c57a2dfd56); /* branch */ \n\nc_0x65cecced(0x4f81e8f5b523f5c7bce91cdec14991f7a081d400d089283756e5fc3b26755e5d); /* line */ \n            c_0x65cecced(0x745fec153af63d98c158e65d3373fe9c251e3ff2402b2338a62149a63bef9b79); /* statement */ \nlastSequencerTimestamp = uint40(block.timestamp);\n        } else {c_0x65cecced(0x83aeaf0edf06fce629837fc187b1ddcd640430ea6bb69d6d08a82e1422670dd1); /* branch */ \n\n            // We keep track of the last batch submitted by the sequencer so there's a window in\n            // which only the sequencer can publish state roots. A window like this just reduces\n            // the chance of \"system breaking\" state roots being published while we're still in\n            // testing mode. This window should be removed or significantly reduced in the future.\nc_0x65cecced(0x86f8e3f4216a356f4e2b6de6c5263f8b3aaef691b3f7581480b5dc3f915284a0); /* line */ \n            c_0x65cecced(0x9bd6a231916c770f4cbc34c62179824365397d330604888c6e6f14b4652223b2); /* requirePre */ \nc_0x65cecced(0x5fc8a7572c2a91509283e72dbd9a3730a2bf9564bc8797c5153361bfb5ed6f77); /* statement */ \nrequire(\n                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,\n                \"Cannot publish state roots within the sequencer publication window.\"\n            );c_0x65cecced(0x9858dd72eced099cc3e23490ecfaac4da39636065a2a1a1525a29f1affd3c8ea); /* requirePost */ \n\n        }\n\n        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place\n        // while calculating the root hash therefore any arguments passed to it must not\n        // be used again afterwards\nc_0x65cecced(0xe340ad848eb2e40698952f8624fe9242cef49ae8f40c6fb4e95c6e18dba9e974); /* line */ \n        c_0x65cecced(0xb8fec50fc6ace7dcdbe9d4dd63d851282ed51229499e25fe0713f26b6c0c72d8); /* statement */ \nLib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({\n            batchIndex: getTotalBatches(),\n            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),\n            batchSize: _batch.length,\n            prevTotalElements: totalElements,\n            extraData: _extraData\n        });\n\nc_0x65cecced(0x0e08c45203f89ab1764c90aca50ab6593e17104dd1a139e8e0b1b48615b9af26); /* line */ \n        c_0x65cecced(0x0764609c24d4de65704400f6647a210a6bffe1a8a307e2bbb18283f17ef8b111); /* statement */ \nemit StateBatchAppended(\n            batchHeader.batchIndex,\n            batchHeader.batchRoot,\n            batchHeader.batchSize,\n            batchHeader.prevTotalElements,\n            batchHeader.extraData\n        );\n\nc_0x65cecced(0xd5384ef7cd65d8eeeb7a54fa8526d66a142b6b0196a852f8ba81344a4c6d304d); /* line */ \n        c_0x65cecced(0x58c75e1d5eed79bb95086e3bf03ea7bb10daa7b63596e6f812d920122db9dc29); /* statement */ \nbatches().push(\n            Lib_OVMCodec.hashBatchHeader(batchHeader),\n            _makeBatchExtraData(\n                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),\n                lastSequencerTimestamp\n            )\n        );\n    }\n\n    /**\n     * Removes a batch and all subsequent batches from the chain.\n     * @param _batchHeader Header of the batch to remove.\n     */\n    function _deleteBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) internal {c_0x65cecced(0x79f1daca2d5ec8987fbf3c2313b027c071d79f4732343e7213c26718c4e1ca8a); /* function */ \n\nc_0x65cecced(0x794ed67446391df4d2e25756a4683a4f5c7db0545c3ca3c0108960e3204fcb19); /* line */ \n        c_0x65cecced(0xb38934d4e0677b3341f1482f95b8205c4b3d0df139e88d46741b3f385ace3582); /* requirePre */ \nc_0x65cecced(0xc2666b5e55ca8acdd7b932ccb50cedb2f1df535719450052375315196bc0b827); /* statement */ \nrequire(_batchHeader.batchIndex < batches().length(), \"Invalid batch index.\");c_0x65cecced(0x9383b2ce4a0f7cb18d4c0da0dc9d10bb7607e977fba5b9f5a74aa32ce26c9aef); /* requirePost */ \n\n\nc_0x65cecced(0xeda794b606a274980a568b9d3ddcf1895626bd9a813be62b3ffe26110039d4c7); /* line */ \n        c_0x65cecced(0xc1b7b318b29e91161932eb1d17f97ab7410c0e1be7a986e5de365097c91084b2); /* requirePre */ \nc_0x65cecced(0xa0651e9b5d30f850fee6de03bfdf26fa4f7b02cc69b3e672148aa2b26430fe8e); /* statement */ \nrequire(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");c_0x65cecced(0x9e84c1b007e81158cea3ce5553c5b71bb90620ce57b4f44f022541077bf3525b); /* requirePost */ \n\n\n        // slither-disable-next-line reentrancy-events\nc_0x65cecced(0xca94a13c461b0fa9c3470d0ff41f26915840fb20543ea5d5f747f80cbef6f6fe); /* line */ \n        c_0x65cecced(0xcebd9981b4dbb94b12520660faaeb716f00f306cb49c2fe6aa592eb826f7d787); /* statement */ \nbatches().deleteElementsAfterInclusive(\n            _batchHeader.batchIndex,\n            _makeBatchExtraData(uint40(_batchHeader.prevTotalElements), 0)\n        );\n\n        // slither-disable-next-line reentrancy-events\nc_0x65cecced(0x1492e43880099be8f0b7f17f2eb0ca47ce76413203f4e339770a2394089efabf); /* line */ \n        c_0x65cecced(0x134c8c4d2bff4a52dbb6d985ee912995f85535f0f1ef4ae253dbaf9105799fea); /* statement */ \nemit StateBatchDeleted(_batchHeader.batchIndex, _batchHeader.batchRoot);\n    }\n\n    /**\n     * Checks that a batch header matches the stored hash for the given index.\n     * @param _batchHeader Batch header to validate.\n     * @return Whether or not the header matches the stored one.\n     */\n    function _isValidBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n        internal\n        view\n        returns (bool)\n    {c_0x65cecced(0x45873778868a6dab5cd3e547352aaacaa62b51b0371f0efa2745cfafbac46671); /* function */ \n\nc_0x65cecced(0x859154f0b6fc3e9caafce782f5c941c38b291e8b21dd4d90cd3a8ccd85fbe839); /* line */ \n        c_0x65cecced(0xc2d7d7b511c3b9e9a441db2decadc4a7328b4f1029a70502bc92f30a3b04ea1e); /* statement */ \nreturn Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(_batchHeader.batchIndex);\n    }\n}\n"
    },
    "contracts/libraries/codec/Lib_OVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xc86393d4(bytes32 c__0xc86393d4) pure {}\n\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../utils/Lib_Bytes32Utils.sol\";\n\n/**\n * @title Lib_OVMCodec\n */\nlibrary Lib_OVMCodec {\nfunction c_0xe0526d16(bytes32 c__0xe0526d16) public pure {}\n\n    /*********\n     * Enums *\n     *********/\n\n    enum QueueOrigin {\n        SEQUENCER_QUEUE,\n        L1TOL2_QUEUE\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct EVMAccount {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct ChainBatchHeader {\n        uint256 batchIndex;\n        bytes32 batchRoot;\n        uint256 batchSize;\n        uint256 prevTotalElements;\n        bytes extraData;\n    }\n\n    struct ChainInclusionProof {\n        uint256 index;\n        bytes32[] siblings;\n    }\n\n    struct Transaction {\n        uint256 timestamp;\n        uint256 blockNumber;\n        QueueOrigin l1QueueOrigin;\n        address l1TxOrigin;\n        address entrypoint;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct TransactionChainElement {\n        bool isSequenced;\n        uint256 queueIndex; // QUEUED TX ONLY\n        uint256 timestamp; // SEQUENCER TX ONLY\n        uint256 blockNumber; // SEQUENCER TX ONLY\n        bytes txData; // SEQUENCER TX ONLY\n    }\n\n    struct QueueElement {\n        bytes32 transactionHash;\n        uint40 timestamp;\n        uint40 blockNumber;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Encoded transaction bytes.\n     */\n    function encodeTransaction(Transaction memory _transaction)\n        internal\n        pure\n        returns (bytes memory)\n    {c_0xe0526d16(0x8f9b08f2983b26023bbd4fa1f390297140bd0cb180d0f2616abf516571bd70d6); /* function */ \n\nc_0xe0526d16(0xd7f3bdede7a8f16106b529c5acdb87e840594207a8beb63b4df312441ced2683); /* line */ \n        c_0xe0526d16(0xe51147a0a9cf6b53c60716aa8b27f73f52936b7322e1f3054cc1d742c29c93e6); /* statement */ \nreturn\n            abi.encodePacked(\n                _transaction.timestamp,\n                _transaction.blockNumber,\n                _transaction.l1QueueOrigin,\n                _transaction.l1TxOrigin,\n                _transaction.entrypoint,\n                _transaction.gasLimit,\n                _transaction.data\n            );\n    }\n\n    /**\n     * Hashes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Hashed transaction\n     */\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {c_0xe0526d16(0xf2f9de5333232b55b8845dbcb458064653863e1b59f816eecb6024af346c0912); /* function */ \n\nc_0xe0526d16(0x865dd5641bebcd2c3128036b9ed023852dafb9c648eb6e19c7d3d037fe8f2a18); /* line */ \n        c_0xe0526d16(0x6ec4de55d241f9afcd14deab6412ebc689c6ca4723687b6c3a50d4fc721478a8); /* statement */ \nreturn keccak256(encodeTransaction(_transaction));\n    }\n\n    /**\n     * @notice Decodes an RLP-encoded account state into a useful struct.\n     * @param _encoded RLP-encoded account state.\n     * @return Account state struct.\n     */\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {c_0xe0526d16(0x73a64a2328261a757d8b9bc5b2cb193d7caecdde742db029ab315f0959d194dc); /* function */ \n\nc_0xe0526d16(0x5fa80751fc1092d4a8a2d6558a36661d17cac10b4d5b5c911976ffd076b3e66a); /* line */ \n        c_0xe0526d16(0xdd377ec744ceb6dc77f26ccde4fbd57913c99307cf850db691a090c6eb62bb21); /* statement */ \nLib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\n\nc_0xe0526d16(0x51a0dcb45cc415faa7bf96ddec4e88d73acb5b85b31de885f44684a7b0299382); /* line */ \n        c_0xe0526d16(0xfc771505daf187b53cc611eae44bf41bc91eb05a322958ca70822c540317c79e); /* statement */ \nreturn\n            EVMAccount({\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\n                balance: Lib_RLPReader.readUint256(accountState[1]),\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\n            });\n    }\n\n    /**\n     * Calculates a hash for a given batch header.\n     * @param _batchHeader Header to hash.\n     * @return Hash of the header.\n     */\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n        internal\n        pure\n        returns (bytes32)\n    {c_0xe0526d16(0xf3f5d8eaa77a15412a72828427fd0c9cbd1767f676d6f176a88ae440e4756612); /* function */ \n\nc_0xe0526d16(0xda16e463917d22264c92ad19e59a83f8de0c86732eb7e1c38fc6ee8977e51b99); /* line */ \n        c_0xe0526d16(0x2f641af4a4d30b3bcfde57739b8745e9c979e28db25cc1477ae9a9569a8698cf); /* statement */ \nreturn\n            keccak256(\n                abi.encode(\n                    _batchHeader.batchRoot,\n                    _batchHeader.batchSize,\n                    _batchHeader.prevTotalElements,\n                    _batchHeader.extraData\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x2e0eb64b(bytes32 c__0x2e0eb64b) pure {}\n\n\n/**\n * @title Lib_MerkleTree\n * @author River Keefer\n */\nlibrary Lib_MerkleTree {\nfunction c_0x3279cfd8(bytes32 c__0x3279cfd8) public pure {}\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\n     * If you do not know the original length of elements for the tree you are verifying, then\n     * this may allow empty leaves past _elements.length to pass a verification check down the line.\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\n     * @param _elements Array of hashes from which to generate a merkle root.\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\n     */\n    function getMerkleRoot(bytes32[] memory _elements) internal pure returns (bytes32) {c_0x3279cfd8(0xaaaee75cb9244275bd4c763384ff51d066866944100e5ef5e2da074c9774e55f); /* function */ \n\nc_0x3279cfd8(0x9988aa3aa3719683f0070224fa971c2d82d2568c1360e0e315a303efbf85f337); /* line */ \n        c_0x3279cfd8(0xfe18001d8e35856c39a309d1b49da6ebde454efbe9c33d2044924905e5b79623); /* requirePre */ \nc_0x3279cfd8(0x3123c40d09577711489622e00e825b61116855b6eb2e702f04c94d7bbb55deb4); /* statement */ \nrequire(_elements.length > 0, \"Lib_MerkleTree: Must provide at least one leaf hash.\");c_0x3279cfd8(0x1e4c15d78fd7727a39413da3bb391d3090f8d771e5866c6972961bd112bc1e72); /* requirePost */ \n\n\nc_0x3279cfd8(0xdad88f6009de3b758adf3a2f9bdc1608ba759711bb6f0647fb4bfd0c91fc25bb); /* line */ \n        c_0x3279cfd8(0xcea746e33176f64670111f3fa6c35f916f84fb232822ac0534a9c3c5bde7acae); /* statement */ \nif (_elements.length == 1) {c_0x3279cfd8(0x19c5e2bda5ca16b17a8069c3d8e20fedcb9f707bfcc9b2a36411bc6633fe7cf7); /* branch */ \n\nc_0x3279cfd8(0x76afb2781c0a352fff1c814fb4f73c6f686b38515ec9701818b9e0f9e3cdcfd7); /* line */ \n            c_0x3279cfd8(0x07568949a6c844104ee8f7b698336ac477e8c392618a4bb2a1b5df30f7086954); /* statement */ \nreturn _elements[0];\n        }else { c_0x3279cfd8(0x08f6ab7d5a30c8282900bf639f05db1967db954908da7c7507893aba8f07d814); /* branch */ \n}\n\nc_0x3279cfd8(0x8d5abdf416cda3a488b0663ae97008802dde00a3d2a1d8a73692cc9d33810bfa); /* line */ \n        c_0x3279cfd8(0xeaad4fc4dc4d8cc10dde66e80f3fe728829364b66e863d28f2b54165f596351a); /* statement */ \nuint256[16] memory defaults = [\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\n        ];\n\n        // Reserve memory space for our hashes.\nc_0x3279cfd8(0x125ac989236ed98f115dabf155141b3ab22e628f084215bc62eed4f46e9871fc); /* line */ \n        c_0x3279cfd8(0xa6725c3ae8b13227f1ca6ed6cd15591c99ced99ce6ac5267774b9f37274318ab); /* statement */ \nbytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\nc_0x3279cfd8(0x682aeec8b123bd7912e40949a9c54adc57bf7bd6c4b41497fb3cd9ed5fe8e342); /* line */ \n        c_0x3279cfd8(0x6c54e573ed039e8a5343ee6ed8dcce597b3bd1c3c899dc57524fe59fc02a7866); /* statement */ \nbytes32 leftSibling;\nc_0x3279cfd8(0xa6783d063f518a38d3b01cae50e3929f37129638fed3c0f48eff99b8f0e75c7c); /* line */ \n        c_0x3279cfd8(0x4f8d3a756f5b54334f538c056f51d6b5986da62ca4eff87b00011b8e8d90dac4); /* statement */ \nbytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\nc_0x3279cfd8(0x372ab65228271ae2297511819d07503acf932105d058679d1805d15e80f9d74d); /* line */ \n        c_0x3279cfd8(0x5adc9a1f5033554b31ccaa938a4e428275e610457002b41a24fa1cc5c19a6dd7); /* statement */ \nuint256 rowSize = _elements.length;\n\n        // Current depth, counting from 0 at the leaves\nc_0x3279cfd8(0xd8d1bd94b66fa4e4ecdc456c3b3ce5739d6ceb292b8893a64b0e959285eea653); /* line */ \n        c_0x3279cfd8(0x0dd0c8a12bf4f0097ec53765d4415f3018ebd658a8d228391b422861ce788306); /* statement */ \nuint256 depth = 0;\n\n        // Common sub-expressions\nc_0x3279cfd8(0xc6d7e2e799f322d52f3e9f09af84bf0e55a051fd8e39db92903b6f55bd467efa); /* line */ \n        c_0x3279cfd8(0xe67bfd8c8f8a3e8d65ac29006eeb232cde4e39789d60890f060f722a2ba6a3c0); /* statement */ \nuint256 halfRowSize; // rowSize / 2\nc_0x3279cfd8(0x69d173b5ac5943fb2cc21033729aed17e6f2da8942b41183fe319c6c97120f98); /* line */ \n        c_0x3279cfd8(0x1a9587e805e25a5444e53fc42f9a2ce7fc693609b4153375aae0f1d1f5cb2bc7); /* statement */ \nbool rowSizeIsOdd; // rowSize % 2 == 1\n\nc_0x3279cfd8(0x66088a819b72d6b5256b5766dfbe889b106d72b35136d759df35c62a897034c9); /* line */ \n        c_0x3279cfd8(0xb8db1acc6c7ef0aca5e1e97820acf775b4fc985264291777ee0052a2cf277381); /* statement */ \nwhile (rowSize > 1) {\nc_0x3279cfd8(0xa96ed82a88dee65030e42dbc243346a09b92a6490ad3807e1f9bf2730bfd0b65); /* line */ \n            c_0x3279cfd8(0x5a59fc70514f7fac79090a3c57f84fe548bb44e22d3f2e3ef3cbd7adf2ff134b); /* statement */ \nhalfRowSize = rowSize / 2;\nc_0x3279cfd8(0x0e7003332b2af158633f543bffe580edd93cab2d94799d7cfc7f4241a53e598b); /* line */ \n            c_0x3279cfd8(0x98fb45daadbbd901690770f17bf5c5ee818cd421aeb731287e2b479edad45fa6); /* statement */ \nrowSizeIsOdd = rowSize % 2 == 1;\n\nc_0x3279cfd8(0x881c6d4d8eb571bf697a2fd39d3938c601035eb54ed620a4254546d1c8dd1ab6); /* line */ \n            c_0x3279cfd8(0x326374bf66cebc70c276b48131c0815650b24311eb52d667c50987879088a586); /* statement */ \nfor (uint256 i = 0; i < halfRowSize; i++) {\nc_0x3279cfd8(0x087cc1be74a42238acde47e01dec6a18acbbaa21bbd924252d621f724fded80b); /* line */ \n                c_0x3279cfd8(0xb51db3d9b6980da47de85bd687ead657505a3d8c1e528f6f55ee2922e5dd1918); /* statement */ \nleftSibling = _elements[(2 * i)];\nc_0x3279cfd8(0x5a288da0faa20fa7dcafafc66e43d8db5130d91e793db9efdc8e1e3250b2c1fe); /* line */ \n                c_0x3279cfd8(0xa8680118afeb176ac2dbd1ef9582b43284f3cb062c072072cb4c9be4514a1681); /* statement */ \nrightSibling = _elements[(2 * i) + 1];\nc_0x3279cfd8(0x32e3071fe99ecc0c3deb4e0022ef00abd819ab25ee51c9df68e0f5f2009c8c24); /* line */ \n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\nc_0x3279cfd8(0xacf018d01460941c363f9d3fdeddea3b99e8cd70a382db9f28244f069d02d89b); /* line */ \n                c_0x3279cfd8(0x05b16cd0c9d08c4d15bad6e10c87366dcb2fc5197a251bed597bd866c248d0e7); /* statement */ \n_elements[i] = keccak256(buf);\n            }\n\nc_0x3279cfd8(0xdb1a71cc94170b6111fc1c1de415eaaa0d2127a372710bb567d11d64d1b0606a); /* line */ \n            c_0x3279cfd8(0x2252d3d8f1911c4a713bd265fe465c214d632c4192753dfb81dd0e7ab2749a7b); /* statement */ \nif (rowSizeIsOdd) {c_0x3279cfd8(0xe4b3b170f8f4b3ce5005c8800b50b93f24244683efbfdfeb4f3a2baede9efbee); /* branch */ \n\nc_0x3279cfd8(0x811eee68208ffc9437e54310ebee09ca85896fd41b403137d1311a0b62534996); /* line */ \n                c_0x3279cfd8(0xdc8185b726178e0c2782c48b53fb6ed074ddf8f561b3632c265f0f98dd568d99); /* statement */ \nleftSibling = _elements[rowSize - 1];\nc_0x3279cfd8(0x7afc11d5dddd6b0ad290da350e540301d4a755653d9ebf49b10ba4281a653a5a); /* line */ \n                c_0x3279cfd8(0xd603d6e1fa12240a0088fe89ab1ecc877ff826f2beb8b4524c7e2b15d41312b7); /* statement */ \nrightSibling = bytes32(defaults[depth]);\nc_0x3279cfd8(0x232a4f6d19781cab9714f7847360cf58a37e2e6b378eb24086dbe743841bd2a2); /* line */ \n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\nc_0x3279cfd8(0xa3be624c483d2eabd2e0ed69771c6ba3be6df77b1737c956231ed91da04a4ab8); /* line */ \n                c_0x3279cfd8(0x1913eae1c0f0207bdc7fa906a9e839a5e2358abac3f67432773ee50c30456785); /* statement */ \n_elements[halfRowSize] = keccak256(buf);\n            }else { c_0x3279cfd8(0x6799edd890edb91ae486120c4a89dda1235ff29f5bfd9fa277d393b508a77cb8); /* branch */ \n}\n\nc_0x3279cfd8(0xc8d0fcae630ac8c93272b1db30e929a3dd823fd2ea54611b466f4c0f7102849b); /* line */ \n            c_0x3279cfd8(0x61c580940c90e0ae64daacd0e3d74ca6e295f9db55529f9b8dab1719e6b29759); /* statement */ \nrowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\nc_0x3279cfd8(0x5fc72582e08ba263e78fde94c22c01f4dd8f84a56c94e6dd4b356c95ff096fbb); /* line */ \n            depth++;\n        }\n\nc_0x3279cfd8(0xa18b57f1102e2f4661e9daa44a4c45b44bba7c56355a391b32c21422eed73e6d); /* line */ \n        c_0x3279cfd8(0x0ee2ba80a839eb6d141953cc535aed928cca16833e32ff4998e43b53c9f08d45); /* statement */ \nreturn _elements[0];\n    }\n\n    /**\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\n     * of leaves generated is a known, correct input, and does not return true for indices\n     * extending past that index (even if _siblings would be otherwise valid.)\n     * @param _root The Merkle root to verify against.\n     * @param _leaf The leaf hash to verify inclusion of.\n     * @param _index The index in the tree of this leaf.\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0\n     * (bottom of the tree).\n     * @param _totalLeaves The total number of leaves originally passed into.\n     * @return Whether or not the merkle branch and leaf passes verification.\n     */\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    ) internal pure returns (bool) {c_0x3279cfd8(0x330d132470ae7df75892dc4c02222e71c4f29df926339369efdc441a540d463f); /* function */ \n\nc_0x3279cfd8(0xc8e59e0b3120af990a1bfd15cf857b9d29e02e0ed66504162ab2539fb542e955); /* line */ \n        c_0x3279cfd8(0xc5849be0c494ea503906de61881942caf457065984cafdf3ca8513d6fc5bc7e4); /* requirePre */ \nc_0x3279cfd8(0xd3a8b13e6abf5a1004ac4b56c139f0c6d341f0aa85ac44be42389131c12517ea); /* statement */ \nrequire(_totalLeaves > 0, \"Lib_MerkleTree: Total leaves must be greater than zero.\");c_0x3279cfd8(0x09e1c3ee70d036cc1181091b98a84dc20b7149ce39a429cf98d0387f2f5d8cf4); /* requirePost */ \n\n\nc_0x3279cfd8(0x5ee978f6191e12b96c88e2b47a0e2223b0e0048a10749745e1db93e681185eba); /* line */ \n        c_0x3279cfd8(0xdaa2408da5c47c4ed62e3f88b3b84f941cae6af057283321c967191590b4e887); /* requirePre */ \nc_0x3279cfd8(0x12621fe23e8578ac96e60b4e624c61c5b79c381d8e0a1bbb4bb5241f21a07a5c); /* statement */ \nrequire(_index < _totalLeaves, \"Lib_MerkleTree: Index out of bounds.\");c_0x3279cfd8(0xcaf1897fe7d90200feaeb765283dcf2be364a678889e4125ecb7bce23ecf04ed); /* requirePost */ \n\n\nc_0x3279cfd8(0x3cb9370d92732bb5f8076149a4193f4cf65b98afe7b3415ee624a62fb8572a1c); /* line */ \n        c_0x3279cfd8(0xd50ee0fe13c53a9968dd9e67d34cf02d13b70552f0364c9654b63931e4f4c157); /* requirePre */ \nc_0x3279cfd8(0x6cc44f4a006dce4acc09c6542017dfb1de4f7acfaf7f90697465f5135fa27557); /* statement */ \nrequire(\n            _siblings.length == _ceilLog2(_totalLeaves),\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\n        );c_0x3279cfd8(0xc8c1289acb53c8b9b7743f7b623abfdf02852164dfa7abd06357ca5715823508); /* requirePost */ \n\n\nc_0x3279cfd8(0x453de10562772e42c9913b9ae6a522a7fe62ef88dfaa4e56f0d3ecf7f71dd111); /* line */ \n        c_0x3279cfd8(0xab4e7ce85bf963e6099b501875dfc6a785e5fc960aeae3b1528a99f19e3abbd5); /* statement */ \nbytes32 computedRoot = _leaf;\n\nc_0x3279cfd8(0x679e04c473f15da27dda508e32d5a207c284f2fbacbf2987e964ff04cffffcc2); /* line */ \n        c_0x3279cfd8(0x06ac1067c432ba40a805facecb4148b2c40f84e33a31b240d464f672bc20cfc3); /* statement */ \nfor (uint256 i = 0; i < _siblings.length; i++) {\nc_0x3279cfd8(0x7f16051920539a55951eb31a4c87112a63b4912eda83f49ced3c07989784ec38); /* line */ \n            c_0x3279cfd8(0xb79e7490e4b9d23f93b592ac93c0438008fb512c95e081a24d5db57624e9fdef); /* statement */ \nif ((_index & 1) == 1) {c_0x3279cfd8(0x8da80547e8b3a56ba8c4adbc920d4ab8d045da5cab252281867e1b0e7070ef45); /* branch */ \n\nc_0x3279cfd8(0x9bbde11079e77e0f806811e68c9df1d7c0a0b016c231be28d5a2d3d1788e5195); /* line */ \n                c_0x3279cfd8(0xea26228b4957ab788d2dab54efac188af5f6a3d2b30926c2c8ace6caf2ba943a); /* statement */ \ncomputedRoot = keccak256(abi.encodePacked(_siblings[i], computedRoot));\n            } else {c_0x3279cfd8(0x28c77b04664d59da73d1dd78438513da1798a2b693b6599b1eb8646768586e57); /* branch */ \n\nc_0x3279cfd8(0x988ac17eb29e73d6241a354dbf8683d2912f5c8c778f0df8dd9e315c5e1d39b4); /* line */ \n                c_0x3279cfd8(0xab49981146adbb7c27ddb4617a30ce9ccf8e249d9828d3a390ff9e84b5ef3d7a); /* statement */ \ncomputedRoot = keccak256(abi.encodePacked(computedRoot, _siblings[i]));\n            }\n\nc_0x3279cfd8(0x35d2ee8010a0a1975bcc9a8d59de9d782884f2b2ee5b66605d3a52c77b9a3534); /* line */ \n            c_0x3279cfd8(0x7fc4f5259bf01794ed231aed379b6d43d230ab253f1933b77bbc786b38aeffdc); /* statement */ \n_index >>= 1;\n        }\n\nc_0x3279cfd8(0x68f4243ed965cb21524ab078087a53f3620738f13491a183befc51ea7173d225); /* line */ \n        c_0x3279cfd8(0x06f361435da022b3ca9a74cfd98b852678efa8edaf326f997a9e715d491dd248); /* statement */ \nreturn _root == computedRoot;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Calculates the integer ceiling of the log base 2 of an input.\n     * @param _in Unsigned input to calculate the log.\n     * @return ceil(log_base_2(_in))\n     */\n    function _ceilLog2(uint256 _in) private pure returns (uint256) {c_0x3279cfd8(0x44d94b2ce086248a7db4802cf97f03696f0eb7e79ee33e5ea3cbf04c03c8d23f); /* function */ \n\nc_0x3279cfd8(0x571b96e96bdd78d38215a28ca70f8d4195db4fea70dbee7f6d1b6ddf020a9220); /* line */ \n        c_0x3279cfd8(0x1d9116781fae9c946aed368a5e5e1d1ad7fde8a1c8e9c9d95edfd3d1c7f70c28); /* requirePre */ \nc_0x3279cfd8(0x5f9442cc9a8f545454ba26b957c215f641d93bbeeaec734eae519a7518d66480); /* statement */ \nrequire(_in > 0, \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\");c_0x3279cfd8(0x8a8f1f386796485e2d98d1b893138c228af1e5a558bc28cbbf6ca035c7a2fb68); /* requirePost */ \n\n\nc_0x3279cfd8(0xea04e741aeae71315894b3fe37c060f50c0726315c59f2879c8c709cd2172c49); /* line */ \n        c_0x3279cfd8(0x7360509d6b3d75c5befc50e5047fab6393181087ee357c483e7a952a92b1f684); /* statement */ \nif (_in == 1) {c_0x3279cfd8(0xff4f32a8ab2150edf4d2563594b84ad98836ba728ef35ebf492a5da3c92fa2ac); /* branch */ \n\nc_0x3279cfd8(0x5bb1f8113f8c3e7b72b8df34750278472e62b5c28dea32d03015ced72adf3bf1); /* line */ \n            c_0x3279cfd8(0x3501feeb2545e27683595f97c3d22172ea1179cfb95b3e7773f22a4f1fbc663f); /* statement */ \nreturn 0;\n        }else { c_0x3279cfd8(0xa4f9a73134f294d9cf570cc8cbe67fdf4c2f739ab65b7578718d3b4e79648b91); /* branch */ \n}\n\n        // Find the highest set bit (will be floor(log_2)).\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\nc_0x3279cfd8(0xd734b387f01062adb4b902b586c3baa41c904ac37fd1c11677d59d202a94efa2); /* line */ \n        c_0x3279cfd8(0x418ea702c81594668dad14950f14562a3d8878c028c6ad7e3a03e1f119eab3a4); /* statement */ \nuint256 val = _in;\nc_0x3279cfd8(0x3a0e6afc7b5bf3a2809cb273bfa9359c097c5c1abbf6bd5554f9ac56697ff9be); /* line */ \n        c_0x3279cfd8(0x9c596bedb0afaff37ed040895c257d3bda54fceb475874306e24cfd699a86be5); /* statement */ \nuint256 highest = 0;\nc_0x3279cfd8(0x3fd7aa62e51c499dba579c4f92777121082b24c39b6e8d52b3be464296faae5a); /* line */ \n        c_0x3279cfd8(0x75bcd918dfa4da0614f91cdad692c836bd125ea3aa58d90767b68885820c245a); /* statement */ \nfor (uint256 i = 128; i >= 1; i >>= 1) {\nc_0x3279cfd8(0x74fe2532e23b30c6370887527f683ad374c77c0dc6047adb93db05c018cfe6db); /* line */ \n            c_0x3279cfd8(0xe3c78cd646667a41d33c29777db89ca2701322b1022f01dbb7789b53cccbf37d); /* statement */ \nif (val & (((uint256(1) << i) - 1) << i) != 0) {c_0x3279cfd8(0x8bf5a955fb0e9a2c7cfba92b1af01f0fbe69675679f4e511b66ba322b90733d2); /* branch */ \n\nc_0x3279cfd8(0x4ac754a48ea0c15c21198b59ced644a120cc16bae03c7cf4a2c4713115af4076); /* line */ \n                c_0x3279cfd8(0xea308327abd18975c4f1961e060d70f2d5fd099ff8d3283289f62e3fac0340aa); /* statement */ \nhighest += i;\nc_0x3279cfd8(0x93f662661c9bf6a5771428df26bdc024540e253949570d59ac475346c7406eff); /* line */ \n                c_0x3279cfd8(0x4f849d4502ca280483522d73e58d485c151f10d1808bf8f6cb585f142675a7b3); /* statement */ \nval >>= i;\n            }else { c_0x3279cfd8(0xbf6a86c0366b1a259a130dc21849e55ecde4d5d3a9983d480940aff22c8b5998); /* branch */ \n}\n        }\n\n        // Increment by one if this is not a perfect logarithm.\nc_0x3279cfd8(0x4da24d549f88819dd8c3be6a04f10674a24dfb729e8d8c92df71a42ee7a4a223); /* line */ \n        c_0x3279cfd8(0x40fa0162b10e89dd8ad80244f05d524d68a560e16e11bbc793f3b806e528a604); /* statement */ \nif ((uint256(1) << highest) != _in) {c_0x3279cfd8(0x141b2bdeda05b5061aedc7f8fc91191f2db2f31597f5d7115ee25f0d4293c467); /* branch */ \n\nc_0x3279cfd8(0x86c547eab32f336712414235d282b495c919e92ee4e4807d9ae032bfe95d5779); /* line */ \n            c_0x3279cfd8(0x887ed63f3e771e5a2b287873e0952f868683a3a4a7bb6f2459ae97238a453ca7); /* statement */ \nhighest += 1;\n        }else { c_0x3279cfd8(0x905875ecf9948fef282237ccba749a926174d12824b11d500bc17a696fb69597); /* branch */ \n}\n\nc_0x3279cfd8(0xf4be2a8738eef5b74be921d08a0c3abc07c2aa7c0e8181eefab34bfbdc12434f); /* line */ \n        c_0x3279cfd8(0x75127b5ae1bc809799011373220f35379dc2aa4b8fced1418255c3279459bbe3); /* statement */ \nreturn highest;\n    }\n}\n"
    },
    "contracts/L1/rollup/IStateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/**\n * @title IStateCommitmentChain\n */\ninterface IStateCommitmentChain {\n    /**********\n     * Events *\n     **********/\n\n    event StateBatchAppended(\n        uint256 indexed _batchIndex,\n        bytes32 _batchRoot,\n        uint256 _batchSize,\n        uint256 _prevTotalElements,\n        bytes _extraData\n    );\n\n    event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() external view returns (uint256 _totalElements);\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches() external view returns (uint256 _totalBatches);\n\n    /**\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\n     */\n    function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\n\n    /**\n     * Appends a batch of state roots to the chain.\n     * @param _batch Batch of state roots.\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\n     */\n    function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\n\n    /**\n     * Deletes all state roots after (and including) a given batch.\n     * @param _batchHeader Header of the batch to start deleting from.\n     */\n    function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) external;\n\n    /**\n     * Verifies a batch inclusion proof.\n     * @param _element Hash of the element to verify a proof for.\n     * @param _batchHeader Header of the batch in which the element was included.\n     * @param _proof Merkle inclusion proof for the element.\n     */\n    function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    ) external view returns (bool _verified);\n\n    /**\n     * Checks whether a given batch is still inside its fraud proof window.\n     * @param _batchHeader Header of the batch to check.\n     * @return _inside Whether or not the batch is inside the fraud proof window.\n     */\n    function insideFraudProofWindow(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n        external\n        view\n        returns (bool _inside);\n}\n"
    },
    "contracts/L1/rollup/ICanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/* Interface Imports */\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title ICanonicalTransactionChain\n */\ninterface ICanonicalTransactionChain {\n    /**********\n     * Events *\n     **********/\n\n    event L2GasParamsUpdated(\n        uint256 l2GasDiscountDivisor,\n        uint256 enqueueGasCost,\n        uint256 enqueueL2GasPrepaid\n    );\n\n    event TransactionEnqueued(\n        address indexed _l1TxOrigin,\n        address indexed _target,\n        uint256 _gasLimit,\n        bytes _data,\n        uint256 indexed _queueIndex,\n        uint256 _timestamp\n    );\n\n    event QueueBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event SequencerBatchAppended(\n        uint256 _startingQueueIndex,\n        uint256 _numQueueElements,\n        uint256 _totalElements\n    );\n\n    event TransactionBatchAppended(\n        uint256 indexed _batchIndex,\n        bytes32 _batchRoot,\n        uint256 _batchSize,\n        uint256 _prevTotalElements,\n        bytes _extraData\n    );\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct BatchContext {\n        uint256 numSequencedTransactions;\n        uint256 numSubsequentQueueTransactions;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n\n    /*******************************\n     * Authorized Setter Functions *\n     *******************************/\n\n    /**\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\n     */\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() external view returns (IChainStorageContainer);\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() external view returns (uint256 _totalElements);\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    function getTotalBatches() external view returns (uint256 _totalBatches);\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    function getNextQueueIndex() external view returns (uint40);\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    function getQueueElement(uint256 _index)\n        external\n        view\n        returns (Lib_OVMCodec.QueueElement memory _element);\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    function getLastTimestamp() external view returns (uint40);\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    function getLastBlockNumber() external view returns (uint40);\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    function getNumPendingQueueElements() external view returns (uint40);\n\n    /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    function getQueueLength() external view returns (uint40);\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target contract to send the transaction to.\n     * @param _gasLimit Gas limit for the given transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external;\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch(\n        // uint40 _shouldStartAtElement,\n        // uint24 _totalElementsToAppend,\n        // BatchContext[] _contexts,\n        // bytes[] _transactionDataFields\n    ) external;\n}\n"
    },
    "contracts/L1/rollup/IChainStorageContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IChainStorageContainer\n */\ninterface IChainStorageContainer {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\n     * 27 bytes to store arbitrary data.\n     * @param _globalMetadata New global metadata to set.\n     */\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\n\n    /**\n     * Retrieves the container's global metadata field.\n     * @return Container global metadata field.\n     */\n    function getGlobalMetadata() external view returns (bytes27);\n\n    /**\n     * Retrieves the number of objects stored in the container.\n     * @return Number of objects in the container.\n     */\n    function length() external view returns (uint256);\n\n    /**\n     * Pushes an object into the container.\n     * @param _object A 32 byte value to insert into the container.\n     */\n    function push(bytes32 _object) external;\n\n    /**\n     * Pushes an object into the container. Function allows setting the global metadata since\n     * we'll need to touch the \"length\" storage slot anyway, which also contains the global\n     * metadata (it's an optimization).\n     * @param _object A 32 byte value to insert into the container.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\n\n    /**\n     * Retrieves an object from the container.\n     * @param _index Index of the particular object to access.\n     * @return 32 byte object value.\n     */\n    function get(uint256 _index) external view returns (bytes32);\n\n    /**\n     * Removes all objects after and including a given index.\n     * @param _index Object index to delete from.\n     */\n    function deleteElementsAfterInclusive(uint256 _index) external;\n\n    /**\n     * Removes all objects after and including a given index. Also allows setting the global\n     * metadata field.\n     * @param _index Object index to delete from.\n     * @param _globalMetadata New global metadata for the container.\n     */\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xf8b88c7a(bytes32 c__0xf8b88c7a) pure {}\n\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\nfunction c_0x3be3e55e(bytes32 c__0x3be3e55e) public pure {}\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {c_0x3be3e55e(0x67bae5131a2ee1a0b01ad826097aa861752c0085d3755fabccfc39e20096c1a2); /* function */ \n\nc_0x3be3e55e(0xdd9e0c3fcac747e5e634696181e08aab8431ec5d22c10baa5a5f84224e80456e); /* line */ \n        c_0x3be3e55e(0x0314865db3cb15895702b2d2ca03b011aa16c8b1918562d07e24c0695d64ed84); /* statement */ \nuint256 ptr;\nc_0x3be3e55e(0x82a50bce063b17470663988152a8da790730c6f5db2cc6830297c3c25bf94de1); /* line */ \n        assembly {\n            ptr := add(_in, 32)\n        }\n\nc_0x3be3e55e(0x1fbd19e65b4fe3568e3708065051a7d2423fe3b9710f2ba4f4bb3e24d39ebd3c); /* line */ \n        c_0x3be3e55e(0xb136e27017b2ce350682ee4bf62efe952e7ca7621b4cb5b7c529d19ecda3d736); /* statement */ \nreturn RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {c_0x3be3e55e(0xa56965d51fd8bf28f0362849e957212d585336b7a4c3532618c7c2645d5ea255); /* function */ \n\nc_0x3be3e55e(0xee1bd8ec7d524f38258df2011ab0f479ab4d173d0ca93918bbe7d26d666401e3); /* line */ \n        c_0x3be3e55e(0xd3763eb90a755857d274aa0c0d717d13d7716ad723a594d629d4c940736c65b8); /* statement */ \n(uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\nc_0x3be3e55e(0x45f1432c1e185d67d7bd9e524dc64591009a407c2b3525c882b5cebfc404ed8e); /* line */ \n        c_0x3be3e55e(0x0502de5bd2fa083b390f6e63e7672db10259306cd2b57ef856ef723cdc15aad0); /* requirePre */ \nc_0x3be3e55e(0x187d944a8324e6f9e9a3edd3cad31a4cfb850a050807b65cd5a172a4ebbf87cb); /* statement */ \nrequire(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");c_0x3be3e55e(0x52ce4787ad5a7cda80278bdf7895d0c6ebfa47b1aa74e6cd5a403f9f6e21a874); /* requirePost */ \n\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\nc_0x3be3e55e(0xf84b331d7c4efa97d0ca2b73a1d7ff2411b59432a6d110793ae6301027c02b39); /* line */ \n        c_0x3be3e55e(0xb1f9df3365577151590ffdda65f4af8182eeac34508d919fb85093a1c8b64c65); /* statement */ \nRLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\nc_0x3be3e55e(0x0900d4168753fa07e523e336b4d2589727055ea43950a04b2fe1f11eeb495b87); /* line */ \n        c_0x3be3e55e(0x690cbb6bf08e965ba4702511899e94271afdb35d53d3cc8ce9b6f51dcf2e025f); /* statement */ \nuint256 itemCount = 0;\nc_0x3be3e55e(0x52e66b9c56563a921842f1ab4801c330a80570600bbb85645e5e4a501c6d5374); /* line */ \n        c_0x3be3e55e(0x8648b74f76e0dbe17dbc07b21520e53f8b085ac9375ba3a0f5cb54d76bcd6b3b); /* statement */ \nuint256 offset = listOffset;\nc_0x3be3e55e(0x89a5248c9db741c60351e71fa0543a3711632108b1b2a039f8d52d2877ffef50); /* line */ \n        c_0x3be3e55e(0x1596a6da917187d991d0aa2d51ad2ebfb6996e12d1db622133e8ccf4d3f0e3c4); /* statement */ \nwhile (offset < _in.length) {\nc_0x3be3e55e(0x905bc833ad279a16ecb91b856b07041b6f984529345cb7a3a215489376689a60); /* line */ \n            c_0x3be3e55e(0xde62ac95661ea2e2a67607c566624f2c17175718be731eba1dda6c2b3f243d45); /* requirePre */ \nc_0x3be3e55e(0xe82baf54f8f22fb14f4d744f93943de879df8fb5ecee903a459fbc6b6ca6bd15); /* statement */ \nrequire(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");c_0x3be3e55e(0x6436cb2c623ce33d778076633ad32cc91361ed3f6d860d2ddc89ec89fe306752); /* requirePost */ \n\n\nc_0x3be3e55e(0x0c986476381ee9bf7333c480818765c6c02e3247009633aacb589297cec4c56d); /* line */ \n            c_0x3be3e55e(0x3b90f04dd47b16158c9f29c8a74d2b96b4808a8bf205e66bc6dc5d2ad2f12999); /* statement */ \n(uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\nc_0x3be3e55e(0xbe637711e410f751055442745e64b426775fb1802684b8a217ec18244869751c); /* line */ \n            c_0x3be3e55e(0x782b9d4766f6dca4899254522f626a5097887446769ec3f8343290fdb135d05e); /* statement */ \nout[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\nc_0x3be3e55e(0x94e529d4d3a5c0a3ec1912a8e47ce737c15ad78aecbfa70231278fe826e5235c); /* line */ \n            c_0x3be3e55e(0x42406f7b2d586735d349b3218dd5989f635071cd1826f0ff0664e3a94ac72225); /* statement */ \nitemCount += 1;\nc_0x3be3e55e(0x1349e6d2a3545f296ab6b801bb995d690fdef8744b58e1f40e33194791b84566); /* line */ \n            c_0x3be3e55e(0xd152ff7b0acc40b5ffba4e7600321676d11578bfb4dc78e9c68e635058f8224e); /* statement */ \noffset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\nc_0x3be3e55e(0x905272fd65b6446bed08a528588ea3c245b3c7c04d861cc51adb5c010bfef219); /* line */ \n        assembly {\n            mstore(out, itemCount)\n        }\n\nc_0x3be3e55e(0xfac1a1f3b4be939afe65353023b92be35cedfa46b93e8b752a4960d1a9d318e9); /* line */ \n        c_0x3be3e55e(0x65b2d3b5d2250370722f9c41e1c6b1ec8a0dc55ffbdf77a224ff979ba1235007); /* statement */ \nreturn out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {c_0x3be3e55e(0x39c6078bb884b9f1d1a5297130ab1048195b1b9ccaebd9161a94cc1a298b1795); /* function */ \n\nc_0x3be3e55e(0xca82898e928d5d0a835c10947a22fe085d2d23c68e0888863c4ad98823c57f6e); /* line */ \n        c_0x3be3e55e(0x6d17ad29cc9d82d840dc2ce7767b1555cf9984c02f0126c0013b38895c40da5c); /* statement */ \nreturn readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {c_0x3be3e55e(0x69d72f7e7cb661fe47c043f7d1b1c3343b278b2809610d938cf4da9e76967eef); /* function */ \n\nc_0x3be3e55e(0x1f9f423c12f72707b9b6f46fc9f3200fdf7d882d66bd5c2691b99db7f69e9a8f); /* line */ \n        c_0x3be3e55e(0x7a59e0aca4f3dcbf370724f388a7b94ee80472a19927b1b9faa1386bf668c87a); /* statement */ \n(uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\nc_0x3be3e55e(0x9f248235e144578092aa5febf55f07e73ef310d5d2f9a4be1ab5f38e9e8b50ce); /* line */ \n        c_0x3be3e55e(0xae6c64a1e6944cdbe96313132d694d611a5ab8c7ac53111ea17d75f68dba2e93); /* requirePre */ \nc_0x3be3e55e(0x4150f1c0a71fc63c7f7e05a0bb9f1791a0c607f25f658b76ce7d883eb1d4a7b9); /* statement */ \nrequire(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");c_0x3be3e55e(0xf76a200009abd6f62f7b9336f8cee4aec78ba9bee6715324c45b5e0a0951ce77); /* requirePost */ \n\n\nc_0x3be3e55e(0x463066b4e5d07be14ce59cc590c603a388504a7eb747c5bbf4671f05d06b0a6a); /* line */ \n        c_0x3be3e55e(0xbe822a17c39f81da5897812ffb60b1eddc11c883a2d919b9a7b6125ff9428163); /* statement */ \nreturn _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {c_0x3be3e55e(0xb4d02c1972f4439621f3ddfaaa517acba7ad5a4834f1a006e0100fdf46ee4f84); /* function */ \n\nc_0x3be3e55e(0xb5b5267fd49f1e1ada615542b1f395708e83099e012fc73daccffef308108c33); /* line */ \n        c_0x3be3e55e(0x055b79c8f90a6bfa4834d1199d09f22b21058e6787d7d8f990b4aff09c7fe988); /* statement */ \nreturn readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {c_0x3be3e55e(0xdae014c21c4f33a9dd54488117528078a01bedc4b103e144a3695f8ba44b46c7); /* function */ \n\nc_0x3be3e55e(0xf2ad5fa16b4898ec1fcc0f15399bfbbfe73cc3548d4b8fb128a1a7f1c16f230a); /* line */ \n        c_0x3be3e55e(0x68976ca7bacdfbfb6c2c37f799be95f28f028b57fdea927a9b5be87a49d9001f); /* statement */ \nreturn string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {c_0x3be3e55e(0xf6f2f7ce18f8f97162b7b41b5b53c0781c6b8bb1de97343ea27c3147f65fd7cf); /* function */ \n\nc_0x3be3e55e(0x874ef3924f4b0d8d922446dabd27600c180ae459a20a690365cd48ee58ea33b3); /* line */ \n        c_0x3be3e55e(0x525b17d64dece9b8ad477cb6f6246869dcd6d5a16a2219eea1a36f94c93693a0); /* statement */ \nreturn readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {c_0x3be3e55e(0x2ea2ebf6acca64a4b6de1a33bca806492850c004d6f91cb41d853f72d4c99759); /* function */ \n\nc_0x3be3e55e(0x2bf2fdb97341954e2b736a5c3b1f660bb31be7a780ee9ad61db770231a7596ed); /* line */ \n        c_0x3be3e55e(0x3facbfaca6c36bd717cfd1877aa79249042c966c1f46965083f920b15d22379d); /* requirePre */ \nc_0x3be3e55e(0x41db7488e16f0c8191e280b8aef46ae6bb2dd05edc76c98dcebf0cca2dba31b0); /* statement */ \nrequire(_in.length <= 33, \"Invalid RLP bytes32 value.\");c_0x3be3e55e(0x0fa9f3c23d19da7420e3bb971c8d47a96a0849cc575e448e355b69a5991403bc); /* requirePost */ \n\n\nc_0x3be3e55e(0x686acd08729eaa8fe042a2308752c1258544b43b02de4f2126fffe2415c6bc5a); /* line */ \n        c_0x3be3e55e(0xcce62258892239a3cf44543b0d8ab8e2be3f982673d5ce236281ac44b07633ab); /* statement */ \n(uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\nc_0x3be3e55e(0x2f5452f07979830980cdf974184310cffd851766084cf6133b70f184da61f1e0); /* line */ \n        c_0x3be3e55e(0x0ca1e0709ce9924dd639187efb0121d9381a7e82e45333a96bf9a3a4e4073959); /* requirePre */ \nc_0x3be3e55e(0xc259d95d87e58f4d2f48cd7cd4d0b0fd06ba98461c251ac10b97687ce0dc3e16); /* statement */ \nrequire(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");c_0x3be3e55e(0x6c0c9558323425c3a95b320b24e13f83e91d45aeb13ace760d0fe06aa2456244); /* requirePost */ \n\n\nc_0x3be3e55e(0x1fa7400dd037ac808157eb7c10f3ab095c740222bcd62f33c221c82e7d78e0a8); /* line */ \n        c_0x3be3e55e(0x9b7b5b504bd60cfd0cfb0612c3c46548f1f61be0d641e622e71b110d5a53d30c); /* statement */ \nuint256 ptr = _in.ptr + itemOffset;\nc_0x3be3e55e(0xacb33e96a83ed98cdb9b65bead0db05d17e061015ca0ad7dab2dc15af1576687); /* line */ \n        c_0x3be3e55e(0xb86b3cb03769c8b6c91f6503d1d839607b66f6b4e69dc855ce19e29fafea1c62); /* statement */ \nbytes32 out;\nc_0x3be3e55e(0x7c2c0f5d026c230f087fed1f09618bfbc9a88ff7e1e3dc0aa3f3d69cd61d3110); /* line */ \n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\nc_0x3be3e55e(0x5666379f03ef5ccc69fc46ac8c1aec1244919d12de2ec610794cc72954ed9106); /* line */ \n        c_0x3be3e55e(0x94b8efc721988b1e0ae473e1dcde50899c6d0d4bf6e319530092ac21418b0eb9); /* statement */ \nreturn out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {c_0x3be3e55e(0xe1896f329559a041635f5a7d210d8cc4e6ae6e2de643b524500479eb99f05df5); /* function */ \n\nc_0x3be3e55e(0x750a2d29088cd0625f20dcd5b66f2efb3cef34ad7eb478daf66040a63b0a4fb7); /* line */ \n        c_0x3be3e55e(0xce9f0273038c8f691aaca3f86f03426da9ff5a6bcdd373893ab93f416ef51e4c); /* statement */ \nreturn readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {c_0x3be3e55e(0x53f1fb828b51512d80b887885237c9c1161845fc1ee822c6b7304c3373da1a68); /* function */ \n\nc_0x3be3e55e(0x588e23a040f01dc9c889e67f1cae141b8553a699e716dbe285b7de053e8d1b57); /* line */ \n        c_0x3be3e55e(0xbdd11e2bcbf62f2bd4a885bff2437101bee5907779b70c8cd393c01e04fd8039); /* statement */ \nreturn uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {c_0x3be3e55e(0x22c76769d9223dd50fd9093aace7d1fd7fe5d1b38145e96916a435f3bb93dfee); /* function */ \n\nc_0x3be3e55e(0xa3099b31f656ca61c031de915e9992106e603a8a4f64b65125949ec33d9f899f); /* line */ \n        c_0x3be3e55e(0xadda47225df889fc6851a182a50a83006ee037cee40348e76988629376bb5a70); /* statement */ \nreturn readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {c_0x3be3e55e(0x8f2641fa34dd9a2a9974fe4ac09d81af38d9c9a5a5c14f1e2630a56de9e3680e); /* function */ \n\nc_0x3be3e55e(0xc78dc0b1b74cf6f59c97bb4a57098cf28a9d32d5c272bcad6d5f9ca4c4a9238a); /* line */ \n        c_0x3be3e55e(0x35b4e7de6bce4cbcab911cf3a1785195a56b6410779a304019ab3108fd3a7261); /* requirePre */ \nc_0x3be3e55e(0xa3900d4ad5c30643a8a2acea946d8a345b84eb6dc59d9b130f93695f9da6a1bd); /* statement */ \nrequire(_in.length == 1, \"Invalid RLP boolean value.\");c_0x3be3e55e(0x5a1337b74086fd5fa7668bdd7002f975254f86c541c8e0d374372db96d33f9b8); /* requirePost */ \n\n\nc_0x3be3e55e(0x0d7ed84bfbd74999612f05556d6113e749817701db169ca3d2b19c5a3cc4c39c); /* line */ \n        c_0x3be3e55e(0xd73de6bd2c7058b57ce921a5510211ef27c96636cf815f423ea4567266a04bc2); /* statement */ \nuint256 ptr = _in.ptr;\nc_0x3be3e55e(0x0a264784dc3935adad8017098668abca1843d556628908c82eedb777d685c70c); /* line */ \n        c_0x3be3e55e(0xd8492d36a8fd9d0c76f3d903dd83da3c9eb19ceba69d24950730fb36642525bc); /* statement */ \nuint256 out;\nc_0x3be3e55e(0xe0909b63c7a2a55b4ae43a40227ee462643b21ce52e3ad8a081f50917f78faed); /* line */ \n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\nc_0x3be3e55e(0xf5f02a7f8e630619fc86cc78bddc2e4d8e6b5d7f12969a8a46ec1e99f95fcbc5); /* line */ \n        c_0x3be3e55e(0x6b0daf6eabd45a5253c3b48b690137738d1c33c9e604571a8c6ff704c1e9e396); /* requirePre */ \nc_0x3be3e55e(0x3248aa196af2e7d244bbbc8446f3d255eac6d7344c676ec1257ff6e7e9466513); /* statement */ \nrequire(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");c_0x3be3e55e(0xd23e934fa0a4c3bead2babd33a9189e92bea5042199b8d9f5c7ef4682c9d9bf9); /* requirePost */ \n\n\nc_0x3be3e55e(0x913071a895419cfa3c31c2b98c6504778c291c98176309a76ab6c62a220d4bae); /* line */ \n        c_0x3be3e55e(0xc52ecfc284bf729942fa5cb204858a034910b713d87ad65fbb67348eb19019a4); /* statement */ \nreturn out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {c_0x3be3e55e(0x7fba5533d07b4c13f90fa56935685190bf5b8f41b5b83af6d876561789134b65); /* function */ \n\nc_0x3be3e55e(0xcf9a836c35415422d289ef8c51d488c6fa48bfac55619a86e962c785ee1bf75e); /* line */ \n        c_0x3be3e55e(0x9a4a8ba47708364cab74fcfa360e6a076e54476ea5c3700692bd711f3a8a74fb); /* statement */ \nreturn readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {c_0x3be3e55e(0xfb364ef326c675d98e82d8c2c5a0794eef9ea57c04d6a952a3d1e8ba9d5a7d4f); /* function */ \n\nc_0x3be3e55e(0x8a4fce0b293490fdc08ba15b94edd6768b845a50487cb25bccf0dcc1118c9700); /* line */ \n        c_0x3be3e55e(0x9bae27e4f7ab14a3519cbbd92613928baddb81e1af580a6a59014e27dbe9ace4); /* statement */ \nif (_in.length == 1) {c_0x3be3e55e(0xba475da2f091d1b18645d2ff965188669fd5e7ec424605ee0eb49818f3bb205f); /* branch */ \n\nc_0x3be3e55e(0x948c3aa75a157862b4e385fea6885d1d55f2dc7c89157eb08b7e5adcc67175b3); /* line */ \n            c_0x3be3e55e(0xd7ad2d4779eea04ca990358c61e1c879f2f5c3436de1f78219f61c5bb3e7aa07); /* statement */ \nreturn address(0);\n        }else { c_0x3be3e55e(0x458c5c262e3112a792c1233449bf8703023dde0120f777f4caa1645ed04a25ae); /* branch */ \n}\n\nc_0x3be3e55e(0x0a669d9e636451d346006ba7c315bd01b062b676475ecde860dc6b8d82fd2afe); /* line */ \n        c_0x3be3e55e(0x157b42ab467058c98319d04c827ed8da33588f65451d6fd866b45e5a3c9d7bb3); /* requirePre */ \nc_0x3be3e55e(0x06efcd0dc923ec24eb0bb756fa2f74f464c803a42f65dd4b693a97bdc2def26d); /* statement */ \nrequire(_in.length == 21, \"Invalid RLP address value.\");c_0x3be3e55e(0x19fc1690a976a66d9f152f45519bf1c2586014327eed3e1826bfbb7af9c104d2); /* requirePost */ \n\n\nc_0x3be3e55e(0x779c05a7bc323f97d9585ea45474970d49966e0a8be9cf34519c841affd6f616); /* line */ \n        c_0x3be3e55e(0x1fa7ff970a394433fab9035ef0d36d0b03a2ca97c173415b9ca999fa19438c49); /* statement */ \nreturn address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {c_0x3be3e55e(0xcabc34b24ee9323b122ec6d1167f83b095310061b872225a69e2ea9621de1f14); /* function */ \n\nc_0x3be3e55e(0x368f0717bb88a6ebe2f7e0f6ad986649fdad113bed22a37df4894d270d5a7382); /* line */ \n        c_0x3be3e55e(0x0ea08ed5cedcab24bc7298ca9a3a75979c3626c6d8f3c569a5b26157efa76abe); /* statement */ \nreturn readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {c_0x3be3e55e(0xaa59bbf0b38c533952bf01ceea58b32b0638a70bcdcc3947e0fd1bbcc1b23708); /* function */ \n\nc_0x3be3e55e(0x0e434dbb142282a12932fc42c71997c2fd508d62f701e5d400267ae7721e4f9f); /* line */ \n        c_0x3be3e55e(0x938a8d83e607efd630439f697d3fb2b4630ef61268a6addfbed7040f5b6f3ef2); /* statement */ \nreturn _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {c_0x3be3e55e(0x8064b7ef785a4f44727a02e623d2d0351b5c89ac8b7f753fd5d83e7394b24333); /* function */ \n\nc_0x3be3e55e(0x93422d71e892b73940c3613703563590887772552689f383ac7b56529d698258); /* line */ \n        c_0x3be3e55e(0xbc320411c6945ee85a0f14a529d2f19639f95cf9b340ed7b2a730f5e978a6f1c); /* requirePre */ \nc_0x3be3e55e(0xbfa41925bc5d90e344f0edd250e5306516a6d816aa9c3b5ee2a6e7e4916c2c07); /* statement */ \nrequire(_in.length > 0, \"RLP item cannot be null.\");c_0x3be3e55e(0x23267ed09114074701f51f546c5d2c77f1b37b8c5f78162f0c08ccdd8ff6be04); /* requirePost */ \n\n\nc_0x3be3e55e(0xee7444af601dd87ffc253d69b93e606a609b88d39714585b73d38f14e0c0dc3a); /* line */ \n        c_0x3be3e55e(0xf076da5c3cee3ccccd5494b8acf2050afbfe00f2fb40f6bab20d0b58f608b2cb); /* statement */ \nuint256 ptr = _in.ptr;\nc_0x3be3e55e(0x8e564a394f48f6cfa0f376740d816d9702d125b35b8c75f36647b81b5402d6fd); /* line */ \n        c_0x3be3e55e(0x222cbb6f9e599a4cf4dcfbb0743309ab6c9c500fc59e382adcef69e77d3344ff); /* statement */ \nuint256 prefix;\nc_0x3be3e55e(0x2b2b118a5eb371dfa698039efa097fe9f6ae1dff34699656e89da57a23d3b00e); /* line */ \n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\nc_0x3be3e55e(0xbc05e2cd051a50ca2eabaab8be7e164dda611a392f018477ed510f132ff23588); /* line */ \n        c_0x3be3e55e(0xcead9a5ae7adf65bf19a4542aff30432655f3fd17d3b67f8135f13d817c0d223); /* statement */ \nif (prefix <= 0x7f) {c_0x3be3e55e(0xa25bda44df6eeaedb4586d027c9e9b5eb5776497b175ebcb8d4784c2799bd8c3); /* branch */ \n\n            // Single byte.\n\nc_0x3be3e55e(0x56119a0feccb5dbc956557ddb28b8902889642f4222e287b46ccf4ca3818ea5b); /* line */ \n            c_0x3be3e55e(0x44363a1d80fe8031d00dee93a99cbf9d1d3a9facb7aa787b35975b14c6c4310e); /* statement */ \nreturn (0, 1, RLPItemType.DATA_ITEM);\n        } else {c_0x3be3e55e(0xb9f92ae9a11e1492a816bdacd4b68d09385bf2e7e05b65a4721fa87fe522a4b3); /* statement */ \nc_0x3be3e55e(0xc866cf87144495e5105332ed27fa0762b9dc8e077f25f3092761331753a04ef1); /* branch */ \nif (prefix <= 0xb7) {c_0x3be3e55e(0x7abd9a648435a0199168fd531197ad5bf76652f60bb67148e53858fbf8b40ca4); /* branch */ \n\n            // Short string.\n\n            // slither-disable-next-line variable-scope\nc_0x3be3e55e(0x83b65f903f835be1c8ea98022df1d46e0aa31f85c97b23e3f5edb83aa2e5ee6b); /* line */ \n            c_0x3be3e55e(0x545dc4c8d44fdd833368ae9eeebc1d2285704f8e718f0907d572930bdac52a7d); /* statement */ \nuint256 strLen = prefix - 0x80;\n\nc_0x3be3e55e(0x20e0cf160c9c015aa5af3df0a36bac8bc9a31d170689c42767d1a8985b7ee8b4); /* line */ \n            c_0x3be3e55e(0x2322cd3be65cfee68b9186052115a5e687ec3ba0614f38a234929da8fc750b12); /* requirePre */ \nc_0x3be3e55e(0x2291e949c2a3e7836a4dd6a85a75c55bf66eaa0e798df370de4af655ec613893); /* statement */ \nrequire(_in.length > strLen, \"Invalid RLP short string.\");c_0x3be3e55e(0x933877fdb6a37f3c28f7ef835e2104e288618b123747b3019a628f9ed72f6731); /* requirePost */ \n\n\nc_0x3be3e55e(0x5a5d49cb885c25eedff763ef34d34b76a7138aeef7c070985fbf048a0947d403); /* line */ \n            c_0x3be3e55e(0xa087ab6841226ec61be5c7e6bb9a77c2d214fbc655f4b891a7540c995fb5c80a); /* statement */ \nreturn (1, strLen, RLPItemType.DATA_ITEM);\n        } else {c_0x3be3e55e(0x6d947f6b9facca96bc2691c0ca2fb5eab97e1b6897f5d3499d15bfddcc396fbb); /* statement */ \nc_0x3be3e55e(0x92a422af42689a6450bda767a48e984d07b755e69b7f1fa8c33940ba0f151cfd); /* branch */ \nif (prefix <= 0xbf) {c_0x3be3e55e(0xe4d2b5f0a5eb84c865b817ad17d897bf9597e92b021bc8f49137e3f8a12a384a); /* branch */ \n\n            // Long string.\nc_0x3be3e55e(0xc2cb8c260350474fe694253dc76200bd688a55051b015ea91792c8fd8ad3392b); /* line */ \n            c_0x3be3e55e(0x3ac6f480d50906dc14fc01455855f61e6411c595de8b7d46c0c2e2b9fac39e9a); /* statement */ \nuint256 lenOfStrLen = prefix - 0xb7;\n\nc_0x3be3e55e(0x04587281da5517d36d68185d97f660cfdb0c9307ad4cfc63cc793a2dde94516d); /* line */ \n            c_0x3be3e55e(0xe9265051da82bfb5f6e1c1b2addc44a79a5db06696fe2d6606cc019059e01479); /* requirePre */ \nc_0x3be3e55e(0xaf9ab9036d1e589a6f1b1602ced35f9ad93efc7ea77cf1b975c273e3459611ca); /* statement */ \nrequire(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");c_0x3be3e55e(0x873c5721384a6ec0a85f096fcd37f24b87c95841da4f73d22f7ebda1abf73fee); /* requirePost */ \n\n\nc_0x3be3e55e(0x44b4f6399f805bb04765863a273e73874bb47f2e0e5ef6b0e3eaa066f3029524); /* line */ \n            c_0x3be3e55e(0xf469d0e50a135accf162acf3df85b92b0fc7851ab857a138231c80e8b2181e9f); /* statement */ \nuint256 strLen;\nc_0x3be3e55e(0xbfaf3310b202bf496a1b623bf12ae665c6fcc99aab0423cc58f10b5a82a582ae); /* line */ \n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\nc_0x3be3e55e(0x71c758a6d8088c78095c36e5e7b4c136994ef41d3d207f74ac43b64876090b8a); /* line */ \n            c_0x3be3e55e(0x23034e87dc0c1b05fecdd2a44a77d99eca5b0311eecba81d2b507b61f4d3ba90); /* requirePre */ \nc_0x3be3e55e(0x9c16e8dd9d836a81851acc6bf1d269e09f348a057d9ef09da37263a978d161f3); /* statement */ \nrequire(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");c_0x3be3e55e(0xd19da4ea515944ad4c9679100da6f753948cd99d69682cf57eef992b110818f2); /* requirePost */ \n\n\nc_0x3be3e55e(0xf34b7170061a047a040030474a0ceee649930a40461153277e19e5f4a0b99967); /* line */ \n            c_0x3be3e55e(0x466f0f4fc457d22b7a17040f191226b864f1c1dfc68f6352baf866d5a78f93ad); /* statement */ \nreturn (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else {c_0x3be3e55e(0x2d537329a05d63f8f3ed735150d5f44e29cabafa23ebf5accfe1b69749dc056c); /* statement */ \nc_0x3be3e55e(0x2b0a22864890a9652466203798398722d0eba92767cf60e00e102b10babcc212); /* branch */ \nif (prefix <= 0xf7) {c_0x3be3e55e(0x9831d9a877bf0f33b0ec442f081fa1155a92c1a332eff7f67997d29e364250c2); /* branch */ \n\n            // Short list.\n            // slither-disable-next-line variable-scope\nc_0x3be3e55e(0xb9a02a5fd39919e9ffaa52acb4d8156bc8e98094469c1e001798502123b85c7c); /* line */ \n            c_0x3be3e55e(0x3c36304ada187a901da2ad0b65006ac1bba94fd8c22332b722709a823de763cc); /* statement */ \nuint256 listLen = prefix - 0xc0;\n\nc_0x3be3e55e(0x2d2894a69d4e2a16b22254f085e53ddb76ba9d25346369759886ab52b07cd489); /* line */ \n            c_0x3be3e55e(0xe50e06764c82e57d822aac1acf9d948832aa74741b3dcb5a2c54ad92a62aca51); /* requirePre */ \nc_0x3be3e55e(0xe971395bdaa800c1a0e23d7718491ec693abf35e671238d2f8b808ec6dc7d36f); /* statement */ \nrequire(_in.length > listLen, \"Invalid RLP short list.\");c_0x3be3e55e(0x106f63bd87a1f4f92e744811400f6516b78513b737c4c9381db8badb46919eb3); /* requirePost */ \n\n\nc_0x3be3e55e(0xb3e34ddd748d0f5391287bab5cc7210d3bcf124b7bbc0328ea1777459d21fc94); /* line */ \n            c_0x3be3e55e(0x1aa0e4b9eb7f5b956865138edb37daf9e78718bc97117266856fb4da46775f96); /* statement */ \nreturn (1, listLen, RLPItemType.LIST_ITEM);\n        } else {c_0x3be3e55e(0x86e98c512c07403bc2623200b3a678bce6d67aca4a9170d4e7a5fa9882db0d67); /* branch */ \n\n            // Long list.\nc_0x3be3e55e(0x2faaa072354f51b26e551606b48935bb66927f68c437f02c3371253c2fe5a75f); /* line */ \n            c_0x3be3e55e(0x9f2039c8c30b185b0f00650aa7a28c87488cfa80bf548ef76c1018eeea7605aa); /* statement */ \nuint256 lenOfListLen = prefix - 0xf7;\n\nc_0x3be3e55e(0x6c5f7d8aaf90a294423013b1bcc324d69da9728bde578c4054228e127eca0a07); /* line */ \n            c_0x3be3e55e(0xcc5124f9179f15defb814fbe2a5c29674ea339c446cd893608b3884bc7813d32); /* requirePre */ \nc_0x3be3e55e(0xaffd7d445e6366d1343a0d671ee5d23459b873b313e132c5bbbf0b097c54d5fc); /* statement */ \nrequire(_in.length > lenOfListLen, \"Invalid RLP long list length.\");c_0x3be3e55e(0x47c047ca1b9c86b77d0ea3c18e4892f76bf4ddee13da3af407780129798e808d); /* requirePost */ \n\n\nc_0x3be3e55e(0x443f5fbbb5dd03d5fe790bbd1d38d02eade1df9ca9808eef74bf4b4d59e8c0be); /* line */ \n            c_0x3be3e55e(0x78c41d5b47035585d6beafebb69cfd4a31ef989410316fec8bfcde1085409a8c); /* statement */ \nuint256 listLen;\nc_0x3be3e55e(0xd6b74a9dab4480ed950189de4a4c2b0f85cf32cb333f8d8acb03883c72cc5a0a); /* line */ \n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\nc_0x3be3e55e(0x0972559b2e666513512e5cce565f6bb7c7555a8bb86f60e06341646007565709); /* line */ \n            c_0x3be3e55e(0x93e926b21e988070318c2f815a1d90c7505619e62d4240d12c02b7be5b78e2bc); /* requirePre */ \nc_0x3be3e55e(0x559596012c9c0609ed3ae0bd299ddbbf10ded482dac588456f9e5d44f3358d33); /* statement */ \nrequire(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");c_0x3be3e55e(0xf7aea0b1d252186d76e051e1d6501bb59c3174de0de99b47dcd4ca92eb5efc49); /* requirePost */ \n\n\nc_0x3be3e55e(0x077657c77db3446e1e8a37acfad85eba8b85b18dfa8bdf4f1aa7f7eb3f3970e0); /* line */ \n            c_0x3be3e55e(0xc81ecf9fdcbd79347c1baefa42be82d0ae9cc6c36c735762bf4e0b9438a173ce); /* statement */ \nreturn (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }}}}\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {c_0x3be3e55e(0x6d28d35ddda80313e04cea1f718835536f61e46e69baab5c52cc0374f9bcf0fe); /* function */ \n\nc_0x3be3e55e(0xd16cf168d1393c6f1cd1b645976b6251839b50ceadf4ffe7ae5af48a2591d567); /* line */ \n        c_0x3be3e55e(0x71d298345049b0d19a25da1939631a56687a5684439e040835e9f89a14673b42); /* statement */ \nbytes memory out = new bytes(_length);\nc_0x3be3e55e(0x9af2e3fd5d9300593f1dc6192d6bfde68c3ac7c63e2024a512b7fce703739c50); /* line */ \n        c_0x3be3e55e(0xf341ad4502938c3c41004b924a4621cfa5df1100319c6e98438a5040dc20171b); /* statement */ \nif (out.length == 0) {c_0x3be3e55e(0xef8533b6279be39d0abb0ee9a66ef3be0b511ba8d5882fad1974c7c3391f0a92); /* branch */ \n\nc_0x3be3e55e(0xb1902c329d4ec92df52d80dc2390f96e62b8899395c74e726cd06167a441818c); /* line */ \n            c_0x3be3e55e(0x204c84662672ef0f313a4d150286fb33d724c60eca3b6efea8738a77cd113034); /* statement */ \nreturn out;\n        }else { c_0x3be3e55e(0x76e7dd4db16d6d6a713e2200c2e16b400ed99c641fb7b74d2aed0624dffd7b38); /* branch */ \n}\n\nc_0x3be3e55e(0xdb65998b1b1fe4ef1772fe70c541e332b29e44f1cf6388c89b28411700a7e73d); /* line */ \n        c_0x3be3e55e(0xb9d61e7c8678d2aea2e39db688f7ebaae778c2d45569425bd8cfeb892b2481b1); /* statement */ \nuint256 src = _src + _offset;\nc_0x3be3e55e(0x101294013a0ae1efd032555f48b5b64f8eea407f7e61f9a3eaebfc50b6b67ff4); /* line */ \n        c_0x3be3e55e(0x919b97f3f2f79ea9dbb365c199381f19a2fc432755c7db4701a5b451e1b4a373); /* statement */ \nuint256 dest;\nc_0x3be3e55e(0xecd7c2aee1cc93896ca442a585d873433069f854e9fbcbf393128bc7bf5cd5d2); /* line */ \n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\nc_0x3be3e55e(0x94d99aa6bf0494bc5c3e3ef38b147ef44aa33116d76291a9f2e3aa0bcc7060c8); /* line */ \n        c_0x3be3e55e(0x286d335e520ffca2a1fc20b025509214b3e82f0cf2bcae4c0dff76155175e4aa); /* statement */ \nfor (uint256 i = 0; i < _length / 32; i++) {\nc_0x3be3e55e(0xb6ce817e7cb403d5fabd5036b4d2696b1c3ebd8c9b7359752125a2d8a4a20bd4); /* line */ \n            assembly {\n                mstore(dest, mload(src))\n            }\n\nc_0x3be3e55e(0x97c111232e535c0a7556252f0756263766ccaa16a7c1f5e20cc607ec350e50ca); /* line */ \n            c_0x3be3e55e(0x815846ee4b5ca400910e9bbedc6f9086e27a110788514a76cc9f9ee389a692e6); /* statement */ \nsrc += 32;\nc_0x3be3e55e(0x8c82a923f2b8d78844d174750575e8aae940a3ad259b9f6d9796d87a19fbaf46); /* line */ \n            c_0x3be3e55e(0x3238bfc45250e77c452ea3e50a41f89a79addc82c43c5b166d96682698154d26); /* statement */ \ndest += 32;\n        }\n\n        // Pick out the remaining bytes.\nc_0x3be3e55e(0x360037fe9c8b002286dd815a6448f16da8112057a6e768123df50bade034f7cd); /* line */ \n        c_0x3be3e55e(0xf85ed1dc10e21630af5ea3d0fafcd8d68efd7d25579b76d32c6e40edddbb4c20); /* statement */ \nuint256 mask;\nc_0x3be3e55e(0x691339f3d559bc7b548859f7d95cced1c863cca97b03c91bd4067ea79a4a6c43); /* line */ \n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\nc_0x3be3e55e(0x4a142ca85eb2841813496811d7eb47b626f1b6da8e06615a269b6a02e632e147); /* line */ \n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\nc_0x3be3e55e(0xb0425d6402de4f6b525aff0667c880774a6377b304c1de95c12cdc3d5d65f608); /* line */ \n        c_0x3be3e55e(0x794624437a391130a9387b070149c288a3a7d105538d4d5ecacfb27592fcd952); /* statement */ \nreturn out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {c_0x3be3e55e(0xad06076744bc7285166899897f5d988156e4f77e593874f723b4c592a9bee0d3); /* function */ \n\nc_0x3be3e55e(0xb8f4cad18cd909be24830a750c7cdba3d7b269213f3631e9e64b66cfec12e181); /* line */ \n        c_0x3be3e55e(0x6439a35772992f763f44d0394f7591004e21f4e637ef8804ae587542f151a38a); /* statement */ \nreturn _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xf63b1ea6(bytes32 c__0xf63b1ea6) pure {}\n\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\nfunction c_0xa3d35310(bytes32 c__0xa3d35310) public pure {}\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {c_0xa3d35310(0x07d2dbfd6773bf0c253efbc23dbd8a70e3269b2d198c2fc4434c8fda02927f76); /* function */ \n\nc_0xa3d35310(0xd005e50b20e48d0aab3d23a448a1d18ed4b6b5aa807f5ece0d5bc9ccfa9576aa); /* line */ \n        c_0xa3d35310(0xfd14428f275298b742501e5972b8f3392ecc0f8562f119a26656b2d2aef2a4af); /* statement */ \nbytes memory encoded;\n\nc_0xa3d35310(0xb1de9c4c99ef2053c9de64c2fd1bc816aad9fc16ee3445aabca3eb4dc388862b); /* line */ \n        c_0xa3d35310(0xac5a39afc340ecc23bf137aa333760e05d7c7b010e96339f5e9e0cb3a5b4fa0f); /* statement */ \nif (_in.length == 1 && uint8(_in[0]) < 128) {c_0xa3d35310(0x55018d9cecc8324fa80232cf43de398dbf7eaf1c74d96f9447b2afaca9bcde40); /* branch */ \n\nc_0xa3d35310(0x57768d7d9b260261eca2006f79d160aded04684e9456b1c9e43a6f14dab10a4a); /* line */ \n            c_0xa3d35310(0xa86bad33d534ef0d6917bab664cd814619e68632446b8366526646c970222f8c); /* statement */ \nencoded = _in;\n        } else {c_0xa3d35310(0x755ef22bab638cbda22324682012853029309ee3497a06ac1695d121bae7282c); /* branch */ \n\nc_0xa3d35310(0xb37657aee4bdb0b236f45fd1970752228ea1e1aa595be4fd0d2bf0a6d55ea09d); /* line */ \n            c_0xa3d35310(0x5a6d4dfe85364ce135ac87d555fce9906eb80a1a0658b1f3cb967568ac50a560); /* statement */ \nencoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\nc_0xa3d35310(0xeea0a8b8deac5c9bba60708f8432d6738438440c47224a71805548a3d356329f); /* line */ \n        c_0xa3d35310(0x0ef74785c02f8a4a7afd18b4e16e06faeace63c530674fad0fea46dbe5bba338); /* statement */ \nreturn encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {c_0xa3d35310(0x4a74e4c3218b7698124a069090e602607cc6cd214265f6698cf6a7e1b04a6a22); /* function */ \n\nc_0xa3d35310(0x3b5805f527ee9608b783b5a753b989afa4e00bdd89bd1c7702098595be3709db); /* line */ \n        c_0xa3d35310(0x6907e444432b66b4bdfd2d4398e1249efd646661ce1a5980e077138cce13c0c8); /* statement */ \nbytes memory list = _flatten(_in);\nc_0xa3d35310(0x504072edffc81217b43013470ddafa272eedd39c70f2fe7fa5c1c8546c01b4c6); /* line */ \n        c_0xa3d35310(0xad1a33723a1c09ee1ab141d34cb04d4821f16120bc24027083949506f42d48d2); /* statement */ \nreturn abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {c_0xa3d35310(0xc3c92de4fd24b98581d63033dcea8dbd4b2b2d78e2b30a353d9c0a75546e3b7f); /* function */ \n\nc_0xa3d35310(0xd6c908c021d78755ca6b2f81095eac3e4bd5b6bcf110248ed3a1f9aa06a8ee88); /* line */ \n        c_0xa3d35310(0xf6e3a5022dd79abaa76f7549bffcc1d427b18f12a366e7285a8fd195b4117785); /* statement */ \nreturn writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {c_0xa3d35310(0xd113e0d8c1f334bb6289a64b9f6431ea2d19085db998da7055cdadf93e47558f); /* function */ \n\nc_0xa3d35310(0x3313c3eb41ceabd5cd4232dd606734075f96e48090c4b3f826674334aa374919); /* line */ \n        c_0xa3d35310(0x2ece40f345c9638f04966fe77391342df7cfa42bfcd2da0d0b1e996ac18be49e); /* statement */ \nreturn writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {c_0xa3d35310(0xf3c2a3f4e23f4c7b76141db7732294dee95f53603f4b7076ac3d9e3114af3648); /* function */ \n\nc_0xa3d35310(0xcae36d60c80308c0cc27a14ddac13868f17738d8f5fe35d327706aacf85daace); /* line */ \n        c_0xa3d35310(0x9e3da80fd83459679d0fefc56af8e844beaa7d04597d688dffd7c9b61d71b606); /* statement */ \nreturn writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {c_0xa3d35310(0x5429c5f9676472ffd73a1b661f21ede6f2b9bf42f11c84570025f78b1857086f); /* function */ \n\nc_0xa3d35310(0xf07cb4e41fd2d52770f3747676b9efbb9e0024357d19e2a050f47ce8bb3c67b0); /* line */ \n        c_0xa3d35310(0x1c251e11529856f93376ec86d02a68214205971e00cc0a88de2008ed6b0bc29f); /* statement */ \nbytes memory encoded = new bytes(1);\nc_0xa3d35310(0xd742c7739d5f0aa74b52ae27f97d1b9625d8a5eb27265626efdbc6662b6cc6a0); /* line */ \n        c_0xa3d35310(0x8f5115fd51d905c8c5cf45854f1f84b29c56a3c60f2e1601bb6bf80628bc1ef1); /* statement */ \nencoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\nc_0xa3d35310(0x21d8473132530bb0403f0b0e80dfff752cea0b1c4cae952f3657231b29a0a4fb); /* line */ \n        c_0xa3d35310(0xed5002d91e857dec5a3c2d4df2f361fe7c09dd000ad87b057870f61a70757d50); /* statement */ \nreturn encoded;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {c_0xa3d35310(0xf2f3b2ae23a4ec27fe58817688109a1bca5c3fd841d0a628270168ab37c30aa0); /* function */ \n\nc_0xa3d35310(0xe229205ad12be150acca727533a2c573091ce1f03f3fc07e11d5949c3ee319a1); /* line */ \n        c_0xa3d35310(0xff9e8b836eedd868f854c0156581f3a8f409fa8cb9fce232608efb5d1ead332a); /* statement */ \nbytes memory encoded;\n\nc_0xa3d35310(0xb5be57cb8bd360c1ca4fc36d987e5750cbc02c7b16ea45f6308243516d5643a5); /* line */ \n        c_0xa3d35310(0x4c084f7d3d9ee6eb5a8e0373d615c5867a11dc082b0c8a40db42cbcecbac97e2); /* statement */ \nif (_len < 56) {c_0xa3d35310(0x3505429b0b88d2471cb978e931be61adbc03a84e3abe6a4c450ae86961cff719); /* branch */ \n\nc_0xa3d35310(0x402ef38ea67f823cdd0d75b47c13a6255cfcb77497c5b1f3fd1e5695d924aa52); /* line */ \n            c_0xa3d35310(0x241a44647c8874972f5bc16909c89c396f975cf00270c92a9ca94020b8128a64); /* statement */ \nencoded = new bytes(1);\nc_0xa3d35310(0x63f6cce187e2724cad114d2304d0a8ed45ef557cd472a81aac832f301f50c658); /* line */ \n            c_0xa3d35310(0x706813e05331cc42613ef17a095c145673e81f2f39eb07b8999b25ce99793050); /* statement */ \nencoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {c_0xa3d35310(0xdf1cfa220949862327b2884ecc38b857464875e4a34923c7c1f86fb69d25b90d); /* branch */ \n\nc_0xa3d35310(0x63f804bd05c8ea6a8685caccfbab51a0628063ea5780487952cce2e584c95931); /* line */ \n            c_0xa3d35310(0x40e77b3e5ae165349bf91259535c1f1e6c556e7803fae6590ce49935764970ad); /* statement */ \nuint256 lenLen;\nc_0xa3d35310(0x5899276ddb1bca411232377642fe4fd5fd4214f60e3c43c4368b15368eadaea8); /* line */ \n            c_0xa3d35310(0x2fae372b317239d409a47407e8dea1888bd3c867fa0efca6b65f64a0ebf21a11); /* statement */ \nuint256 i = 1;\nc_0xa3d35310(0x66ef02d41e91b36b6840e86ac92d763d1cfb96f7be602016f3463cc6ca5ae5df); /* line */ \n            c_0xa3d35310(0xc72dc81273eeff332144c292768bfb8e1d1d5ce298b2194e0f47c254f423e965); /* statement */ \nwhile (_len / i != 0) {\nc_0xa3d35310(0xa8f24cafbfee484ad20e167a8057c7c90c46d5ee6e258de1fba29b86f5a61b55); /* line */ \n                lenLen++;\nc_0xa3d35310(0x1b7ab80e58b3f557fc367bd9fdabb291ec4f12054ea1a950bff51adf14362c24); /* line */ \n                c_0xa3d35310(0x796ab6f5427d53a32d730e55fa2fcd05d1ab9005a52cb0c578e132b649d995bb); /* statement */ \ni *= 256;\n            }\n\nc_0xa3d35310(0x5d40032f3268c14f21b0353a644f2e18bac48336d177ceb00879bf9370ef0265); /* line */ \n            c_0xa3d35310(0xb08850a82f6a6fa8a3810961436b07b6e12647fc7c12cc01fabb2de5e189050a); /* statement */ \nencoded = new bytes(lenLen + 1);\nc_0xa3d35310(0x67c2cd9fc820c60c4793d8ff953e97cd14baf2e268307bbe7f6e301308acc792); /* line */ \n            c_0xa3d35310(0x36bddfa66f2d26aff6941ce53ae1352efc67696d84ad9c95977c3f3f405c4ce6); /* statement */ \nencoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\nc_0xa3d35310(0xe19ebdfc39d7a546650aa5e4a86ba2b9e7696b8df720de4d1320ac11a1dd7ebe); /* line */ \n            c_0xa3d35310(0xf30dd5b4a5854244c595baa6a562df84b5cef3d095c0b2f93cd20526a2b09150); /* statement */ \nfor (i = 1; i <= lenLen; i++) {\nc_0xa3d35310(0xca9ba6bebd1c1094e130ba6d8bf1f088c3f3d1444f4e1fd2bc67a4848376fda1); /* line */ \n                c_0xa3d35310(0xd5930158e4cdddff0f0f4f1553e0a8c07e34bd75f84016c9d3e812d1b973c1be); /* statement */ \nencoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\nc_0xa3d35310(0xdae29b43af15327a8a8bdafdf7bae94580a451728e51e01794f9f0e22a7779a7); /* line */ \n        c_0xa3d35310(0x9002e4b9ee857b6b52fb80c1de1a4a1c18b68b660e9a1643834b90f901da4d32); /* statement */ \nreturn encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {c_0xa3d35310(0xa991cd69bd5b8f139a47a464016b182edf0882a37ae76245f0b137b16b66defb); /* function */ \n\nc_0xa3d35310(0x77555358a87c97d17d6bb54b19debe70e65bd178b4086f66965840ec6dc7043e); /* line */ \n        c_0xa3d35310(0x596c37ecef5aa978b4c445bf91de9af68db123b892548359ab17f499f50bdb82); /* statement */ \nbytes memory b = abi.encodePacked(_x);\n\nc_0xa3d35310(0x0edf173ff022df9d214f68568b7f888087d9580e864b09336a71750173773b5e); /* line */ \n        c_0xa3d35310(0x8569fadc4425886d1abdef1da8b6f0b50c55af528a84efd50f98f4889c56e2ce); /* statement */ \nuint256 i = 0;\nc_0xa3d35310(0x871e2242cf8701ebc1201cb0910dfdf80d5eb71075f56e9f60292586b87e1648); /* line */ \n        c_0xa3d35310(0xcc5c15537ebe177e63e70097e5a9acf74dc44a42d8a3db06d5191f482116cdc5); /* statement */ \nfor (; i < 32; i++) {\nc_0xa3d35310(0x85c6f9733215962a82e2812b7515a88021a4322d4fc1af07f98886c327eea4c1); /* line */ \n            c_0xa3d35310(0x5a2711da95bae504153cde9105e5afc10cae7119de4074df362b7de999bb1fda); /* statement */ \nif (b[i] != 0) {c_0xa3d35310(0x45ea6b6a72ebbf05c3f33cd53658c306eb9ea7245aa08faf3e1de5f0983e591f); /* branch */ \n\nc_0xa3d35310(0xe5f8e8e3070b2eaffe16fcda955c6caae5f61d9bfbb89ac702f89d5e113e5853); /* line */ \n                break;\n            }else { c_0xa3d35310(0x52c87e3c14c5c1144241d0e9b24afa53b59ee021c2d86fb0f425b8a081f73517); /* branch */ \n}\n        }\n\nc_0xa3d35310(0xb359298d9c1f2d0b02550c6e04e79b704bf867fce47e6966e8753f3b0c36e6e8); /* line */ \n        c_0xa3d35310(0x325ff7e7443ed444b454c1a954bc8bd378567e6495bd711eac5e143c7864e072); /* statement */ \nbytes memory res = new bytes(32 - i);\nc_0xa3d35310(0x8f070966a6ae448206de0f8fa76067ef630116c78e26fb3584f43251410bf48a); /* line */ \n        c_0xa3d35310(0xe00195bf446d66b3a8d145dfefb2b81b5104e438e704c7247a57c038e96cadeb); /* statement */ \nfor (uint256 j = 0; j < res.length; j++) {\nc_0xa3d35310(0xfe0b9e9d68edef718a51c82135cd5c2d17262f908df4e2ad9a45cdc7cfb40a78); /* line */ \n            c_0xa3d35310(0x430d12005886f214886ee3143bf691f31c245e9738a2432da4f7344cf7096ac3); /* statement */ \nres[j] = b[i++];\n        }\n\nc_0xa3d35310(0x6a4f9f83e13e1d30b062877d93c9e33691eb915a03c2a8a02f39755fb49cf867); /* line */ \n        c_0xa3d35310(0x146ea2424a5d887781d24ca03933a69cee58ac2f55bd8af5b7dcb16b3242e7b8); /* statement */ \nreturn res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {c_0xa3d35310(0xb6536411b1b8cc3269f17158d55c79a95f291a483161aa275299a59b44ee518f); /* function */ \n\nc_0xa3d35310(0x9d140ee64a8fd0e1dcb4b916d1a5d15222639235fba9dde876ad1aee6308e681); /* line */ \n        c_0xa3d35310(0x212595e31c59ffebb38011c6fc7d8a4056a69cb696686a79ce7f1d717c910d54); /* statement */ \nuint256 dest = _dest;\nc_0xa3d35310(0x8b88900d8617120e3fc5b6bb2298eddb415e633bc738ec2cea5cc9b49ac3f38f); /* line */ \n        c_0xa3d35310(0x3336dc16642ddfe0d12f10a095cd198dc7f1be2eb625c9cd91c8cde79a0e5d62); /* statement */ \nuint256 src = _src;\nc_0xa3d35310(0xdb515e9d1a7ed621edb355cb2aab614bc8382cd32f5541a769c41a17c3720ff0); /* line */ \n        c_0xa3d35310(0xf03309496ef6b44596831ee96713b509e62c118d6ea5be7bd8fbf45dc25d2a22); /* statement */ \nuint256 len = _len;\n\nc_0xa3d35310(0x0c96f05a15fc6fd4344d7905c027c6e40b96ac81bd625e9cd5c183fa9b34b59e); /* line */ \n        c_0xa3d35310(0xbcec32657a194f4834526dab16c1b4c3ee0a4c472ab67cf62cf2bc6c723425fd); /* statement */ \nfor (; len >= 32; len -= 32) {\nc_0xa3d35310(0xe086798de859857732ecef7c1baf07029a597b7f5a8d95e70edeaaa3991c6124); /* line */ \n            assembly {\n                mstore(dest, mload(src))\n            }\nc_0xa3d35310(0x69b078dc17381e14ae91b5bdd659b8eba3dc1e78ea0d178179030c240837b17f); /* line */ \n            c_0xa3d35310(0xf74d32190cf8bc99727477849737e16ba15b0a1ec3d940c42a42e9ff185c6371); /* statement */ \ndest += 32;\nc_0xa3d35310(0xb4f08cb4f80d98151171c220ec836817a15859dd177d987b966235fcd4195f94); /* line */ \n            c_0xa3d35310(0x1b0c0cb5dbc6dad87ce34cf1406ac0f62eea97b2d03c5562eab04684c4b391c9); /* statement */ \nsrc += 32;\n        }\n\nc_0xa3d35310(0xe57a51f3102a9326b5e1604bd7de26a604ae5008781ffb4a8f7c978f90a9953b); /* line */ \n        c_0xa3d35310(0xdadd102f0104fb9f3e4c11f04cfaa80234bfb12b9794e1ba7e77e0e0182170ad); /* statement */ \nuint256 mask;\nc_0xa3d35310(0x96eb30c438825709c59612763b3c67e3228b2520c00a5107bd3d13e64b0cf23a); /* line */ \n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\nc_0xa3d35310(0x49c05262cab35b0860faad0727a93e9146951da6a4493e4b2d3169e00d2340d2); /* line */ \n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {c_0xa3d35310(0x688852f48c47efd2db0bbd4aa5b8367c0a6b67a4121474ec71d0327ce118a818); /* function */ \n\nc_0xa3d35310(0xd13338cbf399f9b14727e24b588bec4efd6bc31d331d65650a1a3f7f150204d0); /* line */ \n        c_0xa3d35310(0x0a9d0d0a43e585dbcf4ae56a8675f4de46b454e4748d30c003a19dacbfcad726); /* statement */ \nif (_list.length == 0) {c_0xa3d35310(0x306e823ff0165e71bdef733c9a54d60edf2833cff953f55ae087c25bbaaf0735); /* branch */ \n\nc_0xa3d35310(0x5a11f8fe28ae3034180625a221628307d9437022afb512ca4eb570140f51e1e3); /* line */ \n            c_0xa3d35310(0xc6487a04942f7f012d826d2536e790b5c81eeb87fadc335bedbec9829da2098c); /* statement */ \nreturn new bytes(0);\n        }else { c_0xa3d35310(0x3cf02aca9a1c03eb2d6ed9fafba3220fdeaf409ce20bd46db4c6f5a7b441460c); /* branch */ \n}\n\nc_0xa3d35310(0x27d2c47e5fee3447d606f29c23aa7d3ab745adcfc86e71b74c648497191d6adc); /* line */ \n        c_0xa3d35310(0xdaae5c53c52ff6dde19891c37a1d21ad579fabd5d074f175796fd864e00b69d7); /* statement */ \nuint256 len;\nc_0xa3d35310(0xe5d718ba2e0015cd3bdaa32958ff8dd8244f7353c018e750abd00712baeb7a64); /* line */ \n        c_0xa3d35310(0x6191619f77176783ae9ee9041eb973593be65899c6e14622e0a0c98d03ca0e09); /* statement */ \nuint256 i = 0;\nc_0xa3d35310(0x39d0d4a8c88ea408dfc365c9cffa9524d640b0bf6dea30aa69c1bb67926fb100); /* line */ \n        c_0xa3d35310(0x44ec53e89f013c991025d3515a4c4c1c6673923885ca3339446e4477c5f8c03b); /* statement */ \nfor (; i < _list.length; i++) {\nc_0xa3d35310(0xd81e3d770e842ee18c3175a56664405420b333c1c4e1c503f6195f94fa7dacdf); /* line */ \n            c_0xa3d35310(0x3fd7d293c080b1a22ec0fd9483278f0f5c8e7d117f7f6baf420c24c140fad7ef); /* statement */ \nlen += _list[i].length;\n        }\n\nc_0xa3d35310(0x453ba7441e3fd3e59156754a7f35074abccbf10c8e1d93690436f6d45ab7dc33); /* line */ \n        c_0xa3d35310(0xf9e9b12e98196965d61d34b4a21d98fa1275e7760324a60730aaebc074ea5f24); /* statement */ \nbytes memory flattened = new bytes(len);\nc_0xa3d35310(0x2e14ebfdf6c5ec363daff5ddde810d60ae1cb8dc40dd08440ee66c86efdf4a57); /* line */ \n        c_0xa3d35310(0x4f8b7f3739d89a48ab2a364180953e95f0a6d32cda596aa6608350881a4d2cf2); /* statement */ \nuint256 flattenedPtr;\nc_0xa3d35310(0xe08a280249e255fbd64f7938247cd05321cf34d66a1d8adc8b31a47ff4a26218); /* line */ \n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\nc_0xa3d35310(0x691e58f513be07cd141a5b13c6228bf5b7e290757e2e765f32b83ee54752c4bb); /* line */ \n        c_0xa3d35310(0x21ec0000b5925da2c4e89e96a6d4a21132c3de57f5bbba595174229ee9ff6b49); /* statement */ \nfor (i = 0; i < _list.length; i++) {\nc_0xa3d35310(0x29e7e9ee6a52d18c23a87c17571285da9788a0cc3406701e4eacb26cb21b6d51); /* line */ \n            c_0xa3d35310(0x0aa4cd747ea4ebe43954417b15d249e4721ae6544fe71cc1568a2cdaf08b5075); /* statement */ \nbytes memory item = _list[i];\n\nc_0xa3d35310(0x419178b20e80d413992013e8cb5e50c41feb40a540d1f29554e44e91512fe43b); /* line */ \n            c_0xa3d35310(0x06f9e0c95d984aaabde734bf1ab6815efb815d5077dd6699f08da32298b064b9); /* statement */ \nuint256 listPtr;\nc_0xa3d35310(0x236de50804c9fb0d881bff61b16f7771f5405e1b2bedff8b71b6f7556144c3d7); /* line */ \n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\nc_0xa3d35310(0xb1884356ff7ba7a5e35686b19168245cee2461b824994c33edbc61f5aca516b9); /* line */ \n            c_0xa3d35310(0x63415898a686bd86315dd8d9f97d261c887b27301b20e6dc906b26b85a2ad583); /* statement */ \n_memcpy(flattenedPtr, listPtr, item.length);\nc_0xa3d35310(0x4e4fb36b0cbe7fee33cb2949d5ff33f53d983f5731bdc5f6b0790572d1fb33b5); /* line */ \n            c_0xa3d35310(0x547daebd90c5c540b81d6bfd3dc99ad3854233d80ff22953a75439fcd687723c); /* statement */ \nflattenedPtr += _list[i].length;\n        }\n\nc_0xa3d35310(0xcf29c691bc81c7208c7311fc1cf315de6b38e89a66a994893d9cc325d5f5fba4); /* line */ \n        c_0xa3d35310(0xb7aef5c675ddbb4671e12d9712cba513cf94f9b3de109e8cdac2e42577a3f987); /* statement */ \nreturn flattened;\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x1763e9f8(bytes32 c__0x1763e9f8) pure {}\n\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\nfunction c_0xda3ce6dc(bytes32 c__0xda3ce6dc) public pure {}\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {c_0xda3ce6dc(0xb44cf2d9ec209a1c2e7a32a427b886796a145f1fbcc44d2074483eb2139f9ce0); /* function */ \n\nc_0xda3ce6dc(0xca3901eda96888713b78147d1f40dffae28d2e58443875f4a7458b6a1e9e182d); /* line */ \n        c_0xda3ce6dc(0x93cef3790dcb263cf3f116d515d9144d3db2b398b48ee072ee092153a63f3ac6); /* requirePre */ \nc_0xda3ce6dc(0x391fdc6e8f9304f9469707d51b19927080a1a19b857635c0c5febb35afdf852a); /* statement */ \nrequire(_length + 31 >= _length, \"slice_overflow\");c_0xda3ce6dc(0x455ecfd390cb55b9f47ad861d22814f9298c7d6a661f925238833299359d40aa); /* requirePost */ \n\nc_0xda3ce6dc(0x72e61e47cc830e7b53adc0e0ff19a2d78a905186ae27017ae4f85a3f676bad2f); /* line */ \n        c_0xda3ce6dc(0x0c9b3f35466d7c81470bfcde9f8a38e497abe2642749ee7ace0dbd9aee04ba4e); /* requirePre */ \nc_0xda3ce6dc(0x53f828f27357da7dfff3e222ba8f8a11460556dded0c46ca167edef10ea7313b); /* statement */ \nrequire(_start + _length >= _start, \"slice_overflow\");c_0xda3ce6dc(0x38a70ce6879f496e307ce8b23fd44f0bebe221a968b0e7d71d3cc841b33b09ec); /* requirePost */ \n\nc_0xda3ce6dc(0xe6a249976e5b35b3399268e6b028d10c6975946b43f673573b3c47f8238fad50); /* line */ \n        c_0xda3ce6dc(0x91c00f19e137f097015661e51d743913d8c25637dc633dff0440f0f0edad248a); /* requirePre */ \nc_0xda3ce6dc(0x571bcb1cc61d7ee2e1ad617db1de979b7b56945fec9708156270a4536dbfe2ff); /* statement */ \nrequire(_bytes.length >= _start + _length, \"slice_outOfBounds\");c_0xda3ce6dc(0x15c074544eae117e55f654020bb05e3b7548d7a06cb78634300d1a49b2e14396); /* requirePost */ \n\n\nc_0xda3ce6dc(0x24993a6130a3dd04fa691b55af9c7db4b47d9e5f00acd6dfab241a9341f8ab0b); /* line */ \n        c_0xda3ce6dc(0x468ee32a52ac172a92aee3b3ab9a33ece26936465c604f8abdb0334926253c9c); /* statement */ \nbytes memory tempBytes;\n\nc_0xda3ce6dc(0x246a6a6cda234e3944029a56311de6b3068ada617f9340f9704bae2781d6165b); /* line */ \n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\nc_0xda3ce6dc(0x33bf4199cb4ca4b732d65c0fe9ae8eebe9936738fac48418b816aef42ccd2259); /* line */ \n        c_0xda3ce6dc(0x9b3fea109a11b56fa28e8e5f12b926677eacccd2cbf526422ed5ab05dc88abf6); /* statement */ \nreturn tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {c_0xda3ce6dc(0xc4f65288540f91492165a6d99a59eedaf0469bde8616fa168da4f0ad899beb13); /* function */ \n\nc_0xda3ce6dc(0x5b259171db3a2fa2672b5b90df8e3a70ca49d680340921a72900164b973b7591); /* line */ \n        c_0xda3ce6dc(0x9512082182328aa941d5211ffd93cc6808f29108227ca078801bfe1c69c27685); /* statement */ \nif (_start >= _bytes.length) {c_0xda3ce6dc(0x6875aac199290c6c769a01e4eeac148c11a23b9c7024206b6e5317e0bdd1a240); /* branch */ \n\nc_0xda3ce6dc(0xb965d8195cd9b82bd748f565aa6f2ee6268aa705d9ac1a1eaf1d490230f95c23); /* line */ \n            c_0xda3ce6dc(0x292d29baf7da1e2d0ef10306f1a360261c3182b8bbc50c4e2f085537b5bc48dd); /* statement */ \nreturn bytes(\"\");\n        }else { c_0xda3ce6dc(0xf1d18299d87cba2ab6f3328fc82f4f3b326bb1c9897594b2c38898696efedf09); /* branch */ \n}\n\nc_0xda3ce6dc(0xdf45536003f9cf235df17798dc73169109507e83cfb772793e8a7c4c149ab495); /* line */ \n        c_0xda3ce6dc(0xe14ae72189b834bb1a740b5c01a8d1a48649c1a62bdaeed331acd17807cdeeac); /* statement */ \nreturn slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {c_0xda3ce6dc(0xf580ad151fefaea3478401f33ea6b5f89ce8abde439eb8da46863195994f5ec5); /* function */ \n\nc_0xda3ce6dc(0xa2c14b79745f7333265e5cf538d5c2d54d636b5d63fbc1d382db60303769c458); /* line */ \n        c_0xda3ce6dc(0xcafab6afb13d13e92d50d6209db9a88153d6288610ec82a3eeab80bbda5447a1); /* statement */ \nif (_bytes.length < 32) {c_0xda3ce6dc(0xa7650724c4cea8fc6d28b827ce52ad99db2f3d41d9c8e1d2eb92a33450113741); /* branch */ \n\nc_0xda3ce6dc(0x4ab587658ff69e5b99e0073849fa8ee8c983e945240528ccf4fe7dce3fd6edbc); /* line */ \n            c_0xda3ce6dc(0xb87e28c6d98f04552a8797891bdf08d5935a7b221fe87f342616e46b808cf5ca); /* statement */ \nbytes32 ret;\nc_0xda3ce6dc(0x28e1202de4976f696ae326c80f12d57ea8a0a58f1143f7b4a6611b08997c73fd); /* line */ \n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\nc_0xda3ce6dc(0x1b60b5b4cb2eb059d9c3f7daddba03df9992947140f141166cbde73067d4ee99); /* line */ \n            c_0xda3ce6dc(0xb513b3fb33821a9df29bed1509cc25caac08f564d448c1446f2da9bdf1c333b9); /* statement */ \nreturn ret;\n        }else { c_0xda3ce6dc(0xc1d0a11b267c61dac27fe619ea1f3ea3ccfe10f5947b43dc0c94eeee41c5f674); /* branch */ \n}\n\nc_0xda3ce6dc(0x7796b0c1609ae5846e9d17871044e6d5ed2e5ccdbf4031ec8476c22b1b942886); /* line */ \n        c_0xda3ce6dc(0x3f8d6ebe3228d9c2240e229e66c6efb0740e7a6cf14a81d51588d6b99b13f792); /* statement */ \nreturn abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {c_0xda3ce6dc(0xc4297b8e50d1142266967f86536f6ed697f07ca54497b55bd2a5bc4c211bec04); /* function */ \n\nc_0xda3ce6dc(0xc9d441783b24b8018c477966f30d318bfbfab1ddcae15d82dc88dc7e4af7add8); /* line */ \n        c_0xda3ce6dc(0x017fbde2068ab87577ccfa497c3afd823c261a6f2fb44451db17830ef6c2c088); /* statement */ \nreturn uint256(toBytes32(_bytes));\n    }\n\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {c_0xda3ce6dc(0xc8913e31383c6381e52d957da6be7833f573aecb074c0f8bbdf8994b90597864); /* function */ \n\nc_0xda3ce6dc(0x3f103ebf4b1f79999f42d0babb7ca881d70e43f6a92e2fe5e7c1e860616cecf6); /* line */ \n        c_0xda3ce6dc(0xee0fc0c1ab3e54bf22be976c96b5b69900cf4fa14c47a21b5cbeb632796cf033); /* statement */ \nbytes memory nibbles = new bytes(_bytes.length * 2);\n\nc_0xda3ce6dc(0xe3f0e4e658d700491db4304b1f0ad3099654a86ef25f9714a9c5f7cbbc0648f2); /* line */ \n        c_0xda3ce6dc(0x390feccfe566c8b62ddbcf145cd87d4525b4dc7183341bbe6f528b1874a0c0bc); /* statement */ \nfor (uint256 i = 0; i < _bytes.length; i++) {\nc_0xda3ce6dc(0xff8690296861590bc45c54bbbcd627626c5764ed0094022745baa8f700d3b6e8); /* line */ \n            c_0xda3ce6dc(0x2cfed4a507f13b01e674e96a9f8b018dea156fb4f680ded3af015d702ef47c83); /* statement */ \nnibbles[i * 2] = _bytes[i] >> 4;\nc_0xda3ce6dc(0xa920ce47e398b971cf2a89639bedd2b90eab3fb8dcb2f0a296f9fa713ed938bd); /* line */ \n            c_0xda3ce6dc(0xec75f4ae8ab956722e8eb7b5f70b507796e2eb6c6ab3f5195829eba838f540a9); /* statement */ \nnibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\nc_0xda3ce6dc(0xd2c971a241c72697e879e2582565bf7d1ed82e03ea55c9599f317ef54bc1e6b8); /* line */ \n        c_0xda3ce6dc(0x78eab2bb4e9cdd29c97f62b4f09433369251865d98ba8e469c571d7eca94abb4); /* statement */ \nreturn nibbles;\n    }\n\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {c_0xda3ce6dc(0xb1a4c8f1684664aa77ca1c0880e6cf843fae5e2abc3739c9247134764c092366); /* function */ \n\nc_0xda3ce6dc(0x99b0cfd6f48a3461e759b584e5361aa64d14f02ed2fd3e6929eec9a2e25caf8e); /* line */ \n        c_0xda3ce6dc(0x5d92529dd2b83769d02091a8d7a6f0b2db6b4826f1a00a8dba0a598dda591768); /* statement */ \nbytes memory ret = new bytes(_bytes.length / 2);\n\nc_0xda3ce6dc(0x68f1af207820b10a884ba993160a3a1e84617884b378ada19a37ed55da7f0bf7); /* line */ \n        c_0xda3ce6dc(0xc663f079d417c2297edb6913bbd6530584e9c24dcbc3551d138956b7108b8b8b); /* statement */ \nfor (uint256 i = 0; i < ret.length; i++) {\nc_0xda3ce6dc(0xe8dddf2fc217159de49ce279bcaf6bccb8add6963c8ba2dfdb9cb3f98afb090e); /* line */ \n            c_0xda3ce6dc(0x94b5958b6dfde93ad96f68fcf466dfe5d182938bd0300cdb7c136e1f03e34d28); /* statement */ \nret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\nc_0xda3ce6dc(0x7909f65886a370e9c6de3893321cad836ce60bc54120e8460b69b99f965c4632); /* line */ \n        c_0xda3ce6dc(0x82da0324547c071f3e9fd3a945e095cd8741b1a9294a653a1c982dc1105f5bc0); /* statement */ \nreturn ret;\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {c_0xda3ce6dc(0x41b86589e176c7ce26716320230cda2faa7451c63bd9c0f330417dc872c6d12c); /* function */ \n\nc_0xda3ce6dc(0x64497ef97d33cf8a6ee25a1c0dc4e74aa4741a912ef63455032e4e30d55c22f4); /* line */ \n        c_0xda3ce6dc(0xbf43573754548bb23c950d386ecee57a0556b4f83db66de7ce1ff9294a925126); /* statement */ \nreturn keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xbb7caaa1(bytes32 c__0xbb7caaa1) pure {}\n\n\n/**\n * @title Lib_Byte32Utils\n */\nlibrary Lib_Bytes32Utils {\nfunction c_0x31623bf5(bytes32 c__0x31623bf5) public pure {}\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as a boolean.\n     */\n    function toBool(bytes32 _in) internal pure returns (bool) {c_0x31623bf5(0x4546bde0460b36cdbc7244b57d7e71091011522f6f744eb96adde675e1032b31); /* function */ \n\nc_0x31623bf5(0x058fe783b3c5bc839405aaf3975c11ca984a36d45047bd268689f25be551e1c6); /* line */ \n        c_0x31623bf5(0x80eb3deca978362826706aedb05c341a40b5b29fc4e6231685323388616f465b); /* statement */ \nreturn _in != 0;\n    }\n\n    /**\n     * Converts a boolean to a bytes32 value.\n     * @param _in Input boolean value.\n     * @return Boolean as a bytes32.\n     */\n    function fromBool(bool _in) internal pure returns (bytes32) {c_0x31623bf5(0xcc121f4fc91c98df44104042cc7c587f8c872e752360ca64448fb3c77bb21060); /* function */ \n\nc_0x31623bf5(0xfa4a72e65f059665a36bfc4f8da5cbdb258ecd6df59be50facf9db6c33e6dcad); /* line */ \n        c_0x31623bf5(0xe7e55efcb6854ed5d6ec298646f86bee02d9f40d97dacdb70e85e8f1f85ec804); /* statement */ \nreturn bytes32(uint256(_in ? 1 : 0));\n    }\n\n    /**\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as an address.\n     */\n    function toAddress(bytes32 _in) internal pure returns (address) {c_0x31623bf5(0xc625b87f7c8cb39514923404e9a350e14e36175a2d4f19b8850aaf775057bce1); /* function */ \n\nc_0x31623bf5(0xf907953fbb47c432bbe84dc56f8aa99707001fb062edeac749d61f46332551b5); /* line */ \n        c_0x31623bf5(0x47042529e658a1b0f248e97c21c14b229a1db30fe174da084d4d7d898317d09e); /* statement */ \nreturn address(uint160(uint256(_in)));\n    }\n\n    /**\n     * Converts an address to a bytes32.\n     * @param _in Input address value.\n     * @return Address as a bytes32.\n     */\n    function fromAddress(address _in) internal pure returns (bytes32) {c_0x31623bf5(0x5e141e6bf7792ed49dafb6c4c95ee2f14cb2ce9ad33007b2cec53cfbc6e4bb17); /* function */ \n\nc_0x31623bf5(0x430154562d501304e9be904b17c6ad8a180a1c896c82097a5b77519fa3e28a0d); /* line */ \n        c_0x31623bf5(0xf98ccefa85fda8dfb13a797757b1c8567dddcb7e758f24da1e32f75744bb6be5); /* statement */ \nreturn bytes32(uint256(uint160(_in)));\n    }\n}\n"
    },
    "contracts/L1/rollup/ChainStorageContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x66fef148(bytes32 c__0x66fef148) pure {}\n\n\n/* Library Imports */\nimport { Lib_Buffer } from \"../../libraries/utils/Lib_Buffer.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title ChainStorageContainer\n * @dev The Chain Storage Container provides its owner contract with read, write and delete\n * functionality. This provides gas efficiency gains by enabling it to overwrite storage slots which\n * can no longer be used in a fraud proof due to the fraud window having passed, and the associated\n * chain state or transactions being finalized.\n * Three distinct Chain Storage Containers will be deployed on Layer 1:\n * 1. Stores transaction batches for the Canonical Transaction Chain\n * 2. Stores queued transactions for the Canonical Transaction Chain\n * 3. Stores chain state batches for the State Commitment Chain\n *\n */\ncontract ChainStorageContainer is IChainStorageContainer, Lib_AddressResolver {\nfunction c_0x8b47d469(bytes32 c__0x8b47d469) public pure {}\n\n    /*************\n     * Libraries *\n     *************/\n\n    using Lib_Buffer for Lib_Buffer.Buffer;\n\n    /*************\n     * Variables *\n     *************/\n\n    string public owner;\n    Lib_Buffer.Buffer internal buffer;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     * @param _owner Name of the contract that owns this container (will be resolved later).\n     */\n    constructor(address _libAddressManager, string memory _owner)\n        Lib_AddressResolver(_libAddressManager)\n    {c_0x8b47d469(0x7abe9c0756d71ffbb4f645b43fda13e58ba184ecaa9a7e3c003bcfc4e2477b12); /* function */ \n\nc_0x8b47d469(0x2ca0c39746fa47680b5d9ab6d8c134495e89e802c4b7a0da43900af5a270d2b8); /* line */ \n        c_0x8b47d469(0x9202e3e4a0279c54da05c2b9b4e63b4bba60eb0598d8de954725ca5d0885518a); /* statement */ \nowner = _owner;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyOwner() {c_0x8b47d469(0x1e376ba7b57dc9d3a06c53203648a1c070081dcdf59ca435e4ad692cbe6446ad); /* function */ \n\nc_0x8b47d469(0x303e21a9d54f50e3e70f03bad7984721c91fb0d79ba9135633c3b6ea4111aa0b); /* line */ \n        c_0x8b47d469(0x023851f930d30de31b1dbb694882a55b5c3e5910e750b7aa63039c4424d13eb5); /* requirePre */ \nc_0x8b47d469(0x3031bf08958fe6446f815ee52a6f95a4be174739e8a6dba2e44b4341c6a77bbf); /* statement */ \nrequire(\n            msg.sender == resolve(owner),\n            \"ChainStorageContainer: Function can only be called by the owner.\"\n        );c_0x8b47d469(0xfe9a6a55b46a5992cacfc0cdda61a839e305d2c82ba62be2cda802e1d78acda4); /* requirePost */ \n\nc_0x8b47d469(0xa2a27db2bae45efe9a859d7c8dbe6ddc4646577e76c2ad54ce85c8abfe7a5731); /* line */ \n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function setGlobalMetadata(bytes27 _globalMetadata) public onlyOwner {c_0x8b47d469(0x36dcd758e3c65bebb108c5b4c6ebd9a2c1505c1137296440e40d8acd34cf4c66); /* function */ \n\nc_0x8b47d469(0x8ef3b102ca76b16638c0c0ebdfb09efb99a119dfa18316d39c4cb71b9984d168); /* line */ \n        c_0x8b47d469(0xbf74f36d3be79cc5f4e23f6e77b1f1cd0b75e545feb7a0bfadb0711e39a6e5a0); /* statement */ \nreturn buffer.setExtraData(_globalMetadata);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function getGlobalMetadata() public view returns (bytes27) {c_0x8b47d469(0xc20b27683799b1f340f9671a6d1d0aa4a3018b87f8a9ede5d4512d86e11012ea); /* function */ \n\nc_0x8b47d469(0x7aa96ce2c98f3ab07a773c23532f52999b230417d47e4e77e0ceb48d15b97237); /* line */ \n        c_0x8b47d469(0x506a0ddc4d9ceafd6baeeede4ee3983cd33f9daa46992fe0a180f75572fa54e0); /* statement */ \nreturn buffer.getExtraData();\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function length() public view returns (uint256) {c_0x8b47d469(0x4ca96f4b1482c7caf0533d7851b8bd8f41f8640f411b0264d7ae54b4608b556c); /* function */ \n\nc_0x8b47d469(0x2c4f98bf3dac8887aaaf574cbe790903afac76a40f0f350371f24716f385938f); /* line */ \n        c_0x8b47d469(0x11807c55a0d402c4c4579c3da51312d0f1bf6c0c839931aef62a7bb4f20aeb64); /* statement */ \nreturn uint256(buffer.getLength());\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function push(bytes32 _object) public onlyOwner {c_0x8b47d469(0xd5de9057c21afd6517ab6c57fa48cffc616da644603cbbb81c562cd09a97c285); /* function */ \n\nc_0x8b47d469(0x77ffb58739068c1c8bf77b98e768a9c3517417a4b1246fb81ca8849a44548075); /* line */ \n        c_0x8b47d469(0xa656f73a7bc7c231de6b59bd8410176e20df9c91df944a0ab1940d664ef3ff28); /* statement */ \nbuffer.push(_object);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function push(bytes32 _object, bytes27 _globalMetadata) public onlyOwner {c_0x8b47d469(0x55a8052d56453acb2c4243309e135669acbdf4b6d29ee7ca25be15ea1bcce9b2); /* function */ \n\nc_0x8b47d469(0x30c4cc45f93e3adf8bf0e598f8287442bf594a446f6533f9b9b6baf6617a8159); /* line */ \n        c_0x8b47d469(0x7525e480c95c2299c2e602f489c8eb78b6719d251945699de33a2878c3807016); /* statement */ \nbuffer.push(_object, _globalMetadata);\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function get(uint256 _index) public view returns (bytes32) {c_0x8b47d469(0xd48214588275a7e027062dbe4528dbaf03b79c675166e89c9f04de964fa57b1c); /* function */ \n\nc_0x8b47d469(0xd4d8f3162c5d9351f80dd18ad3d7622f91becd31627e18bdf8580d850cf5b55d); /* line */ \n        c_0x8b47d469(0x4032eaa84bcf352fb4bc6bbc9a07b3b70e3d09239416d272e6bc9e1f523cf417); /* statement */ \nreturn buffer.get(uint40(_index));\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function deleteElementsAfterInclusive(uint256 _index) public onlyOwner {c_0x8b47d469(0x994545d0022bd7e127618d717d1d1c968638d0746b37db6c3e3211b23cb6c4bc); /* function */ \n\nc_0x8b47d469(0x6371ee03969903a7fb3a761085fba974c2ad4f1fb302492c942a2255ede96b43); /* line */ \n        c_0x8b47d469(0x87674c4b5d913ec8c1820ac27aad87f426b2cbeaad61e07fe70d1a47274c0d21); /* statement */ \nbuffer.deleteElementsAfterInclusive(uint40(_index));\n    }\n\n    /**\n     * @inheritdoc IChainStorageContainer\n     */\n    // slither-disable-next-line external-function\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)\n        public\n        onlyOwner\n    {c_0x8b47d469(0xef612e6c9417345df07aecdc433045d20f61e25527433a340278b9a340410391); /* function */ \n\nc_0x8b47d469(0x128b7132891ea154b32b28c9745bba8b7232e6e36e4a065698d2b7c0756e2958); /* line */ \n        c_0x8b47d469(0x06a45a0ab6bca9575e77368e96ae6d84f4871c617cff56e6ad078a9b931b603a); /* statement */ \nbuffer.deleteElementsAfterInclusive(uint40(_index), _globalMetadata);\n    }\n}\n"
    },
    "contracts/libraries/utils/Lib_Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xac40bf5a(bytes32 c__0xac40bf5a) pure {}\n\n\n/**\n * @title Lib_Buffer\n * @dev This library implements a bytes32 storage array with some additional gas-optimized\n * functionality. In particular, it encodes its length as a uint40, and tightly packs this with an\n * overwritable \"extra data\" field so we can store more information with a single SSTORE.\n */\nlibrary Lib_Buffer {\nfunction c_0xd94285fa(bytes32 c__0xd94285fa) public pure {}\n\n    /*************\n     * Libraries *\n     *************/\n\n    using Lib_Buffer for Buffer;\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Buffer {\n        bytes32 context;\n        mapping(uint256 => bytes32) buf;\n    }\n\n    struct BufferContext {\n        // Stores the length of the array. Uint40 is way more elements than we'll ever reasonably\n        // need in an array and we get an extra 27 bytes of extra data to play with.\n        uint40 length;\n        // Arbitrary extra data that can be modified whenever the length is updated. Useful for\n        // squeezing out some gas optimizations.\n        bytes27 extraData;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Pushes a single element to the buffer.\n     * @param _self Buffer to access.\n     * @param _value Value to push to the buffer.\n     * @param _extraData Global extra data.\n     */\n    function push(\n        Buffer storage _self,\n        bytes32 _value,\n        bytes27 _extraData\n    ) internal {c_0xd94285fa(0x82e8cb05c64b507a1c68f7673ae30e039d90c26dc086e9ef5f134627d2e451b6); /* function */ \n\nc_0xd94285fa(0xe232f3bc7b50fec067fba3985dd5762a349e35afde044fd724b05615202b8661); /* line */ \n        c_0xd94285fa(0x4d9de3d55e16498f6dc7d6a5cf10f7e823989f8daf9c20b49e66a4f0d1264c6e); /* statement */ \nBufferContext memory ctx = _self.getContext();\n\nc_0xd94285fa(0x80222f7e2077b7b3b58e8654df15a88c07526f3d28ffa66bbf10e6081070641c); /* line */ \n        c_0xd94285fa(0x9ce24f2e809ee148945ecd92876c98074a5dce024c8a59b21a12fb280e361b3e); /* statement */ \n_self.buf[ctx.length] = _value;\n\n        // Bump the global index and insert our extra data, then save the context.\nc_0xd94285fa(0x936c7050cdafc31529c58109afed8e9581de3a3ceb489f5e2348723d7cd0c068); /* line */ \n        ctx.length++;\nc_0xd94285fa(0x57b4f7473ca20dce69eba1dc6b8e8815ba34ab00c2a0ffdd4579a8609c54d135); /* line */ \n        c_0xd94285fa(0x6f04518e8b035a5c9ab0865f96bcfb6143380f9668c82e1d5ca3dc759378cece); /* statement */ \nctx.extraData = _extraData;\nc_0xd94285fa(0xd822f46c50ebe62b09c3f88616521a99564fffbf5773666bfc9382692f585996); /* line */ \n        c_0xd94285fa(0x5d49deb2a61f55900e9e6bd02635373513549fa0e46cdba668d196e1c60d0f52); /* statement */ \n_self.setContext(ctx);\n    }\n\n    /**\n     * Pushes a single element to the buffer.\n     * @param _self Buffer to access.\n     * @param _value Value to push to the buffer.\n     */\n    function push(Buffer storage _self, bytes32 _value) internal {c_0xd94285fa(0x687e1ffc29a88d0c6722e840a717c244a9a3a4eec64d71dfa6e5c74ec45acb89); /* function */ \n\nc_0xd94285fa(0x29db939e17a20652fa357c412de8d3e7e664c8f3ea100b5a2449ec204c39eecc); /* line */ \n        c_0xd94285fa(0x87769fb76a3b2a4c8a607fee1a0b486b9dcbeeff3fcb4e8b61445b5dacfb4e73); /* statement */ \nBufferContext memory ctx = _self.getContext();\n\nc_0xd94285fa(0x66a1e9a35251b4ec2e2749ed3ac9f5c55080c664e439bf4d504d3fd5ee600c2b); /* line */ \n        c_0xd94285fa(0xbcf625314d7c8779d66f236baa0b22598ecaa65504d23e44e96651d1262b39ba); /* statement */ \n_self.push(_value, ctx.extraData);\n    }\n\n    /**\n     * Retrieves an element from the buffer.\n     * @param _self Buffer to access.\n     * @param _index Element index to retrieve.\n     * @return Value of the element at the given index.\n     */\n    function get(Buffer storage _self, uint256 _index) internal view returns (bytes32) {c_0xd94285fa(0xc69ac4b97a9ca4742b7e8e858725e7626168c32fa35fd545d2c781812fe56ddd); /* function */ \n\nc_0xd94285fa(0x9ee6ea05326988c84656357b6e0202850c4041e4ae6b9d77f196a475d7841ef1); /* line */ \n        c_0xd94285fa(0xc56ed27c641f6b9b9e70d5c4e6a9d548362f69eb13dc4fb29da7002c5e56ce92); /* statement */ \nBufferContext memory ctx = _self.getContext();\n\nc_0xd94285fa(0x84f4bacbf5b8bae02e6dc48be97f18286da2169380c27e46e7e1402ff1d07171); /* line */ \n        c_0xd94285fa(0xbef550c18607533236ad98d3fb8123f5f6db451c703cb693d855cd98c9d6a813); /* requirePre */ \nc_0xd94285fa(0x66aba51817e2bc9632055054bd69650fb12303d3a7e431d5e00310ec35cdb87d); /* statement */ \nrequire(_index < ctx.length, \"Index out of bounds.\");c_0xd94285fa(0xe5fa57791964d72b3e77cbec5f832003f4a8393daf3ae414b369e5c4501fb208); /* requirePost */ \n\n\nc_0xd94285fa(0x4afab88f4cdd32531454e297243e102c0c59a5b4725f0214de87055756cbcfcd); /* line */ \n        c_0xd94285fa(0x24bdf66283f682a3deaca79b9e1264d50011ce53cd07ed5ea25862acc837c05d); /* statement */ \nreturn _self.buf[_index];\n    }\n\n    /**\n     * Deletes all elements after (and including) a given index.\n     * @param _self Buffer to access.\n     * @param _index Index of the element to delete from (inclusive).\n     * @param _extraData Optional global extra data.\n     */\n    function deleteElementsAfterInclusive(\n        Buffer storage _self,\n        uint40 _index,\n        bytes27 _extraData\n    ) internal {c_0xd94285fa(0x48fbc6e894b69c625f5c03040dcf03bf138a2aa9d195a7595c20b3c1a171bf14); /* function */ \n\nc_0xd94285fa(0xd1077b7716182496f3d06137c07e06cf7f314c322ecf6010522d730ce90b3ac4); /* line */ \n        c_0xd94285fa(0xa484190c753097e3a5c775c504fd242211f7324e1d89d7865e2e5ff72f6f1c9f); /* statement */ \nBufferContext memory ctx = _self.getContext();\n\nc_0xd94285fa(0x195b0f722c9334d9c75ca40d4332f860208a630630b67732eb853dca16bf4634); /* line */ \n        c_0xd94285fa(0xa8552d687f2375a26cbd95844dd2bfb9ec0d88b33270ee3a634eac6c3769761e); /* requirePre */ \nc_0xd94285fa(0x29ab2caf30d5f120854a220be51d854e57e2b2de2a7687e17b96c1ddcc36bbb1); /* statement */ \nrequire(_index < ctx.length, \"Index out of bounds.\");c_0xd94285fa(0x5e9850211e066e1d8692f7a6d171fc757b84085029f7c56582fd2139c741b231); /* requirePost */ \n\n\n        // Set our length and extra data, save the context.\nc_0xd94285fa(0xae77b054873c52daca244d530ea630b6d20cfb4cef66101dd866680afdadbaf6); /* line */ \n        c_0xd94285fa(0x72c36a0ceed94d1d5b2fa0de75aee40a19365f99458342c8839b847b10bf9186); /* statement */ \nctx.length = _index;\nc_0xd94285fa(0x88b307d4d315799d8121008acdb4ca7414076f4553df840c8e6f17019fab37c4); /* line */ \n        c_0xd94285fa(0x37c95565e2f55051b7391894029a861c74f11e545e45ca843ba7be4f1e5d60fa); /* statement */ \nctx.extraData = _extraData;\nc_0xd94285fa(0x94def890aa4fa5499b5cb7935a8fd9a5f0199ef60aec9151e3f4744a444f3c48); /* line */ \n        c_0xd94285fa(0x0f339bbe2752fda0ad82bd993528be1f716063611003178e60066a95a9b6dc98); /* statement */ \n_self.setContext(ctx);\n    }\n\n    /**\n     * Deletes all elements after (and including) a given index.\n     * @param _self Buffer to access.\n     * @param _index Index of the element to delete from (inclusive).\n     */\n    function deleteElementsAfterInclusive(Buffer storage _self, uint40 _index) internal {c_0xd94285fa(0x9720a11ead034ffe844ae09d174717e29beb654157e20ef59632701987ac0567); /* function */ \n\nc_0xd94285fa(0x2411a54807f2288c1687694ad72fa848337466b81a7d5bd480761ebf2269578c); /* line */ \n        c_0xd94285fa(0xf367dece873a7b1e64564d1119e2563e1cc0019c964b27aafb21ffd309cb97fb); /* statement */ \nBufferContext memory ctx = _self.getContext();\nc_0xd94285fa(0xcf603d3121b7c41886658fa340cd6d037877cfee4f0a7d98ce520bd6b010c6f1); /* line */ \n        c_0xd94285fa(0xea429471e258514e35ca47467a2f97ae68a788b4bf48bbbc091dec13a7bb53d0); /* statement */ \n_self.deleteElementsAfterInclusive(_index, ctx.extraData);\n    }\n\n    /**\n     * Retrieves the current global index.\n     * @param _self Buffer to access.\n     * @return Current global index.\n     */\n    function getLength(Buffer storage _self) internal view returns (uint40) {c_0xd94285fa(0xcd2b4a560adafe293fabbe99ee2a92a4067c04748c9d0f7597dc6db80823e7cb); /* function */ \n\nc_0xd94285fa(0x5f9f6c2ba30a157e6bf51f3fe6079380361b0f727f7242bd10b8a1c85c4b3e17); /* line */ \n        c_0xd94285fa(0xd2d8da347f7414f250aca13f0c4cbd8745ecbcd38bde6f849819557fa32e2279); /* statement */ \nBufferContext memory ctx = _self.getContext();\nc_0xd94285fa(0x88e889e2b07bad9fd499a7cfe62ed70a3f0627796de9fa156d05744947c0113a); /* line */ \n        c_0xd94285fa(0x6abd6af63b51c6fa3361956a63c15077587b3cb4b05d559adb6585b19baf660e); /* statement */ \nreturn ctx.length;\n    }\n\n    /**\n     * Changes current global extra data.\n     * @param _self Buffer to access.\n     * @param _extraData New global extra data.\n     */\n    function setExtraData(Buffer storage _self, bytes27 _extraData) internal {c_0xd94285fa(0xb8f064534ad39fc3ee4983545a01747b7182c65569d3155eb3a7bfcef0a6d8a8); /* function */ \n\nc_0xd94285fa(0x8e72b50f777271bd9315a998cab2f0158babb84b5a3657e0ff295ef77eb0f521); /* line */ \n        c_0xd94285fa(0x18962af9eb7a046fe8e5a8b2367c1a4755ca8bab76a22e659b3e263e5284f473); /* statement */ \nBufferContext memory ctx = _self.getContext();\nc_0xd94285fa(0x026010b8bc479521e5eb56ad021c18771da7963f77b45004dd4e0493c1ee681e); /* line */ \n        c_0xd94285fa(0x78ebfb298032843ebd679d0961d6c4e954e8e42b85d1c03cd519988be222fa6d); /* statement */ \nctx.extraData = _extraData;\nc_0xd94285fa(0xf7690eacd0168380ef42f72f3bc387087cd31a613992a1583a5564ea73441a57); /* line */ \n        c_0xd94285fa(0x55fa05d7ce7ae60e8d3b5604c7f60d1a7576da9bd49fc06eb6749c9fbf54e28c); /* statement */ \n_self.setContext(ctx);\n    }\n\n    /**\n     * Retrieves the current global extra data.\n     * @param _self Buffer to access.\n     * @return Current global extra data.\n     */\n    function getExtraData(Buffer storage _self) internal view returns (bytes27) {c_0xd94285fa(0x3bdfe5dd22fbc9c24cdb526eb38e2b3e420b7aac5d063e6394c7ff8fc1b74b4b); /* function */ \n\nc_0xd94285fa(0x9a73f133db583cd3c5620de6317a9b7fbbb9c5533a25dfe2eeb302e5e017025d); /* line */ \n        c_0xd94285fa(0x473cccccfb9208e7332fd07f4f78e14dccac6ae296e12e24f6358f89749b96fc); /* statement */ \nBufferContext memory ctx = _self.getContext();\nc_0xd94285fa(0xc0324d5d72599297e736f8fab844e0b28788fef69cdb78706ea60436169592db); /* line */ \n        c_0xd94285fa(0x2d23f4a8df91b6444f909547d95017da7e63a38f8f11bcf678645ccb5b515771); /* statement */ \nreturn ctx.extraData;\n    }\n\n    /**\n     * Sets the current buffer context.\n     * @param _self Buffer to access.\n     * @param _ctx Current buffer context.\n     */\n    function setContext(Buffer storage _self, BufferContext memory _ctx) internal {c_0xd94285fa(0x06efc099902521c675a50fb022d4e8e1d690eae56b48d0c55a088aa4f3c14be2); /* function */ \n\nc_0xd94285fa(0x35c8252840295dd8357916367321db2dfef97d30a5f126e65fb5324090c5b5b5); /* line */ \n        c_0xd94285fa(0x348121c732da402266f31ccf1976590cc944b051fac65694033c5f57c456d3db); /* statement */ \nbytes32 context;\nc_0xd94285fa(0x9859bb874983436eaa5840eebca44db6803428b0b4edee69107562c2cf0ad114); /* line */ \n        c_0xd94285fa(0x0a966f05dc26ea798ae2c08b548b5e2181e8b83adfd75dc50f386ffd73892483); /* statement */ \nuint40 length = _ctx.length;\nc_0xd94285fa(0x708e9dac3c9565c1b62a19ba83ba024bbf51dc869391d8e278f85b3c0444f8cf); /* line */ \n        c_0xd94285fa(0x4c83318cdc28d0305a7606cb843f5c5827f8c7f32bdc58831fabc3a8d7f06eda); /* statement */ \nbytes27 extraData = _ctx.extraData;\nc_0xd94285fa(0x4083501b478bf71c853d26d5eeff253911dcea14700307a63444de25c2984c94); /* line */ \n        assembly {\n            context := length\n            context := or(context, extraData)\n        }\n\nc_0xd94285fa(0x3f2225b09255bda1d24e6eaa4528458c87f2a506a3045a5971219f8962f38ba8); /* line */ \n        c_0xd94285fa(0x4389b0509ae44bf15bf989e38f8f20973949a571aee67b0009c4059064ea6c1b); /* statement */ \nif (_self.context != context) {c_0xd94285fa(0x1661278d34f1f0d69991ada0718d1a8f4aeb9c4f862d741168c5d17df1f71ffe); /* branch */ \n\nc_0xd94285fa(0xabe3abe2751292222b8a36352a7aad4dbc0bd6534069713e5268ed6b3ba823a9); /* line */ \n            c_0xd94285fa(0x4068c14c9ec2a7f1d4957d5fa8fd9eece6d215a774636fee61ac3b49e34c292e); /* statement */ \n_self.context = context;\n        }else { c_0xd94285fa(0x3e3459729b48d4d48497bd28646dbcce8cd8f2c64ee71adc6f5c2b8f590908cc); /* branch */ \n}\n    }\n\n    /**\n     * Retrieves the current buffer context.\n     * @param _self Buffer to access.\n     * @return Current buffer context.\n     */\n    function getContext(Buffer storage _self) internal view returns (BufferContext memory) {c_0xd94285fa(0xb08a4267e98c86e8e835676154055fb900cd124a68bf31b9eb5880c7c94c9889); /* function */ \n\nc_0xd94285fa(0x7f2dd34f7ebfde237430ef17ee4a20339a73e3be8604cca421de60c3f0b307c3); /* line */ \n        c_0xd94285fa(0x38e71734bd9b12bc272e2f73f3460c039fecb43537ac48c6f1e1f548a1d24b92); /* statement */ \nbytes32 context = _self.context;\nc_0xd94285fa(0xdefed56a9912260a047e97a9bcb2e365e95956dac4db7c4b3b911bfae3fdb67a); /* line */ \n        c_0xd94285fa(0x26df0972e959d4b85b012b9623d8f82d9a7645d0540e015787ba1aedfdf16e57); /* statement */ \nuint40 length;\nc_0xd94285fa(0x0db46f2921f9370112b2dfb4ade6ec080f1eb600947d5df3b79dede00ef52533); /* line */ \n        c_0xd94285fa(0x2797ef18f6d9b5db46d5674843ec859df8b4e8b97e1a1cc4e0070c40c4c3b88e); /* statement */ \nbytes27 extraData;\nc_0xd94285fa(0x465d6bb5fd0e27ad239ddf8ada182127065795ad48935bfc4bd9f48b473f7bd9); /* line */ \n        assembly {\n            length := and(\n                context,\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            extraData := and(\n                context,\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000\n            )\n        }\n\nc_0xd94285fa(0x525f419d992b81bd60dbcecd6691cc1f60b277b0f58d4df71e2f9bcfa1eabc67); /* line */ \n        c_0xd94285fa(0x45c454e867492892427be691126d6162394f4bfea7f670c72aeaab8b2ce75989); /* statement */ \nreturn BufferContext({ length: length, extraData: extraData });\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_Buffer } from \"../../libraries/utils/Lib_Buffer.sol\";\n\n/**\n * @title TestLib_Buffer\n */\ncontract TestLib_Buffer {\n    using Lib_Buffer for Lib_Buffer.Buffer;\n    using Lib_Buffer for Lib_Buffer.BufferContext;\n\n    Lib_Buffer.Buffer internal buf;\n\n    function push(bytes32 _value, bytes27 _extraData) public {\n        buf.push(_value, _extraData);\n    }\n\n    function push(bytes32 _value) public {\n        buf.push(_value);\n    }\n\n    function get(uint256 _index) public view returns (bytes32) {\n        return buf.get(_index);\n    }\n\n    function deleteElementsAfterInclusive(uint40 _index) public {\n        return buf.deleteElementsAfterInclusive(_index);\n    }\n\n    function deleteElementsAfterInclusive(uint40 _index, bytes27 _extraData) public {\n        return buf.deleteElementsAfterInclusive(_index, _extraData);\n    }\n\n    function getLength() public view returns (uint40) {\n        return buf.getLength();\n    }\n\n    function setExtraData(bytes27 _extraData) public {\n        return buf.setExtraData(_extraData);\n    }\n\n    function getExtraData() public view returns (bytes27) {\n        return buf.getExtraData();\n    }\n\n    function getContext() public view returns (Lib_Buffer.BufferContext memory) {\n        return buf.getContext();\n    }\n\n    function setContext(uint40 _index, bytes27 _extraData) public {\n        Lib_Buffer.BufferContext memory _ctx = Lib_Buffer.BufferContext({\n            length: _index,\n            extraData: _extraData\n        });\n        return buf.setContext(_ctx);\n    }\n}\n"
    },
    "contracts/L1/rollup/CanonicalTransactionChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x5e146189(bytes32 c__0x5e146189) pure {}\n\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { ICanonicalTransactionChain } from \"./ICanonicalTransactionChain.sol\";\nimport { IChainStorageContainer } from \"./IChainStorageContainer.sol\";\n\n/**\n * @title CanonicalTransactionChain\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the\n * Sequencer will eventually append it to the rollup state.\n *\n */\ncontract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {\nfunction c_0xeec32677(bytes32 c__0xeec32677) public pure {}\n\n    /*************\n     * Constants *\n     *************/\n\n    // L2 tx gas-related\n    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;\n    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;\n\n    // The approximate cost of calling the enqueue function\n    uint256 public enqueueGasCost;\n    // The ratio of the cost of L1 gas to the cost of L2 gas\n    uint256 public l2GasDiscountDivisor;\n    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.\n    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.\n    // See comments in enqueue() for further detail.\n    uint256 public enqueueL2GasPrepaid;\n\n    // Encoding-related (all in bytes)\n    uint256 internal constant BATCH_CONTEXT_SIZE = 16;\n    // slither-disable-next-line unused-state\n    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;\n    uint256 internal constant BATCH_CONTEXT_START_POS = 15;\n    // slither-disable-next-line unused-state\n    uint256 internal constant TX_DATA_HEADER_SIZE = 3;\n    // slither-disable-next-line unused-state\n    uint256 internal constant BYTES_TILL_TX_DATA = 65;\n\n    /*************\n     * Variables *\n     *************/\n\n    uint256 public maxTransactionGasLimit;\n\n    /***************\n     * Queue State *\n     ***************/\n\n    uint40 private _nextQueueIndex; // index of the first queue element not yet included\n    Lib_OVMCodec.QueueElement[] queueElements;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _libAddressManager,\n        uint256 _maxTransactionGasLimit,\n        uint256 _l2GasDiscountDivisor,\n        uint256 _enqueueGasCost\n    ) Lib_AddressResolver(_libAddressManager) {c_0xeec32677(0x26f4039ba4f68f8039a0ddf537748a521c8bb2f69b5246ec4b8052f86bfc0e53); /* function */ \n\nc_0xeec32677(0xf6e9e0fa0213d65adef1857950489f4e63262de62fe9b9b7c88c7d01eee3689e); /* line */ \n        c_0xeec32677(0x12ca49ae7f4729b78581928a34e1be40c0e5c8335be5db7b8381ad6766dff7ce); /* statement */ \nmaxTransactionGasLimit = _maxTransactionGasLimit;\nc_0xeec32677(0xd1c517c32872905ca2f842f66845d92073da0e7d3ee8c416bba6c332db82ce3a); /* line */ \n        c_0xeec32677(0x5ee9333f711f5177a35803298a3c0f5dedffe199b076f6eefdf878d7bbb7b752); /* statement */ \nl2GasDiscountDivisor = _l2GasDiscountDivisor;\nc_0xeec32677(0xa819dda7cfc6bfc26d4d1a8a4c98ee42e73de35f59dd8de9671dfc36f4378dc8); /* line */ \n        c_0xeec32677(0x401f484b95ae9a89a9fb972df3b4c46b870b3ac6ec2c72764c906349502d053f); /* statement */ \nenqueueGasCost = _enqueueGasCost;\nc_0xeec32677(0xa9185c8024df2aa1d12d1921fbdd771c3dd0e2c9070b5d0aa9ad0095d720479e); /* line */ \n        c_0xeec32677(0xa7bbcea2f157fb44480337c23489eb31dc3bfd5e79863ff0ca09d7a93ca88972); /* statement */ \nenqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Modifier to enforce that, if configured, only the Burn Admin may\n     * successfully call a method.\n     */\n    modifier onlyBurnAdmin() {c_0xeec32677(0x69a7dfb3d9de82ed8a85d4efa61edb0b624fb8018084a5441aa667121e51c2dc); /* function */ \n\nc_0xeec32677(0x3b0616ec1812d2f02c9533d24b08fdc7de06837d9f14a36d1ff86fde9e3e1a5b); /* line */ \n        c_0xeec32677(0x4c52a9613618e972bfa5afb34183afe3b76c3f673b41b2c6145df0238958b5cc); /* requirePre */ \nc_0xeec32677(0x1f387306aef422acc8dd29f7a62a74d35b8f9c5ce41e4889c3d94a3bd674d7f9); /* statement */ \nrequire(msg.sender == libAddressManager.owner(), \"Only callable by the Burn Admin.\");c_0xeec32677(0x9e42e2e29ea9b2f1ab16a59c36740bc6bdbe908c9191a61757a12cec0c2e035f); /* requirePost */ \n\nc_0xeec32677(0x7338be4d07c720d4f7b4f2e1212b8540e74daffa0f6dbf10f279f2251f72f412); /* line */ \n        _;\n    }\n\n    /*******************************\n     * Authorized Setter Functions *\n     *******************************/\n\n    /**\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\n     */\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)\n        external\n        onlyBurnAdmin\n    {c_0xeec32677(0xf22ecf03a201064610f78f50a4cefdf1ab41e2f25645f326e9769b1b7e1f4b08); /* function */ \n\nc_0xeec32677(0x98a99023a928b67fc7a4206698b47841d631f564989cce68b84d7312671a3aab); /* line */ \n        c_0xeec32677(0xc93f631509bd5148c2b2b26924c76c05613ff2bef4b682e7d712eccb88ee4adf); /* statement */ \nenqueueGasCost = _enqueueGasCost;\nc_0xeec32677(0xfeb50c0bf7fcd918edb9704344ddc9ba1b79b2346dc56102631ed9c53cb04b5d); /* line */ \n        c_0xeec32677(0x92e447a6cd954aa8a8a3d03d055b76e0a3e41d00a6bf6d1a1bbb210ef8c4d19e); /* statement */ \nl2GasDiscountDivisor = _l2GasDiscountDivisor;\n        // See the comment in enqueue() for the rationale behind this formula.\nc_0xeec32677(0x79191316b11a9f0aae93332d31daddd494d9d925c518702ece90a387ad637b0b); /* line */ \n        c_0xeec32677(0xfc2d460508a785d4bf8147e2c4a2b45571f177ebf5a64a85b67fc30931aa7bc8); /* statement */ \nenqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\n\nc_0xeec32677(0xb63773c7152d5f36b47890dc368ee56a52db646f657d5a669bfca29212472884); /* line */ \n        c_0xeec32677(0x8de616220b0bb9350875108226da56c6fb37ae7f298b7ed04a036705d7b5c702); /* statement */ \nemit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Accesses the batch storage container.\n     * @return Reference to the batch storage container.\n     */\n    function batches() public view returns (IChainStorageContainer) {c_0xeec32677(0x4a9e441db67932384fb3dccd7534d713ba4ab4ce3fc46d41a0ebe36b778f016b); /* function */ \n\nc_0xeec32677(0x54ca02cdf6490294b7076b367924e9037484073655fc1e3eb43d195aab142ac4); /* line */ \n        c_0xeec32677(0xf03ced03e62e4887179d6b9bfbabb3226a9dfe14429106fe02d23effa81c68f9); /* statement */ \nreturn IChainStorageContainer(resolve(\"ChainStorageContainer-CTC-batches\"));\n    }\n\n    /**\n     * Retrieves the total number of elements submitted.\n     * @return _totalElements Total submitted elements.\n     */\n    function getTotalElements() public view returns (uint256 _totalElements) {c_0xeec32677(0x70c350a1c606bb35f5615f278891794ab960611cd8317b67c393b8f396637abb); /* function */ \n\nc_0xeec32677(0xa2c2b2c16aeb7c36d012991d9fe1240e95d46055206b724bc968c0bbf1a620da); /* line */ \n        c_0xeec32677(0x2f92d294f95d53c6410b4233d5b1ba85f73f884fb7affd8eab7e5e5f8ad3ebbe); /* statement */ \n(uint40 totalElements, , , ) = _getBatchExtraData();\nc_0xeec32677(0xae209e11b1a53ad2a3cd900903cbbb8108b4f2f12fe055042fafa2e9685c3031); /* line */ \n        c_0xeec32677(0x42839df5748fa2eb99871d0fa5e12ed98fb1b76e05a3eb2e20f4fe9218666fe6); /* statement */ \nreturn uint256(totalElements);\n    }\n\n    /**\n     * Retrieves the total number of batches submitted.\n     * @return _totalBatches Total submitted batches.\n     */\n    // slither-disable-next-line external-function\n    function getTotalBatches() public view returns (uint256 _totalBatches) {c_0xeec32677(0xda5b2f1e7d20640fdd8c3abe570e27788b412a4bc0028aadad606f4706ef6171); /* function */ \n\nc_0xeec32677(0x498dac850f30fca9596467c7857d9d462810253a42a80cd1d578b8ec370078b8); /* line */ \n        c_0xeec32677(0x90fd3259bd4c1aa9f2c1bf5fe81f3612edd3f130869856cbf1cd6be0d364e5a5); /* statement */ \nreturn batches().length();\n    }\n\n    /**\n     * Returns the index of the next element to be enqueued.\n     * @return Index for the next queue element.\n     */\n    // slither-disable-next-line external-function\n    function getNextQueueIndex() public view returns (uint40) {c_0xeec32677(0x4ba38eaebd304eb13a43544d1f7190823c1ddd7652342e97305b41f9bad02364); /* function */ \n\nc_0xeec32677(0xe94fc325f31a917a992ecb2e0944273dfd5f232a6093ab1b497b05e26733fe2b); /* line */ \n        c_0xeec32677(0x3ecea2393991b275b690934541713dbb09831da1bf0760adcc6205e5c5a80a94); /* statement */ \nreturn _nextQueueIndex;\n    }\n\n    /**\n     * Returns the timestamp of the last transaction.\n     * @return Timestamp for the last transaction.\n     */\n    // slither-disable-next-line external-function\n    function getLastTimestamp() public view returns (uint40) {c_0xeec32677(0xa3bf9b731a66bb20cabd80859b380226932bf2ad63e3a3d6d5d43a6f2143e801); /* function */ \n\nc_0xeec32677(0x00c99aeb830ed965800ee13bd3bf0a67d804544108d0ec07115834f7cb5b1cf3); /* line */ \n        c_0xeec32677(0x84050c3d49e6c3c13da8f77c149e2257c2b8f412f262dd7056895d538065815c); /* statement */ \n(, , uint40 lastTimestamp, ) = _getBatchExtraData();\nc_0xeec32677(0x107f2e8a6c2689edb6e6f2d54845cb004205bb58d3d596168f85c0a6e5b8e098); /* line */ \n        c_0xeec32677(0xab6ed98b459d73d753a53a5729d33d2a5113c8ad080052370454802ddd59fefd); /* statement */ \nreturn lastTimestamp;\n    }\n\n    /**\n     * Returns the blocknumber of the last transaction.\n     * @return Blocknumber for the last transaction.\n     */\n    // slither-disable-next-line external-function\n    function getLastBlockNumber() public view returns (uint40) {c_0xeec32677(0xa99d08869459bac4589f486560c78249ccd48982dd6c98dfd78573106b7e93ae); /* function */ \n\nc_0xeec32677(0xb903b2be1774a597a9943d8d8e3df3797f5719519d1b5ca92da789640ac8173c); /* line */ \n        c_0xeec32677(0x129142ee0a758b9bbe536610b2b8f469fa5016b84a2527f5452f3be591d7bf7f); /* statement */ \n(, , , uint40 lastBlockNumber) = _getBatchExtraData();\nc_0xeec32677(0xe3d149fde325be82d4ff4c42872c34159f7eb443d610267fdb00b102a1a608d3); /* line */ \n        c_0xeec32677(0x055965b6d3d61a9e57005845877c77a789ba478664bba31ff8964d48aac0a05c); /* statement */ \nreturn lastBlockNumber;\n    }\n\n    /**\n     * Gets the queue element at a particular index.\n     * @param _index Index of the queue element to access.\n     * @return _element Queue element at the given index.\n     */\n    // slither-disable-next-line external-function\n    function getQueueElement(uint256 _index)\n        public\n        view\n        returns (Lib_OVMCodec.QueueElement memory _element)\n    {c_0xeec32677(0x935855f87e60877c2036984f8b2535b0e8df118863b746c3304afaac9b4d8d30); /* function */ \n\nc_0xeec32677(0x8888bef87034ff56345cedf70472f5a83d755c6b5711a98bf57819f603eb1a27); /* line */ \n        c_0xeec32677(0x71bd2d988b93746765213539aed2bbacba410a0244cc7946e58f8dc603b018d9); /* statement */ \nreturn queueElements[_index];\n    }\n\n    /**\n     * Get the number of queue elements which have not yet been included.\n     * @return Number of pending queue elements.\n     */\n    // slither-disable-next-line external-function\n    function getNumPendingQueueElements() public view returns (uint40) {c_0xeec32677(0xf70f993dff66883646cf23b0af820d59658bf6454b5f6ae3db0e3c4b8caa554d); /* function */ \n\nc_0xeec32677(0xd5a3396a006d0d0eaf9e9388b1af6316087113a94b93cb3858bdaa79b209b456); /* line */ \n        c_0xeec32677(0x739156698d30205b4929c44ab0e51430b9ff72f0e32c696c700dd6ee465d70dc); /* statement */ \nreturn uint40(queueElements.length) - _nextQueueIndex;\n    }\n\n    /**\n     * Retrieves the length of the queue, including\n     * both pending and canonical transactions.\n     * @return Length of the queue.\n     */\n    // slither-disable-next-line external-function\n    function getQueueLength() public view returns (uint40) {c_0xeec32677(0xfe03193c0c445662ebf4775322dace9512a8201300a66eea86a7502c68aebb93); /* function */ \n\nc_0xeec32677(0x920cf893f8b0b911848c9e1a0ae4173808d196cd269302bd864300418ddfbfcc); /* line */ \n        c_0xeec32677(0x7b74b5a432394cf91aeffc57a43a649b633e4f5652ca24ef3233f24335a9db6d); /* statement */ \nreturn uint40(queueElements.length);\n    }\n\n    /**\n     * Adds a transaction to the queue.\n     * @param _target Target L2 contract to send the transaction to.\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\n     * @param _data Transaction data.\n     */\n    function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {c_0xeec32677(0x8ce8cedc60d68cdc5cb76839300590c6cb4709643df752e5feafd45363071faf); /* function */ \n\nc_0xeec32677(0xb4a444c5237e7931ff2911d727b6596f4d1e5e77281bdde4b31fe5d95b6d69d6); /* line */ \n        c_0xeec32677(0xc2804029b55c6ce5b701696fbd4a0f1256e9a4665543b4e5f74579f0568974fb); /* requirePre */ \nc_0xeec32677(0x8330059d41bc57e31bf6f2a3ba0bea391010a37d04ed43d342e7ffcf5dc90a62); /* statement */ \nrequire(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );c_0xeec32677(0xd565c6efb36d1e5dbf83dfebc6bc3dd02340ae43d4ae2f9ba114753efd04e18c); /* requirePost */ \n\n\nc_0xeec32677(0x86758e86919e4410402379715e07a7a0187002714a6b2b3db999b45e61ae56d3); /* line */ \n        c_0xeec32677(0x17510c2cb2c1b037aa0296f441a77ff659ae94cde87a19549a309fbc3f388a81); /* requirePre */ \nc_0xeec32677(0x79da0ba296313b5a8836ed178961a197d6f5ec0094257617b87f8a9a0f4313fe); /* statement */ \nrequire(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );c_0xeec32677(0x6dcaac5da42edbed4c1ca7faf200425f838260e3d9cac2c4634314f1bb0a7194); /* requirePost */ \n\n\nc_0xeec32677(0x5bb21dba02e18036cb5f82b236384a2921c0d2ccce3139b72c990be3981b4dc2); /* line */ \n        c_0xeec32677(0x845cb653f0508de5d06b0dddf30bd247f749325b8692fba9baea3976c1e8e434); /* requirePre */ \nc_0xeec32677(0x2d5848cc23aa295dbff922489bf8a59373a1c45f6fed287bf1cb29ffe1ee8468); /* statement */ \nrequire(_gasLimit >= MIN_ROLLUP_TX_GAS, \"Transaction gas limit too low to enqueue.\");c_0xeec32677(0x0098dc37a2cac2268b379785b1ea9174c5ed5274acbb75dfa0f1b1255813ac60); /* requirePost */ \n\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\nc_0xeec32677(0xa5db2681cd76319956e30723dee0e37302c3189fc949ea14a2786065eaee4550); /* line */ \n        c_0xeec32677(0x329db7c07daa099d4b2870c2670a3fc3bf35543d34f9112f15158343dc0b4d1b); /* statement */ \nif (_gasLimit > enqueueL2GasPrepaid) {c_0xeec32677(0xfb862882fc0abd2f682454166cce5652bf5c8e78ae3e43287dcdb647bfe33565); /* branch */ \n\nc_0xeec32677(0xbe2dd24bc31ff86dce07b244461533f3b6ae54e94d0b8a774a92da3a81f0ee1c); /* line */ \n            c_0xeec32677(0xdf9d107a09394b952f5569fe09f2f4ebbe9c44955acaaf28b5b34aaaa70916b0); /* statement */ \nuint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;\nc_0xeec32677(0x2864f84c67bcbcec946e23eb39a27f3f54bef992268b40fbe520efeca4896dec); /* line */ \n            c_0xeec32677(0x144d7d7cb570628dcfe6c4f8654e16e0e6d6ccd07740699177378deab82ccbfe); /* statement */ \nuint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\nc_0xeec32677(0xd005d141da3cba7876dd8c489cafa642509cab1fb81533b6995978242247b00b); /* line */ \n            c_0xeec32677(0xcc0b76bf5526d58528949f21b05caa4cb8b80f1de8409ba8ca309509562ef543); /* requirePre */ \nc_0xeec32677(0x16ef89d6932233000052bbed69d5be126fd22be695e2b39208d0a099a3cbc753); /* statement */ \nrequire(startingGas > gasToConsume, \"Insufficient gas for L2 rate limiting burn.\");c_0xeec32677(0x79d115062123138f18847b0defefe02965076d18863d9ba2f6c96b5a766df1df); /* requirePost */ \n\n\nc_0xeec32677(0x665338bc6be31254db885131f9fa0407f929a80fcdcbb6a002289a0e328a0c55); /* line */ \n            c_0xeec32677(0x790ecb7925ea7ba4130775f7d8ae8b6ee22c35cc7487f8740b60d3daad328978); /* statement */ \nuint256 i;\nc_0xeec32677(0x79812e6c2946f035f1bf23ca1d08b5213ea01d669bdcca0a9d8b6542893b57f5); /* line */ \n            c_0xeec32677(0x15c3e69d65ea7eb89d00e0d144cd628111bf60553ff14623c9c128437ec7fc47); /* statement */ \nwhile (startingGas - gasleft() < gasToConsume) {\nc_0xeec32677(0xcbda68e4b63217d3cc2c3369f2f68ba9d368a0577d67b4a472f17d0fea0f335f); /* line */ \n                i++;\n            }\n        }else { c_0xeec32677(0x1213f06f6d99980cc10f3c46b8ba720e91daf1fa8764dcab19dfa06fd33ed6ba); /* branch */ \n}\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\nc_0xeec32677(0x44af5775e96219a45a1cfeec4a3b6f8a7fb169ca136cb371e7485a9440eb615f); /* line */ \n        c_0xeec32677(0x6cc6db807a097381c8769c2caf8d2911b3724182dacf86f1e607b866dc60f9d7); /* statement */ \naddress sender;\nc_0xeec32677(0x31affbc2b5bd810fc6fc6e4209e13ee1df7b551ff1e9c31ae511d77ae1ec2169); /* line */ \n        c_0xeec32677(0x5e7f885da2205884786cc504032146d5ba8d03fe218ed35c5e5e2d14a22f4d5d); /* statement */ \nif (msg.sender == tx.origin) {c_0xeec32677(0x58beea01e0418df55a0226eda3f444e73e91e2301901c337211ba8b0a01c0311); /* branch */ \n\nc_0xeec32677(0xe73b8b8eb1dbfe077cf4aba1f0384a20ba8c05aa9d9e7f88949bc1d303df6874); /* line */ \n            c_0xeec32677(0x85edf3e6e5f65722f09cc38011cde3dd910d0c3d03fcd67b3601ff426b19daac); /* statement */ \nsender = msg.sender;\n        } else {c_0xeec32677(0x17d99e98fcab55266ffacf4252721cd28ffd9ee20174d5a437da20638b8e7c41); /* branch */ \n\nc_0xeec32677(0xff740452bfe12895604701afc1c976ad0f29a3d2035ce3e2c76931e0971eeaab); /* line */ \n            c_0xeec32677(0x0fe672f049119005c360acff60aaa5a365566b4339b6e98525ab6953ffa39012); /* statement */ \nsender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\nc_0xeec32677(0x17b5373a284aff086d727ae64ef9fa99653577e195d6b1fd30c1b14c3cbb878d); /* line */ \n        c_0xeec32677(0xa2061ddc401ccc2dae7fdb65291b19f7c86755c0b940b905e4fd6ee17531402f); /* statement */ \nbytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));\n\nc_0xeec32677(0x3f0cf7710fe7a7d8ae503d17cbdeb0382d2de3bcbb75dd176f82802afd76b59f); /* line */ \n        c_0xeec32677(0x497ef64bb686fc3c7f43fbb68556139b56cd99f4ba24dcf155fd05e987ea3d3b); /* statement */ \nqueueElements.push(\n            Lib_OVMCodec.QueueElement({\n                transactionHash: transactionHash,\n                timestamp: uint40(block.timestamp),\n                blockNumber: uint40(block.number)\n            })\n        );\nc_0xeec32677(0x424101015e412bee6b3e6f490e4a69e01705f2b9d88035c4e52d35c394cd07a9); /* line */ \n        c_0xeec32677(0xe460c43129f387b8afa093322acdf40b58bb553e96f496f173c825505e52701c); /* statement */ \nuint256 queueIndex = queueElements.length - 1;\nc_0xeec32677(0x078968cf39ffb6931fe1febdc1498d3df3b55d9d27edc4db82422387c3f623fd); /* line */ \n        c_0xeec32677(0xbb961e90ae36e5c6cf9299876c3dd559981858870db4ace09b3792565b3491e9); /* statement */ \nemit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);\n    }\n\n    /**\n     * Allows the sequencer to append a batch of transactions.\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\n     * .param _contexts Array of batch contexts.\n     * .param _transactionDataFields Array of raw transaction data.\n     */\n    function appendSequencerBatch() external {c_0xeec32677(0xda1046024da765a3a3ca573604642016d9a3d1fd69b4e4c4192da115b6039655); /* function */ \n\nc_0xeec32677(0x8f8b697070978392b5065e83b6b51a0e0d3bd8811c6852181278e10daa4690ad); /* line */ \n        c_0xeec32677(0x583620ee82078e5ca9305e5945b26027f587285153a9e2e4ce40ab940bac0d76); /* statement */ \nuint40 shouldStartAtElement;\nc_0xeec32677(0xb28b64499bd9ff43c606c413195fe71136be9b6a65e4e5564ea1c9aa0b3ed327); /* line */ \n        c_0xeec32677(0x321e81eb9ca1b6e0f2e73c2f723ddd463bd29901ded73e2f975f33dcac1cba71); /* statement */ \nuint24 totalElementsToAppend;\nc_0xeec32677(0x2f8e4ae0d82c7f6ae9927ba231491f0c82f53ba9d442e2e95cf8ba9d16e13a4b); /* line */ \n        c_0xeec32677(0x85dd6b11a4f3202f17382068ad9aa71431c28d9ad14203b3ba72288a254dd32f); /* statement */ \nuint24 numContexts;\nc_0xeec32677(0xcbd5c6cf2df15a94fb94e5cc8a9219fb3472d4d96e236f8a38e274e483a021f5); /* line */ \n        assembly {\n            shouldStartAtElement := shr(216, calldataload(4))\n            totalElementsToAppend := shr(232, calldataload(9))\n            numContexts := shr(232, calldataload(12))\n        }\n\nc_0xeec32677(0x531af308c911fe4c5dab0dc87567a0856a3622df45a717ad46ee290da83bd9b6); /* line */ \n        c_0xeec32677(0xa8e364b30fd148df9fbae187688c948d1deaba93d16bbacf8e0459441c6be368); /* requirePre */ \nc_0xeec32677(0xea0c2c5ccd507d56d2aa5d86d88f3a33e306b72440d499c7493384914b441c55); /* statement */ \nrequire(\n            shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );c_0xeec32677(0x1bfc86b8c83349a88730ba28fd50a904aa1553032f527adfde53d3bd2abb6d7c); /* requirePost */ \n\n\nc_0xeec32677(0xf5f1e3f387af0fb3c13fdc81d1d0e41078f118f292aaec78867d89e2208cf717); /* line */ \n        c_0xeec32677(0x13447ae6a98269ce81ba0f9e9c254f045ddaf207462b535e56394a8d69a50f4f); /* requirePre */ \nc_0xeec32677(0x8874101fe5214f6b01f491c472e621ee475c895a2bdd4849fef28f01601591aa); /* statement */ \nrequire(\n            msg.sender == resolve(\"OVM_Sequencer\"),\n            \"Function can only be called by the Sequencer.\"\n        );c_0xeec32677(0xc825f86f6e2a3db768aa5d279ba2523f60dba97b0824fba6354572fb493a0080); /* requirePost */ \n\n\nc_0xeec32677(0x889ff0ee749b1a5f5b30b87cad6d7daf315c0daadf974d9ced1b233fe16d8418); /* line */ \n        c_0xeec32677(0x7f6e581eef7ec1a3971f58249de694c35ca7e69eddba853d2176519d5559fc9e); /* statement */ \nuint40 nextTransactionPtr = uint40(\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\n        );\n\nc_0xeec32677(0xb5b0d9a97082ec1fdd29c9c59b95049a3a109d105e7335f5fb1473744db3f861); /* line */ \n        c_0xeec32677(0xeb65569e606cc3ee9632fc73eeec0af210f9f3b4a12f586e8d5101ed17663c1c); /* requirePre */ \nc_0xeec32677(0xaf1ba044e24268f2f177f2f46b94389f25e667aee46eceabb1ef4bcc0ce44e20); /* statement */ \nrequire(msg.data.length >= nextTransactionPtr, \"Not enough BatchContexts provided.\");c_0xeec32677(0xe561eb3f8d0670e025fac773b06aec1318d5d6b72df6301248e3e1ac5d4a469e); /* requirePost */ \n\n\n        // Counter for number of sequencer transactions appended so far.\nc_0xeec32677(0x06969027c01dd93db333f03ea98fe1eb26a1c0be7ed79d25c7e129abd68338ab); /* line */ \n        c_0xeec32677(0x31e43fbe1ee71cb585a5e89bacbd96997fc0fb05914e18f0a910dc9da559e444); /* statement */ \nuint32 numSequencerTransactions = 0;\n\n        // Cache the _nextQueueIndex storage variable to a temporary stack variable.\n        // This is safe as long as nothing reads or writes to the storage variable\n        // until it is updated by the temp variable.\nc_0xeec32677(0xa80995175af75d13247fd05774692a860ef29be296934bcce6e97942aee53d9f); /* line */ \n        c_0xeec32677(0xcc492fd7ee659e56d48a114867ec231da18727b0523fff59dceb8f0a052ee7a6); /* statement */ \nuint40 nextQueueIndex = _nextQueueIndex;\n\nc_0xeec32677(0x887bbaf64526ddff2815ab04d82fda5a6b01d98df62ea0c5b106be547ac969b0); /* line */ \n        c_0xeec32677(0x751ca277840d9744d055ee5a9ba5855de8e4bc269c66f90b073f56ba1832d08d); /* statement */ \nBatchContext memory curContext;\nc_0xeec32677(0x1ccb4eba7d69c385c09b9af73a35372adb79ae557154562ddc96f82cf6dd7269); /* line */ \n        c_0xeec32677(0xdb832425323b0c41669a73bbd739e3f9b1de8b7c2ad17a1868d439df0a99d3ac); /* statement */ \nfor (uint32 i = 0; i < numContexts; i++) {\nc_0xeec32677(0x086cb78dce55085b17dd46842524e6fa7c9af9d04e2485c49e9a514766be5ad9); /* line */ \n            c_0xeec32677(0xd8c8fb28e5f2996bcaee6dee78940bb97e66e46c1c542b2bd9f00f861925dc30); /* statement */ \nBatchContext memory nextContext = _getBatchContext(i);\n\n            // Now we can update our current context.\nc_0xeec32677(0xca252c3ffe4d1dc98cc8f0b25a4adc5ca4c621e5a917d0a927d714f04c49d6b7); /* line */ \n            c_0xeec32677(0x30405cd5e1f3046801ee2b3d15e85a90ea78be28a7e2bf461b513deaa0ec92a9); /* statement */ \ncurContext = nextContext;\n\n            // Process sequencer transactions first.\nc_0xeec32677(0x0d10941a10d13e3a07ac4c9ce19e9efee1ecfc08dc364c527a9e69d36c37c560); /* line */ \n            c_0xeec32677(0x6ff74f1493fdd029421808a9590ea5dc6e1962a4b2adb912b4feb8ebd6832ff8); /* statement */ \nnumSequencerTransactions += uint32(curContext.numSequencedTransactions);\n\n            // Now process any subsequent queue transactions.\nc_0xeec32677(0x5a73579b30e0b5e957b4eb52e614a68f09c9afbefc14c2ff8244a8597b00bb00); /* line */ \n            c_0xeec32677(0x1aaa93d3809314c8a58a624ff6f67e11711e18c3dd9cb128b06e0d070eb39be3); /* statement */ \nnextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\n        }\n\nc_0xeec32677(0xe337b9ea9a55db9cff2caeb5b6fb14590e04dbda5d02237e4fdd6e2ec5498ebd); /* line */ \n        c_0xeec32677(0x85a638fb4fad0d283924d8d3caa3d5cd029f733e2bf9de34e85b6804d15339a3); /* requirePre */ \nc_0xeec32677(0x4c4d84bb50ae696e60d37b8c0bff50438d42fb58d6dd327101249d2136446c57); /* statement */ \nrequire(\n            nextQueueIndex <= queueElements.length,\n            \"Attempted to append more elements than are available in the queue.\"\n        );c_0xeec32677(0x0f2802dedbc875e09e64e8d7d65397a7d0a26dc5dd991029e1553ec90e190900); /* requirePost */ \n\n\n        // Generate the required metadata that we need to append this batch\nc_0xeec32677(0x45b82425bf440c087ece65b626aea1bbfa313b39322b103dcfb43b394699ccbe); /* line */ \n        c_0xeec32677(0xb32c57c9c446a6bbe5b1f770b910adb41cadfea0b9dbb09bd8fabacde6cb64bd); /* statement */ \nuint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\nc_0xeec32677(0x106ee26ffe26ef33c912f5b795bbea7c5901f792276e26d72bc60c3f2f0972a8); /* line */ \n        c_0xeec32677(0xa1bb287fde92df0b8cc2d5d193be7788dd5fba833ba5cc516ba1dadb47426700); /* statement */ \nuint40 blockTimestamp;\nc_0xeec32677(0x4e79412c0afbbbbc6b573589ff9aaa5713780c06e379efa99fdd6a141b5ab99f); /* line */ \n        c_0xeec32677(0xd7d3c60a470a32c48f46b5150ac6cddb7a1d989234f4b82d975ca59be9a8e332); /* statement */ \nuint40 blockNumber;\nc_0xeec32677(0x3448b2f53eaf6c7c9bce75340ebc1da486aa1beb652a9d9156f3595797b92907); /* line */ \n        c_0xeec32677(0x1912cd338c5b80ead349ee3f87184dad2edf910031e9042803cc2109fba79c61); /* statement */ \nif (curContext.numSubsequentQueueTransactions == 0) {c_0xeec32677(0x31b499cb582d12abda0206a1088f574b41ef8ca08029c482c9826785a36ab8a5); /* branch */ \n\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\n            // the last context.\nc_0xeec32677(0x0ec2e8e09f36572c7d242d596d190bf6daf23b394b710e9c7aab46045ca69772); /* line */ \n            c_0xeec32677(0xcf718d4fb56fdf6154343923b9433a5afa849d909284ccc4a4b60d3a3715fca4); /* statement */ \nblockTimestamp = uint40(curContext.timestamp);\nc_0xeec32677(0xaa1583d536573d2f2982cac51c6677ad438abad3eae87f12e6bf90e79bf9a7d4); /* line */ \n            c_0xeec32677(0xd0cf2fceb61f0c6f9dae5531b2a2d557f90e1c0f83ad09d079401690fc0a2b0c); /* statement */ \nblockNumber = uint40(curContext.blockNumber);\n        } else {c_0xeec32677(0x68c1510dfff33952f4393528c6251fdd60c293fdb969365b75aeceee05754aa5); /* branch */ \n\n            // The last element is a queue tx, therefore pull timestamp and block number from the\n            // queue element.\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\n            // least one queue element. We increment nextQueueIndex after processing each queue\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\nc_0xeec32677(0xc7f0c869b6a8cc3dcce6294daa90a1e062c146f1615112390f4ee2fe3d573f8e); /* line */ \n            c_0xeec32677(0x327b2771e8eb89c544cbfd36509444ddf9e2ac842ea47af73c0132d320bf1196); /* statement */ \nLib_OVMCodec.QueueElement memory lastElement = queueElements[nextQueueIndex - 1];\n\nc_0xeec32677(0x77d8fdf9b161959c8238e817eca988ca84509230232b106033eff506bfcbcbb7); /* line */ \n            c_0xeec32677(0xe1663db094d5de2595e08b3b0a7b50b8582d23dc90bb0c0784f5c4c635a628b8); /* statement */ \nblockTimestamp = lastElement.timestamp;\nc_0xeec32677(0x0d32a42a4d4f3fc593e3fc38832f648d4042b0244ea0ebadc6fdcd006b1aa512); /* line */ \n            c_0xeec32677(0x1682ddf0df7f9c7299df0d80b877b65b65f8400f0704295c24805f9c762233e8); /* statement */ \nblockNumber = lastElement.blockNumber;\n        }\n\n        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\nc_0xeec32677(0xb482cb462bf93b4fc2128539ad69b3bb0c3dff15f44f71de9276e43055ab746c); /* line */ \n        c_0xeec32677(0xe82bb4cdead7588ff481ae544580017336fef4281f9a3d0fe5f19b7119a0f2c8); /* statement */ \n_appendBatch(\n            blockhash(block.number - 1),\n            totalElementsToAppend,\n            numQueuedTransactions,\n            blockTimestamp,\n            blockNumber\n        );\n\n        // slither-disable-next-line reentrancy-events\nc_0xeec32677(0xfa801fb9a326efdbf6feca0e7f8a15dc79efa1869ce50df70e9c2e6337c0df6f); /* line */ \n        c_0xeec32677(0x9e571c8901310a2dfc16cbe0f07f32da6fd6d00b44873d79171ed368c58ce01e); /* statement */ \nemit SequencerBatchAppended(\n            nextQueueIndex - numQueuedTransactions,\n            numQueuedTransactions,\n            getTotalElements()\n        );\n\n        // Update the _nextQueueIndex storage variable.\n        // slither-disable-next-line reentrancy-no-eth\nc_0xeec32677(0x834f2f39b8a20f14471ee0fd4ca96b5cd509e0d9401cbf98a6c9fef4dc622fed); /* line */ \n        c_0xeec32677(0xa3f1317eb712dfd10bc75cdae660756ab9e1148f275bd9a20db7acf672450e86); /* statement */ \n_nextQueueIndex = nextQueueIndex;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Returns the BatchContext located at a particular index.\n     * @param _index The index of the BatchContext\n     * @return The BatchContext at the specified index.\n     */\n    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {c_0xeec32677(0x85b3a290d148881685c24741db4e4502f02d66ac5be7a94333b94577826f0208); /* function */ \n\nc_0xeec32677(0xc73d8cd354c5bc2bd61f1fa1256e754db79155313139c705f45c58a178f1edf4); /* line */ \n        c_0xeec32677(0xae52d8ba81edd34f33bb974f6fce2e7386165d27b52f323c22cbe160ffcef47a); /* statement */ \nuint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\n        // slither-disable-next-line similar-names\nc_0xeec32677(0x1ab4b4bb841391be620e58cb167bdbc7e61faf6cfb15f37920e0d8d77137cd7d); /* line */ \n        c_0xeec32677(0x769f33d22d8d03cc9267351cc585556b1e71b4022716ca0cc0c10454f4b242bc); /* statement */ \nuint256 numSequencedTransactions;\nc_0xeec32677(0xa3cb5674818a609fde0eb88a8f1b0a51894b2b27c11f7995d14ffdb048b08496); /* line */ \n        c_0xeec32677(0x4535bb836885af974f173f3549fb7ec089b71f64f598b6674dd99a9b7d3bf21e); /* statement */ \nuint256 numSubsequentQueueTransactions;\nc_0xeec32677(0x3ab0bab62fbb4f8d032497dd6eb08201ed207534ff9b1ac273218e20538a0630); /* line */ \n        c_0xeec32677(0xf160e49a8337cf81c1f84d9fed7014807170b063dff40d5e6a9ae0c75a3042dd); /* statement */ \nuint256 ctxTimestamp;\nc_0xeec32677(0x1db122a53804e24caf1f85748efb3dbd789c3d69e99a2670d138c3084b974a9b); /* line */ \n        c_0xeec32677(0xeb2a75ff8e2550a8908f58f99283e5dbf3c2a3edf18830e564dc2a0c8dbed6b7); /* statement */ \nuint256 ctxBlockNumber;\n\nc_0xeec32677(0x079a1daead4db702c7cd28cd390d59d64300526b348d78c9e0acbe7f7954f791); /* line */ \n        assembly {\n            numSequencedTransactions := shr(232, calldataload(contextPtr))\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\n            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))\n            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))\n        }\n\nc_0xeec32677(0x1335e25c3edb29b127c55df08f48d084fa7d3d71f50fced76d3228bc0904a4aa); /* line */ \n        c_0xeec32677(0xdd4307f14350d493feb386ffd5391e9d596e55004480972c6157577f9ab21d7e); /* statement */ \nreturn\n            BatchContext({\n                numSequencedTransactions: numSequencedTransactions,\n                numSubsequentQueueTransactions: numSubsequentQueueTransactions,\n                timestamp: ctxTimestamp,\n                blockNumber: ctxBlockNumber\n            });\n    }\n\n    /**\n     * Parses the batch context from the extra data.\n     * @return Total number of elements submitted.\n     * @return Index of the next queue element.\n     */\n    function _getBatchExtraData()\n        internal\n        view\n        returns (\n            uint40,\n            uint40,\n            uint40,\n            uint40\n        )\n    {c_0xeec32677(0x810e26375ebb2cb84520925d76da9700764b3280dc376a9abe8b38268bab6c48); /* function */ \n\nc_0xeec32677(0x5812fdfa70d1de3e053dd631c026cd5ccbae3e54f0ac9a0ca72ad5a4dc69cd3b); /* line */ \n        c_0xeec32677(0xe6a920437bec41e8ce8b23c20688fad8beae6a482d15bae7f1798d71d6370ec5); /* statement */ \nbytes27 extraData = batches().getGlobalMetadata();\n\nc_0xeec32677(0x53562f0edc7982d9c642019aa2845a267556d72d89ab3a3e01cd63cba96b86e2); /* line */ \n        c_0xeec32677(0x979c5ed9d7b99ee2f6e06a8a36c7279bf42610664793d70defd3c5e81f1e3a06); /* statement */ \nuint40 totalElements;\nc_0xeec32677(0x1ebb52586a1f53ab81c05af2d7aee6a35010459d60f112fa611dd542bc188662); /* line */ \n        c_0xeec32677(0xf802d0edf54fc4a8bd1895ed4ee6d432d4367a57ca567a3817ea3f0c77a25a2e); /* statement */ \nuint40 nextQueueIndex;\nc_0xeec32677(0xcebf16f544881febda308e0330f8099129c1cef1faf5066646a811a767b92b76); /* line */ \n        c_0xeec32677(0x262a2435c73c0305fa94cbb52e97221f219938351e9e39048eb9ff673ed971d7); /* statement */ \nuint40 lastTimestamp;\nc_0xeec32677(0x7a07416327c5ba2efdb0849bcd2350a2f898ab545325212685b795ae4a3e5eae); /* line */ \n        c_0xeec32677(0x6eed63cd66c1b4c87f206eb7d06d66e9ad12525d9018f0b132af54c124d22e3b); /* statement */ \nuint40 lastBlockNumber;\n\n        // solhint-disable max-line-length\nc_0xeec32677(0x3ace6ff24e6157e17d6d1b90b387d2785e219a3fd40596e7ef58c785eb49b916); /* line */ \n        assembly {\n            extraData := shr(40, extraData)\n            totalElements := and(\n                extraData,\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\n            )\n            nextQueueIndex := shr(\n                40,\n                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)\n            )\n            lastTimestamp := shr(\n                80,\n                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)\n            )\n            lastBlockNumber := shr(\n                120,\n                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)\n            )\n        }\n        // solhint-enable max-line-length\n\nc_0xeec32677(0xcafde19d38f9acba7061fa3bfaaaa6afd87797e5f0101a81e3da158edf08e227); /* line */ \n        c_0xeec32677(0x23ab64c17886581ffbcd4c2e6bff3f52a676df407e918c8a0cd1d8f93e3d87df); /* statement */ \nreturn (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);\n    }\n\n    /**\n     * Encodes the batch context for the extra data.\n     * @param _totalElements Total number of elements submitted.\n     * @param _nextQueueIdx Index of the next queue element.\n     * @param _timestamp Timestamp for the last batch.\n     * @param _blockNumber Block number of the last batch.\n     * @return Encoded batch context.\n     */\n    function _makeBatchExtraData(\n        uint40 _totalElements,\n        uint40 _nextQueueIdx,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    ) internal pure returns (bytes27) {c_0xeec32677(0xe406b0afcfd7a45b5482ecc475287c84d82b73cf3b04b2aa90b65975c94f2ee2); /* function */ \n\nc_0xeec32677(0x5ed2b5da73d3f1463714cfa08ba8104ade378e2ebdefc9223afeaa625b30f01a); /* line */ \n        c_0xeec32677(0xe767f2127a212df250a52352e70c881573a132e1aa08cdb0b30b0dc3489211e9); /* statement */ \nbytes27 extraData;\nc_0xeec32677(0xbbacf011ced1c81e4ecca1fb2e5f71f3aac13554b332bf2bc5b85d9c0b5783ce); /* line */ \n        assembly {\n            extraData := _totalElements\n            extraData := or(extraData, shl(40, _nextQueueIdx))\n            extraData := or(extraData, shl(80, _timestamp))\n            extraData := or(extraData, shl(120, _blockNumber))\n            extraData := shl(40, extraData)\n        }\n\nc_0xeec32677(0x4fba2af3c3cef85545ca7b5476b2f3b0a6d9bed8df6dfbed2da04222d34ac5f0); /* line */ \n        c_0xeec32677(0x056ec91bff8b42e568047065c308e3148832d7eb284d8a7b2655d6d91cf97be0); /* statement */ \nreturn extraData;\n    }\n\n    /**\n     * Inserts a batch into the chain of batches.\n     * @param _transactionRoot Root of the transaction tree for this batch.\n     * @param _batchSize Number of elements in the batch.\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\n     * @param _timestamp The latest batch timestamp.\n     * @param _blockNumber The latest batch blockNumber.\n     */\n    function _appendBatch(\n        bytes32 _transactionRoot,\n        uint256 _batchSize,\n        uint256 _numQueuedTransactions,\n        uint40 _timestamp,\n        uint40 _blockNumber\n    ) internal {c_0xeec32677(0x6c78f7ae9533e2e3e7d4fda395e95952c976429105c7ca6e1d3cfa2cbe0b0a58); /* function */ \n\nc_0xeec32677(0x8168d053cabda9564990f5b307fd1baca7739e468b27199dfe60b4de18020e8d); /* line */ \n        c_0xeec32677(0x128e24882787747dc9fcd647af59d0f46698cdab6c63cceec8871f94212d5919); /* statement */ \nIChainStorageContainer batchesRef = batches();\nc_0xeec32677(0x87b1176200856b34405f8f6655f4dc76c33f562941ed13ada47250704b5aad6f); /* line */ \n        c_0xeec32677(0xc139b6f14a3f763a86de8668940cb33cb77569f860f87221cee01a4ff751ebe6); /* statement */ \n(uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();\n\nc_0xeec32677(0x7a14ed50d788685cca7efba463d505406ca89491294be875c35dade6b3a804dc); /* line */ \n        c_0xeec32677(0x394e6ab980de147cde9e2b92760b545324cee7076a78ac521f1f6b16646f5fa9); /* statement */ \nLib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\n            batchIndex: batchesRef.length(),\n            batchRoot: _transactionRoot,\n            batchSize: _batchSize,\n            prevTotalElements: totalElements,\n            extraData: hex\"\"\n        });\n\nc_0xeec32677(0x75d4513bd5ed35fadcac257a3a365d36ac35d3fc69ebad96bb4f06ebfcfc7cfc); /* line */ \n        c_0xeec32677(0x5ccc40a20d324b1762ab4c564a55104ee7bd4812578f84a6b58d134a34633c80); /* statement */ \nemit TransactionBatchAppended(\n            header.batchIndex,\n            header.batchRoot,\n            header.batchSize,\n            header.prevTotalElements,\n            header.extraData\n        );\n\nc_0xeec32677(0x90380e4fbbaa3ccc8c76eed23244e09ad1cdd4151458f0594ed6c49586c30be2); /* line */ \n        c_0xeec32677(0x82122d4345ec5634f4614120e1e17bd1d1115bf2635a41389ef39516b3451453); /* statement */ \nbytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\nc_0xeec32677(0xf14a346eec89e000225142dbb9f3b3a59b1ea0488ed4a04fb38a3a3c96c5b08c); /* line */ \n        c_0xeec32677(0x3af893382df58eb2006c80f25abab9c1b6649fd8b8ac3062d78f5fa170c9a362); /* statement */ \nbytes27 latestBatchContext = _makeBatchExtraData(\n            totalElements + uint40(header.batchSize),\n            nextQueueIndex + uint40(_numQueuedTransactions),\n            _timestamp,\n            _blockNumber\n        );\n\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\nc_0xeec32677(0xe41873a0f52b01ae9f88e869befc329a77c944bf11401b80a4392c63c4007890); /* line */ \n        c_0xeec32677(0x71e57c62a4b38bc04621fc77bbbd0a16ce0328bdd81b1d3899636af163b317ee); /* statement */ \nbatchesRef.push(batchHeaderHash, latestBatchContext);\n    }\n}\n"
    },
    "contracts/standards/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.7;\nfunction c_0x9ac73e0c(bytes32 c__0x9ac73e0c) pure {}\n\n\nlibrary AddressAliasHelper {\nfunction c_0xeadf8bad(bytes32 c__0xeadf8bad) public pure {}\n\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {c_0xeadf8bad(0x71520d44f3ec9a960667301f1be4d5baecdfff4f41f66e511a7bffdcf0c99ca7); /* function */ \n\nc_0xeadf8bad(0x7d06186b90366d06a5a666bd84184acc538e404d78e0855dec677b484fdfdbb2); /* line */ \n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {c_0xeadf8bad(0xe4bb1f30001c6decd80cfa863a9931792d733e23bef5da3af10587854fa4cfaa); /* function */ \n\nc_0xeadf8bad(0xd5778b340d43e97843c96bb2d95404e95818b091ece2cc577d220eba749bb1ec); /* line */ \n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "contracts/test-libraries/codec/TestLib_OVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/**\n * @title TestLib_OVMCodec\n */\ncontract TestLib_OVMCodec {\n    function encodeTransaction(Lib_OVMCodec.Transaction memory _transaction)\n        public\n        pure\n        returns (bytes memory _encoded)\n    {\n        return Lib_OVMCodec.encodeTransaction(_transaction);\n    }\n\n    function hashTransaction(Lib_OVMCodec.Transaction memory _transaction)\n        public\n        pure\n        returns (bytes32 _hash)\n    {\n        return Lib_OVMCodec.hashTransaction(_transaction);\n    }\n}\n"
    },
    "contracts/L1/messaging/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xbb6624ef(bytes32 c__0xbb6624ef) pure {}\n\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressManager } from \"../../libraries/resolver/Lib_AddressManager.sol\";\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_DefaultValues } from \"../../libraries/constants/Lib_DefaultValues.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Lib_CrossDomainUtils } from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\n\n/* Interface Imports */\nimport { IL1CrossDomainMessenger } from \"./IL1CrossDomainMessenger.sol\";\nimport { ICanonicalTransactionChain } from \"../rollup/ICanonicalTransactionChain.sol\";\nimport { IStateCommitmentChain } from \"../rollup/IStateCommitmentChain.sol\";\n\n/* External Imports */\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title L1CrossDomainMessenger\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages\n * from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2\n * epoch gas limit, it can be resubmitted via this contract's replay function.\n *\n */\ncontract L1CrossDomainMessenger is\n    IL1CrossDomainMessenger,\n    Lib_AddressResolver,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\nfunction c_0xf0dad4d0(bytes32 c__0xf0dad4d0) public pure {}\n\n    /**********\n     * Events *\n     **********/\n\n    event MessageBlocked(bytes32 indexed _xDomainCalldataHash);\n\n    event MessageAllowed(bytes32 indexed _xDomainCalldataHash);\n\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    mapping(bytes32 => bool) public blockedMessages;\n    mapping(bytes32 => bool) public relayedMessages;\n    mapping(bytes32 => bool) public successfulMessages;\n\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * This contract is intended to be behind a delegate proxy.\n     * We pass the zero address to the address resolver just to satisfy the constructor.\n     * We still need to set this value in initialize().\n     */\n    constructor() Lib_AddressResolver(address(0)) {c_0xf0dad4d0(0xf68219dab4a588dc6b667c9779cf1d2339bbee2ef9c87ee304dcd9d1e14ea39a); /* function */ \n}\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    // slither-disable-next-line external-function\n    function initialize(address _libAddressManager) public initializer {c_0xf0dad4d0(0x43523d17d6d5a3cf60175ad36e6a9bf1527048af7c0f32f4f1603571bec9dbea); /* function */ \n\nc_0xf0dad4d0(0x50da66564a80376c647e92600216040985273386b61cc829cd7e30f6a17f67d2); /* line */ \n        c_0xf0dad4d0(0xf24d4e0b39edf1776c40007e8e8012f3700818d332b0a08d98c7f8306e77ffea); /* requirePre */ \nc_0xf0dad4d0(0xb8908c76a06e2bb0972d079ff3b7463fb5c47792c62017b57e9afeff9b514401); /* statement */ \nrequire(\n            address(libAddressManager) == address(0),\n            \"L1CrossDomainMessenger already intialized.\"\n        );c_0xf0dad4d0(0x5a7b67d176015477b09b563674b01946e31c15f494652c34d48eda4f4c5575fd); /* requirePost */ \n\nc_0xf0dad4d0(0xfa524a6603243d4721d42ab60ea57c936ca9fee7486d985804d71c1b76be75de); /* line */ \n        c_0xf0dad4d0(0x4800999c2e2f1aa74989d7827cb1155083db5418f820d4f01222365cd956bcef); /* statement */ \nlibAddressManager = Lib_AddressManager(_libAddressManager);\nc_0xf0dad4d0(0xe3d3575340f24530b7ae945fad4e38dc657cf781c9670ee05aaa0d58792cd497); /* line */ \n        c_0xf0dad4d0(0xbe412ba4e8c86d5ab57fc6f6219461b529d09f8b842d9531ca2067db8937fa8b); /* statement */ \nxDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Initialize upgradable OZ contracts\nc_0xf0dad4d0(0x25d6114662e14cc2478cf3eff4ff18592a090e36c3181261909151f51a195513); /* line */ \n        c_0xf0dad4d0(0xf4210e9251854ecee003220aa20cf4eb0982a7258aae93a636a863db67a375e8); /* statement */ \n__Context_init_unchained(); // Context is a dependency for both Ownable and Pausable\nc_0xf0dad4d0(0x02d329743b952626566d4c19c54fad23efef81d9c3fe027a342cdb5ee241f50d); /* line */ \n        c_0xf0dad4d0(0x03e2cb9fc5c6cab353529da4537d818dbdf0f570eff198b33bb6bba3cac9c7c3); /* statement */ \n__Ownable_init_unchained();\nc_0xf0dad4d0(0x188a0ff9d21957c7377eaa1d1867e606cc119e170cefb57af45850b23f0e6760); /* line */ \n        c_0xf0dad4d0(0x44b4b1d9b1e1955cbea0660983e2cf045d976c853fafb1f185cb7f4b0a1f00a3); /* statement */ \n__Pausable_init_unchained();\nc_0xf0dad4d0(0x5c953c436db06f59259f2e2d1ed59cf2bb9a8cd98efe8ceee606006efe8a95fe); /* line */ \n        c_0xf0dad4d0(0xe7f67e1312f937d1a7fd4b38b95f551de184fb0111f1601ad3592a3d98f80beb); /* statement */ \n__ReentrancyGuard_init_unchained();\n    }\n\n    /**\n     * Pause relaying.\n     */\n    function pause() external onlyOwner {c_0xf0dad4d0(0x885908d43c0231864291179d3e5b400c8e06b7f774bbdaf84a340caa67421a95); /* function */ \n\nc_0xf0dad4d0(0x9866b6d196bea65780f2e84d893c8cbfdbf10d2217a3710d5767c46c455f76e8); /* line */ \n        c_0xf0dad4d0(0xe888856e793faa85685ab0be9e54b1a13d69a4b4a26692fde05186c905aa89b2); /* statement */ \n_pause();\n    }\n\n    /**\n     * Block a message.\n     * @param _xDomainCalldataHash Hash of the message to block.\n     */\n    function blockMessage(bytes32 _xDomainCalldataHash) external onlyOwner {c_0xf0dad4d0(0xd000f3c2fcdbd38259b8277ce3dcce11a35673e2ad4c655b9af69fa74ca48e47); /* function */ \n\nc_0xf0dad4d0(0x78870046cdddc887ba34ceea22ef249335a0e66a064ffdd93d22d8f4bf01dc3f); /* line */ \n        c_0xf0dad4d0(0xef8930c34234d0e9dd47a476405e2872c5783467c7b3fa873cd3399a88be6c0e); /* statement */ \nblockedMessages[_xDomainCalldataHash] = true;\nc_0xf0dad4d0(0x46f9b46671e1bdbd4d64fe7c3e8e2378535d094a3445fd209d47990bf17d92c0); /* line */ \n        c_0xf0dad4d0(0x942934c5d607518f112c7b62313d1b7b995a71a5aa244d2271fdf3060ada55d7); /* statement */ \nemit MessageBlocked(_xDomainCalldataHash);\n    }\n\n    /**\n     * Allow a message.\n     * @param _xDomainCalldataHash Hash of the message to block.\n     */\n    function allowMessage(bytes32 _xDomainCalldataHash) external onlyOwner {c_0xf0dad4d0(0xad12fbc2ae57493e8dc2297bfa1b927926ba0cdc408607c8e7e0af08dbefa471); /* function */ \n\nc_0xf0dad4d0(0xae29ed958836d256747b01d73c807bacd73e13a6d11c1383e392f4580eb9b00b); /* line */ \n        c_0xf0dad4d0(0xcb12c9ba4ab12a1288e0f449b755fc4bcbbd4404a1303a3082227387112a393d); /* statement */ \nblockedMessages[_xDomainCalldataHash] = false;\nc_0xf0dad4d0(0xdb0694e8bfde4e6eea3eebde273090be6c62203d24f75f17a22716884d9b52bf); /* line */ \n        c_0xf0dad4d0(0xbd0b8daba831d608f2f8bbffef99667e2507f0ddf9e68bbcee1e0a6eefda87d9); /* statement */ \nemit MessageAllowed(_xDomainCalldataHash);\n    }\n\n    // slither-disable-next-line external-function\n    function xDomainMessageSender() public view returns (address) {c_0xf0dad4d0(0x9105d62115df0636ebbb381b3eb42f194f53ee5ea76173976e7788039ce8427f); /* function */ \n\nc_0xf0dad4d0(0x4c2c7cb2a8768cc3e1d580530365b8d740af326a3bf20f119020e57dd49e1207); /* line */ \n        c_0xf0dad4d0(0xfbccc5f90ec0d115ff0bb2eeefa0d3aac0c5bacc97ab855ddd4fd5e453b988b5); /* requirePre */ \nc_0xf0dad4d0(0xda406768069b698b30be9bc2e872463da816efd0500d2cd3dc699308131e9f83); /* statement */ \nrequire(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );c_0xf0dad4d0(0x949793e31c2bcf0445a049557e4f2e2f4ac020cd1ed7a47544589e422d02169c); /* requirePost */ \n\nc_0xf0dad4d0(0x88bc4c764100ed10e209d0e550c0a1a3b8e273a20c4492cd8c32def62390d768); /* line */ \n        c_0xf0dad4d0(0x4ac18fff6c95a43426d3bae9fa925c421886e7798f9bfbe0cd45b64725a0b59a); /* statement */ \nreturn xDomainMsgSender;\n    }\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    // slither-disable-next-line external-function\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) public {c_0xf0dad4d0(0xbb45b48ad1fcd305b9c05e84e43ca1035f4cac65b1ae3d98b15a9544e207726b); /* function */ \n\nc_0xf0dad4d0(0xd68566f2a1d7b5e4d181df5c87775a7576a4bdf00bd84c5aadb13bbdd54b0390); /* line */ \n        c_0xf0dad4d0(0x09382110f17af5b7bb3e0c098fc458b7514a7a9843ef071350c1ebfc6063a38e); /* statement */ \naddress ovmCanonicalTransactionChain = resolve(\"CanonicalTransactionChain\");\n        // Use the CTC queue length as nonce\nc_0xf0dad4d0(0x2aaf89a094db7416ab3253356ebdde13e1cedcf46403f1dacdff3097ab57b8e1); /* line */ \n        c_0xf0dad4d0(0x19814548a6296b06ae0d2d79eb82064faf56b9e7e3ba31e8e72cfe89875c9a35); /* statement */ \nuint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();\n\nc_0xf0dad4d0(0x192e008ca71bfc1dd0ddb6a036c3b758b9006f69a27647c3a3f12ccea495f44e); /* line */ \n        c_0xf0dad4d0(0x357359aeeaaaa935d4e8c8bea53c5977e9cef0cb6a2d39279b23e7ede2a7f9b0); /* statement */ \nbytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            nonce\n        );\n\n        // slither-disable-next-line reentrancy-events\nc_0xf0dad4d0(0x02d0fd67c1f38afc9c859b42b005c67cb91d811d6917779a379211730b739330); /* line */ \n        c_0xf0dad4d0(0x658c78fc6bc02c8d01df9b480dd4160a8fb5f4484712bcdbf0700a08fec67ccd); /* statement */ \n_sendXDomainMessage(ovmCanonicalTransactionChain, xDomainCalldata, _gasLimit);\n\n        // slither-disable-next-line reentrancy-events\nc_0xf0dad4d0(0x324a2294605c9fb5798dc9b9b4cf51564bf1f599e7e0563b8be9d79d47a1b4ec); /* line */ \n        c_0xf0dad4d0(0xeea566a2d9e3ba1554caf796cda23cf7bed33c6e6f9f109ddc118c078ce1815e); /* statement */ \nemit SentMessage(_target, msg.sender, _message, nonce, _gasLimit);\n    }\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @inheritdoc IL1CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    ) public nonReentrant whenNotPaused {c_0xf0dad4d0(0x851bad1b483996564115a75a88abcbf59a0a48a8a848060454d3d7f624195fc8); /* function */ \n\nc_0xf0dad4d0(0x5618eb37606615c68830506bf92edb4deaeb4049b336c3a8bc149d8f9be9e388); /* line */ \n        c_0xf0dad4d0(0x8d803f570dad530be1562411f02ab84b45ee8617b2ede8e308137c6926084bc1); /* statement */ \nbytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\nc_0xf0dad4d0(0x97f800e76615a97dd64c88fc958a9247f8b21c34d3dfb645bb58aee0ded226ef); /* line */ \n        c_0xf0dad4d0(0x6cc6aa1f92763519b669704fb579183c502dcfc9f599c6c80f9543ee48d4d9db); /* requirePre */ \nc_0xf0dad4d0(0x5993b4fcc48b87e99a767c9ff7868e7ffd4d77b517d3bb2e5f4b8230f34e6c7f); /* statement */ \nrequire(\n            _verifyXDomainMessage(xDomainCalldata, _proof) == true,\n            \"Provided message could not be verified.\"\n        );c_0xf0dad4d0(0xcc76a939647669762f3020e7aecbae93eb2e36d3634f11833a5571dac1cd7d11); /* requirePost */ \n\n\nc_0xf0dad4d0(0x6af7900970ee22824d27190d7e0e72fa44fe2cb500769d6374cea9d63b644706); /* line */ \n        c_0xf0dad4d0(0x01fd380782dca576e2e5d13a0351a2d5e9579031187762b5524269d05b082258); /* statement */ \nbytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\nc_0xf0dad4d0(0xdb2858d7794baaf733cea831b323445977846ba094e1ef901daec24a47b7976e); /* line */ \n        c_0xf0dad4d0(0x5b02612abedbcafbe0c2fe2b71dc381aedd0b2df2f6f7b5243d5dbc4da4e538d); /* requirePre */ \nc_0xf0dad4d0(0xa56e08fd8c9b27ed38e8777688417d76422251b17684a7d95d3650e626514ffb); /* statement */ \nrequire(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );c_0xf0dad4d0(0x958455803b744a5bbfff23b3ff1fa9d730561feab0b23fbd9958a61d71f372c4); /* requirePost */ \n\n\nc_0xf0dad4d0(0x44b57df007fbcc67a30c05da36ef594c2cdfadfa9d70330ebf5fb070280eb5a0); /* line */ \n        c_0xf0dad4d0(0xa11ef2ce0865fbaff75a59d12347767a6560cc0187504ffa7affee30d4ebadd1); /* requirePre */ \nc_0xf0dad4d0(0x44e3093e94015bb79373050c880ad1ec366a23cdae2ef9c032a1c129dba77767); /* statement */ \nrequire(\n            blockedMessages[xDomainCalldataHash] == false,\n            \"Provided message has been blocked.\"\n        );c_0xf0dad4d0(0xe5e534f5fd055cc41b8d7c0c6eecf0937dc0f7fffb3786bb7890c89c909d2648); /* requirePost */ \n\n\nc_0xf0dad4d0(0xc8c434892f4a86fba2fc876540aa11c375f9c931b878fbd0c45fa040736fc84c); /* line */ \n        c_0xf0dad4d0(0xab679a283a6470d5ad300ae2993491166b2fee76a0dd53b8664025a3e6601dd0); /* requirePre */ \nc_0xf0dad4d0(0x69e917741e40a0e629e5ec316d21cae7ad779c3073845738c60376cb3ebbb68a); /* statement */ \nrequire(\n            _target != resolve(\"CanonicalTransactionChain\"),\n            \"Cannot send L2->L1 messages to L1 system contracts.\"\n        );c_0xf0dad4d0(0x6721b8315368d8b41921f2a2ffdb10d0aaeb9024714111429448af0bd2637293); /* requirePost */ \n\n\nc_0xf0dad4d0(0x26f24500b04737e5b85d98f4ac698cbfa22574d6239d6102c759083ff9bf397c); /* line */ \n        c_0xf0dad4d0(0x56a3bd3dd469424cc4339dbcbf5f6a0b64da06b9beb1f49754cea1c378873db8); /* statement */ \nxDomainMsgSender = _sender;\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\nc_0xf0dad4d0(0xc6cc50fa2c2cd679f2b2bf6911f3437402c032a6952ed563eab0cfa95cf574d6); /* line */ \n        c_0xf0dad4d0(0xa74c7e73874a841972f15777247ce49bcb2a67fc2fadec8b4139f9deedc5131d); /* statement */ \n(bool success, ) = _target.call(_message);\n        // slither-disable-next-line reentrancy-benign\nc_0xf0dad4d0(0x1e74c054c68983641648a5fff30f9760233e0da301b0b28deb60e2b8106d0152); /* line */ \n        c_0xf0dad4d0(0x3d72d98bfe5fc699c2174ce952f6152de1323d28e564186b5f4d2ec8fd8f0cb3); /* statement */ \nxDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\nc_0xf0dad4d0(0x4556a42848948e83cab43fcf807e063bc6e99c915c52dafebb3177d6350435ff); /* line */ \n        c_0xf0dad4d0(0xd026cc1511ea5de83346c2eef401ee8141917d3b68c3035e87f116bd3fdb7544); /* statement */ \nif (success == true) {c_0xf0dad4d0(0xdcc0abc875ceac3d15299210e1ea7866085c4cbd3ee5687dc7138e1523cd7d9d); /* branch */ \n\n            // slither-disable-next-line reentrancy-no-eth\nc_0xf0dad4d0(0x6e2f59df0fb6799028ce49e72c061d6de54d8b272bc7ad965298466050595777); /* line */ \n            c_0xf0dad4d0(0xa6b5942239704bee96b2fbf2cffa8b2753a34299a5a75373e27a451ed0d63923); /* statement */ \nsuccessfulMessages[xDomainCalldataHash] = true;\n            // slither-disable-next-line reentrancy-events\nc_0xf0dad4d0(0x211d403466e6c58d58cc262e69a64565423c337f94848efecf43ff562abebb63); /* line */ \n            c_0xf0dad4d0(0x4e87f22e0ce4ce254cd69b2a706ba745b444e3ad1b8c30d7d52e8eb714c10371); /* statement */ \nemit RelayedMessage(xDomainCalldataHash);\n        } else {c_0xf0dad4d0(0x8c2b080a69533415d694bfae71d72c6a4de5fadd036f2602b9c7902f22b38c3a); /* branch */ \n\n            // slither-disable-next-line reentrancy-events\nc_0xf0dad4d0(0x795e20a64e689e627b488afffc433a0f587cf832c6d32be5607217589ebdb663); /* line */ \n            c_0xf0dad4d0(0xc8b963469acd87004d3b8c4d94c201aeaf1e9e1a6a66c211f5335c27973821e6); /* statement */ \nemit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\nc_0xf0dad4d0(0xd446b38e86c0a631b350e3be16ac5151d4b930ce992b499f87c38d4f1d7ecd67); /* line */ \n        c_0xf0dad4d0(0x6548e51d34339db9764cae151e0e5d52017536bc7e6f770139acbce80d0a6ab8); /* statement */ \nbytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\n        // slither-disable-next-line reentrancy-benign\nc_0xf0dad4d0(0x4e2028646bbb4185ea015bf1386299b92d2dede39d103d51794a8c29d9ec012f); /* line */ \n        c_0xf0dad4d0(0x7692ddac2073a69fd67eee68afab6b3ae2f056a986ead0f0dea3953ad7302c7e); /* statement */ \nrelayedMessages[relayId] = true;\n    }\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @inheritdoc IL1CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _oldGasLimit,\n        uint32 _newGasLimit\n    ) public {c_0xf0dad4d0(0x3f7936b6793630613988a8f2c3073abf39a78192a6a93da8d383e3a03e5c1de7); /* function */ \n\n        // Verify that the message is in the queue:\nc_0xf0dad4d0(0xc08158991770b949edb0a4bfe631908185b74608159c20973a97ad5f5e2fb54b); /* line */ \n        c_0xf0dad4d0(0x64fc14a0576f5db0607b0865a04d1816439209c897e7b5bdee93ba07245a4b8f); /* statement */ \naddress canonicalTransactionChain = resolve(\"CanonicalTransactionChain\");\nc_0xf0dad4d0(0xc79562602d5a14ef1fd781478178ed7264835ad50d026c2227a2a185f6859f8e); /* line */ \n        c_0xf0dad4d0(0xd606e1e3270f43e70364683d4be86f86f4a85d644b60b1ca845dcb9f06c1887a); /* statement */ \nLib_OVMCodec.QueueElement memory element = ICanonicalTransactionChain(\n            canonicalTransactionChain\n        ).getQueueElement(_queueIndex);\n\n        // Compute the calldata that was originally used to send the message.\nc_0xf0dad4d0(0x68f412f2e5ad3f388c8135f57df91d5aae9988889b2127b3aed4edfa057efa9b); /* line */ \n        c_0xf0dad4d0(0x772fdd29b720157b1bb1620cea9e2222f741a4df469545eb98a58ceb77d5a8b5); /* statement */ \nbytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _queueIndex\n        );\n\n        // Compute the transactionHash\nc_0xf0dad4d0(0xa3aea12a5f860943e2f9836cf0a65855c1bc151c31fd34e3ea5f7ffea2f80981); /* line */ \n        c_0xf0dad4d0(0xcea6602fc41733a1ca80886edd90ab3785f43dbbb3e03d078882ed66b9229ace); /* statement */ \nbytes32 transactionHash = keccak256(\n            abi.encode(\n                AddressAliasHelper.applyL1ToL2Alias(address(this)),\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n                _oldGasLimit,\n                xDomainCalldata\n            )\n        );\n\n        // Now check that the provided message data matches the one in the queue element.\nc_0xf0dad4d0(0x43e654a764abb04c1dfd566e819901ea19658ea6f3a86b2a47175df120d44155); /* line */ \n        c_0xf0dad4d0(0xcc2c2208c684a05109f37fa047dcb53e06b1553acb8de480ec7a759a42656d51); /* requirePre */ \nc_0xf0dad4d0(0x882c4cf02ca3339be5b86daebf183f57843cabf119a7e5fc725c9b9cf35e4f58); /* statement */ \nrequire(\n            transactionHash == element.transactionHash,\n            \"Provided message has not been enqueued.\"\n        );c_0xf0dad4d0(0x811c324c79fc8b5accf562ab5c3b293bbabe685fce78dc56ad042b54476da3ef); /* requirePost */ \n\n\n        // Send the same message but with the new gas limit.\nc_0xf0dad4d0(0xafeef0f1e2c622235ce929c67715a5d6ea4d16a7e7e38ce29e506b875012943a); /* line */ \n        c_0xf0dad4d0(0x16239e236d72ae2366c4b87ecff979d5465de712a5521db9c7a9b0a3dc882d47); /* statement */ \n_sendXDomainMessage(canonicalTransactionChain, xDomainCalldata, _newGasLimit);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Verifies that the given message is valid.\n     * @param _xDomainCalldata Calldata to verify.\n     * @param _proof Inclusion proof for the message.\n     * @return Whether or not the provided message is valid.\n     */\n    function _verifyXDomainMessage(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    ) internal view returns (bool) {c_0xf0dad4d0(0xf7416099b2494743143c558c3b38934e49bd016ea418f97813c0aadf67b0c512); /* function */ \n\nc_0xf0dad4d0(0x11d6e9dc37f21fbd0b0141fcfab6b6fd951640caf3994e4548e7d3cf16b20685); /* line */ \n        c_0xf0dad4d0(0xe56ec342e742383da68fb8022e87905a06b0a60a290eda37faa138bcd7aff08b); /* statement */ \nreturn (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\n    }\n\n    /**\n     * Verifies that the state root within an inclusion proof is valid.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStateRootProof(L2MessageInclusionProof memory _proof)\n        internal\n        view\n        returns (bool)\n    {c_0xf0dad4d0(0x33a73d403d6e02742fa7f60d55074340fc3ffd0f92d582e3157cfce54365d4ac); /* function */ \n\nc_0xf0dad4d0(0x61d2a150eaf047c10ee0ff2a7a4f2894fce96fcf4ead4ff978be742e912be2e2); /* line */ \n        c_0xf0dad4d0(0xc51d6c8d898b7de174ed6c6dff8b19ab1cc288e11e2f21aacf495d28337dacc0); /* statement */ \nIStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(\n            resolve(\"StateCommitmentChain\")\n        );\n\nc_0xf0dad4d0(0x8da9f54fd2c3fa9bdd6e27cdd586034317feed8ba0976ab10777c1c731afa9ff); /* line */ \n        c_0xf0dad4d0(0x3b1b9490d2aad33f7a1cb7f573ae1139618921eac0026d0c15a4ca832563161b); /* statement */ \nreturn (ovmStateCommitmentChain.insideFraudProofWindow(_proof.stateRootBatchHeader) ==\n            false &&\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _proof.stateRoot,\n                _proof.stateRootBatchHeader,\n                _proof.stateRootProof\n            ));\n    }\n\n    /**\n     * Verifies that the storage proof within an inclusion proof is valid.\n     * @param _xDomainCalldata Encoded message calldata.\n     * @param _proof Message inclusion proof.\n     * @return Whether or not the provided proof is valid.\n     */\n    function _verifyStorageProof(\n        bytes memory _xDomainCalldata,\n        L2MessageInclusionProof memory _proof\n    ) internal view returns (bool) {c_0xf0dad4d0(0x3d57b54ea1c134b0c873143dbc837e33a5b8e7b3bc4459145fb8707f44417b86); /* function */ \n\nc_0xf0dad4d0(0x8204179021282eb50d93a3fdec4f4745daa284f3488b89116307c856130c9bc6); /* line */ \n        c_0xf0dad4d0(0x9ddab03b321e11e42d9c3c3d43e4ab9f2c8ee0468c41bf6d70789664addd02c3); /* statement */ \nbytes32 storageKey = keccak256(\n            abi.encodePacked(\n                keccak256(\n                    abi.encodePacked(\n                        _xDomainCalldata,\n                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\n                    )\n                ),\n                uint256(0)\n            )\n        );\n\nc_0xf0dad4d0(0x58d5a03589124dfe0915bb6e62ea9a477a78885d4a339a04d86c7dd76be7d012); /* line */ \n        c_0xf0dad4d0(0xead7dc6fcdae4316067cd8334d592dfe81654a1e8059ed8214acabf0bccbfe28); /* statement */ \n(bool exists, bytes memory encodedMessagePassingAccount) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\n            _proof.stateTrieWitness,\n            _proof.stateRoot\n        );\n\nc_0xf0dad4d0(0x7633f5dd08196d5dc752b9897c8dd44211f076631e58d724895d36dec26756fc); /* line */ \n        c_0xf0dad4d0(0x18e3cf31251851ae5556db38f820f883168396eee4a3668cb9a34db98c77284f); /* requirePre */ \nc_0xf0dad4d0(0xf1f2e1e5c0b1acf42809463c2a301c34f6382c91e43a48a0d2f89734e98fc062); /* statement */ \nrequire(\n            exists == true,\n            \"Message passing predeploy has not been initialized or invalid proof provided.\"\n        );c_0xf0dad4d0(0x9a14120b5a3b9590bd63a469dfa4ae64874b7b324029e80c4b3f53a5fa682175); /* requirePost */ \n\n\nc_0xf0dad4d0(0xe38305d9996f4ba7409e838cb8b85ca3bd395b028d4a00dada9850aae37c69df); /* line */ \n        c_0xf0dad4d0(0x9190d17712212b673beb12ec32ff6a781bbf2d9f4fbc20cf654d520781187588); /* statement */ \nLib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n            encodedMessagePassingAccount\n        );\n\nc_0xf0dad4d0(0xdcebac1bf9b8c2a961b1e54aef7d0ca79cfce90cc16693cc9d1b5571017c2fc8); /* line */ \n        c_0xf0dad4d0(0x3f3d963106eb673c3372c5678632b592c0180aca42052dcf1ec18e602175c6c6); /* statement */ \nreturn\n            Lib_SecureMerkleTrie.verifyInclusionProof(\n                abi.encodePacked(storageKey),\n                abi.encodePacked(uint8(1)),\n                _proof.storageTrieWitness,\n                account.storageRoot\n            );\n    }\n\n    /**\n     * Sends a cross domain message.\n     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.\n     * @param _message Message to send.\n     * @param _gasLimit OVM gas limit for the message.\n     */\n    function _sendXDomainMessage(\n        address _canonicalTransactionChain,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal {c_0xf0dad4d0(0xdac8041c22003b18116d47ce7ee685857abb6a3894226b4f6962880270818fb9); /* function */ \n\n        // slither-disable-next-line reentrancy-events\nc_0xf0dad4d0(0x7c4d335d108c1705c0fd1e0623e144d507ac7e386b45248a6c3ab67cd1bfaa33); /* line */ \n        c_0xf0dad4d0(0x4b611821bbee327f077cdf9eab652137976613a72c5b86db257d95f7f0d4b579); /* statement */ \nICanonicalTransactionChain(_canonicalTransactionChain).enqueue(\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n            _gasLimit,\n            _message\n        );\n    }\n}\n"
    },
    "contracts/libraries/trie/Lib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x06c581f7(bytes32 c__0x06c581f7) pure {}\n\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"./Lib_MerkleTrie.sol\";\n\n/**\n * @title Lib_SecureMerkleTrie\n */\nlibrary Lib_SecureMerkleTrie {\nfunction c_0x6fee1fb5(bytes32 c__0x6fee1fb5) public pure {}\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {c_0x6fee1fb5(0xcfcbc98c7230aadc4884839366c785e6999383e4b400891780069ceb1443c9eb); /* function */ \n\nc_0x6fee1fb5(0x8f8624e9502702cb6cb6b6f11f74b909824d0c02a83fa3c4bc9e2fcf0cec3123); /* line */ \n        c_0x6fee1fb5(0x28b88fea28a614af50f398c38c94b082dad2f6175d9c8fa4d8b672fdc751fa0c); /* statement */ \nbytes memory key = _getSecureKey(_key);\nc_0x6fee1fb5(0x649868f3f1acf25a82746f04afbabb5dfafb566b74a850e8031132965d8ea56f); /* line */ \n        c_0x6fee1fb5(0x2a1a23688c44b2f8ff0bf01ff4f17d687b1d5a75e35c39f566312c79911bfbe7); /* statement */ \nreturn Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Updates a Merkle trie and returns a new root hash.\n     * @param _key Key of the node to update, as a hex string.\n     * @param _value Value of the node to update, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node. If the key exists, we can simply update the value.\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _updatedRoot Root hash of the newly constructed trie.\n     */\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bytes32 _updatedRoot) {c_0x6fee1fb5(0xedbdb00d4580b8c999d39a79ef8109dd585bd8257a3e33120c71cf87e104412b); /* function */ \n\nc_0x6fee1fb5(0x32aa73079a8b1a1bbc6b262cc6c1466117e29e8b16da33f0c7c41642f0b874fb); /* line */ \n        c_0x6fee1fb5(0x5c5367ea8d290a1efd4137f7e352f2e97e559644de022ae9e6c68878ce0268e3); /* statement */ \nbytes memory key = _getSecureKey(_key);\nc_0x6fee1fb5(0xf703f1f99bbdc8c091d4097c4243cd3d4ae583a4be111e7267f0591d3ed42c1c); /* line */ \n        c_0x6fee1fb5(0x4803c6c69dec2e0e5e932271e262812fbed73f4b117a3635a319635bb8255ea5); /* statement */ \nreturn Lib_MerkleTrie.update(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {c_0x6fee1fb5(0x973f81b1b21e11f4cf2704080d517540986d075addbc52f9364dc72d271f277f); /* function */ \n\nc_0x6fee1fb5(0xbad9ab53672bdfae28f19226ebe6a64d934c5dfde5010737712d97b7593d631f); /* line */ \n        c_0x6fee1fb5(0xbf5c9745ed1eb33a95d5de8e4609ee69f3cdca61a83b27e59f28902e25e6b048); /* statement */ \nbytes memory key = _getSecureKey(_key);\nc_0x6fee1fb5(0x87e14073f1fb685d57b0ea65675ae0f67d07f912c3596eb23a1dcee4c5d5e2ee); /* line */ \n        c_0x6fee1fb5(0xa0248a6b9e684706dd8428f0c66338abeef17d6d11eb60046bed2579efcd69ef); /* statement */ \nreturn Lib_MerkleTrie.get(key, _proof, _root);\n    }\n\n    /**\n     * Computes the root hash for a trie with a single node.\n     * @param _key Key for the single node.\n     * @param _value Value for the single node.\n     * @return _updatedRoot Hash of the trie.\n     */\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\n        internal\n        pure\n        returns (bytes32 _updatedRoot)\n    {c_0x6fee1fb5(0x6e7871bf38a10f8caab9ab7762917fe234633d92f502f7391cb023dab2960a69); /* function */ \n\nc_0x6fee1fb5(0xfe33844ca9898ae7ab21cfbce806cb988955860ff798690f660b07288bc7b345); /* line */ \n        c_0x6fee1fb5(0x1176c13253054b55d4780001231548edcc0ad6f283f950109c5c8d546c3a6cc7); /* statement */ \nbytes memory key = _getSecureKey(_key);\nc_0x6fee1fb5(0x3b10db96f4d7a106e66c7afd688bffe538911896e9e0cedca9b65bed66b3088a); /* line */ \n        c_0x6fee1fb5(0x4f9d814694490099adaf97306a8a4072f226821ee6dfd7f8026bc7aa0dfec0e6); /* statement */ \nreturn Lib_MerkleTrie.getSingleNodeRootHash(key, _value);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Computes the secure counterpart to a key.\n     * @param _key Key to get a secure key from.\n     * @return _secureKey Secure version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {c_0x6fee1fb5(0x2617bdebabf7cd3925e36b12ecbef57b5de782535aea2f051ee94c0f09abf201); /* function */ \n\nc_0x6fee1fb5(0x9a95170ae9d7c18b09d2e05a321753e4e43aea9bd658d2cd98e2d1e8a5f7a292); /* line */ \n        c_0x6fee1fb5(0x4e8ccee97f4c3f49989a1e48d4c846127ecdce33d6e103c9dbf0a2f1dd09ea26); /* statement */ \nreturn abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/libraries/constants/Lib_DefaultValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x5fa14fd0(bytes32 c__0x5fa14fd0) pure {}\n\n\n/**\n * @title Lib_DefaultValues\n */\nlibrary Lib_DefaultValues {\nfunction c_0x9a353d01(bytes32 c__0x9a353d01) public pure {}\n\n    // The default x-domain message sender being set to a non-zero value makes\n    // deployment a bit more expensive, but in exchange the refund on every call to\n    // `relayMessage` by the L1 and L2 messengers will be higher.\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x2fae8a96(bytes32 c__0x2fae8a96) pure {}\n\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\nfunction c_0xde244f4a(bytes32 c__0xde244f4a) public pure {}\n\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "contracts/libraries/bridge/Lib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xe41754dd(bytes32 c__0xe41754dd) pure {}\n\n\n/**\n * @title Lib_CrossDomainUtils\n */\nlibrary Lib_CrossDomainUtils {\nfunction c_0xac702f00(bytes32 c__0xac702f00) public pure {}\n\n    /**\n     * Generates the correct cross domain calldata for a message.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @return ABI encoded cross domain calldata.\n     */\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) internal pure returns (bytes memory) {c_0xac702f00(0x3d0a107d0483380afd6bb646836652ae20b95245deb21895ea1b74368fe319ba); /* function */ \n\nc_0xac702f00(0x35901d6f283ec9a0898b3697fc46518b03074b7da9e1875995ce64a2183f3a9d); /* line */ \n        c_0xac702f00(0xebb6b014bc361f47bc6793f3a26fd318a93f740396a2e896f02bba61f6cab4e5); /* statement */ \nreturn\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _message,\n                _messageNonce\n            );\n    }\n}\n"
    },
    "contracts/L1/messaging/IL1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x05e8ffda(bytes32 c__0x05e8ffda) pure {}\n\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL1CrossDomainMessenger\n */\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    struct L2MessageInclusionProof {\n        bytes32 stateRoot;\n        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\n        Lib_OVMCodec.ChainInclusionProof stateRootProof;\n        bytes stateTrieWitness;\n        bytes storageTrieWitness;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @param _proof Inclusion proof for the given message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    ) external;\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _sender Original sender address.\n     * @param _message Message to send to the target.\n     * @param _queueIndex CTC Queue index for the message to replay.\n     * @param _oldGasLimit Original gas limit used to send the message.\n     * @param _newGasLimit New gas limit to be used for this message.\n     */\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _oldGasLimit,\n        uint32 _newGasLimit\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/libraries/trie/Lib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x44ec31c2(bytes32 c__0x44ec31c2) pure {}\n\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_MerkleTrie\n */\nlibrary Lib_MerkleTrie {\nfunction c_0xd5aef18d(bytes32 c__0xd5aef18d) public pure {}\n\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum NodeType {\n        BranchNode,\n        ExtensionNode,\n        LeafNode\n    }\n\n    struct TrieNode {\n        bytes encoded;\n        Lib_RLPReader.RLPItem[] decoded;\n    }\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // TREE_RADIX determines the number of elements per branch node.\n    uint256 constant TREE_RADIX = 16;\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    // Prefixes are prepended to the `path` within a leaf or extension node and\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n    // determined by the number of nibbles within the unprefixed `path`. If the\n    // number of nibbles if even, we need to insert an extra padding nibble so\n    // the resulting prefixed `path` has an even number of nibbles.\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\n    uint8 constant PREFIX_LEAF_EVEN = 2;\n    uint8 constant PREFIX_LEAF_ODD = 3;\n\n    // Just a utility constant. RLP represents `NULL` as 0x80.\n    bytes1 constant RLP_NULL = bytes1(0x80);\n    bytes constant RLP_NULL_BYTES = hex\"80\";\n    bytes32 internal constant KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {c_0xd5aef18d(0xb12699b1f63493795dff079034a0313c56230b82e3749f7939c4bd8381c75e0a); /* function */ \n\nc_0xd5aef18d(0x3dcfe1f23726c352c814b413396ee8b014ab7f63217dbed3ccf91c83f8f0ec24); /* line */ \n        c_0xd5aef18d(0xd28eb00879d9cf381ac650707539c08a948cf675a81a436728322298d8074b45); /* statement */ \n(bool exists, bytes memory value) = get(_key, _proof, _root);\n\nc_0xd5aef18d(0xac5600832447b92bcf17ed37eeeeebae7f2d9179513f14df0cb27bc66b5c02d4); /* line */ \n        c_0xd5aef18d(0x4508745d5852e6d3e6f18ec3d5870307ca05f4be03072c0a4aafb6f6e1026cad); /* statement */ \nreturn (exists && Lib_BytesUtils.equal(_value, value));\n    }\n\n    /**\n     * @notice Updates a Merkle trie and returns a new root hash.\n     * @param _key Key of the node to update, as a hex string.\n     * @param _value Value of the node to update, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node. If the key exists, we can simply update the value.\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _updatedRoot Root hash of the newly constructed trie.\n     */\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bytes32 _updatedRoot) {c_0xd5aef18d(0x393b0ba09c645aaf6694df618946fc4d300a6cd01121d9bf13e8d40f05e0ba99); /* function */ \n\n        // Special case when inserting the very first node.\nc_0xd5aef18d(0x9c0814d77fce64c776a6dd68a10d2da1275c046a9c27f89a7048bbf6bd1f461a); /* line */ \n        c_0xd5aef18d(0xeac23059e63f7989845708ed11258fde1b2f5071666f252690c1918378203b5d); /* statement */ \nif (_root == KECCAK256_RLP_NULL_BYTES) {c_0xd5aef18d(0x1499f9fb526238c5553448bfbd4e42f4f55d9bbd8b756f5c946fa95853a5ce4f); /* branch */ \n\nc_0xd5aef18d(0x006fdee7c58bf397c326bf51002a1030291d8980fc7c5d6def49386061778110); /* line */ \n            c_0xd5aef18d(0x2b8ebaa101369e543e4b05d88c911d5ae2a3fbded47190ec9d9f179bb20c7d54); /* statement */ \nreturn getSingleNodeRootHash(_key, _value);\n        }else { c_0xd5aef18d(0xf31ac91403bfa8bac6e132871a445969f432532b055dacc9f80131d2492990af); /* branch */ \n}\n\nc_0xd5aef18d(0xe7f18eacdf02a46aa74f49aafd888800a243a2564ad0a1754b32997697545623); /* line */ \n        c_0xd5aef18d(0x435b1574afe80c502d8bf696d1c2677123621bc409d92b5d5f4b591b69b60cc5); /* statement */ \nTrieNode[] memory proof = _parseProof(_proof);\nc_0xd5aef18d(0x28d3a75bc5922491c377a9fd64dbb8e7c7437c33b786c0d3d3ed5933fa70ce54); /* line */ \n        c_0xd5aef18d(0xad231101fccbaa7289c50b4cf960672a871bdf7cd47face57a241c9d2b021cb2); /* statement */ \n(uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);\nc_0xd5aef18d(0x7031878a14a13b0d8b09e959835ff34fea4793937e89558b0309ba3c4ba1ccd5); /* line */ \n        c_0xd5aef18d(0xdfa5e3a5729fe8514ed898c4d8444bbaa6c840a1faa6890b4a44a61d151aa82d); /* statement */ \nTrieNode[] memory newPath = _getNewPath(proof, pathLength, _key, keyRemainder, _value);\n\nc_0xd5aef18d(0xebce711ac66d3aea3f7aaf1247bf9d46aa2754b96d542d536378fac33b71d941); /* line */ \n        c_0xd5aef18d(0x7acf4555d1047e3edcaf4713a1a9d29c3b1c36b558e3d615c79b26e99689ba29); /* statement */ \nreturn _getUpdatedTrieRoot(newPath, _key);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {c_0xd5aef18d(0x028b3e39945807b681688e572f28c97537f048d1cc7b288260f2843f5d6bb890); /* function */ \n\nc_0xd5aef18d(0x3451b9655a7cb14d5a46a90d21d9e48885a7e05759a7f06e7b7c60cec103d3c5); /* line */ \n        c_0xd5aef18d(0x8123de7a181e6af4a6ee26cea2ef3ba2551b83d1904249a22278d7ac5bb4914c); /* statement */ \nTrieNode[] memory proof = _parseProof(_proof);\nc_0xd5aef18d(0x63b575abc94626ff62d2176bb1fd32578d8c2521deef65c2a74e7bc0646357f8); /* line */ \n        c_0xd5aef18d(0x837f089386c83c53d36f9d5dbcbb06382a14896f72a2282cd8dc849449526b6a); /* statement */ \n(uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\nc_0xd5aef18d(0xbbd5ab24f530d863154921c5ffabb1a4cfd6c4c74554f5f5d54f435ab201cb7e); /* line */ \n        c_0xd5aef18d(0x2a5ef1558b26f6bda2cd20a10442a9b00e57bdff81f51234c9f802ad87322f96); /* statement */ \nbool exists = keyRemainder.length == 0;\n\nc_0xd5aef18d(0x74e7386f652d9cb328b033ed1ab3e162ef57eaa81f49abc4615401a4d5ca8ee5); /* line */ \n        c_0xd5aef18d(0x5dedca9007c4e6daad21b0a7a680cd0ec45fe3ad3d81df1d796ab22c969b5630); /* requirePre */ \nc_0xd5aef18d(0x10f1cb3c495558183a509e3253435322f08d74285add17f094ad8a93147abe19); /* statement */ \nrequire(exists || isFinalNode, \"Provided proof is invalid.\");c_0xd5aef18d(0x99c6c3530b756894221f1e020840eb9afec0030ed5d93f4f721c0da945f28bf7); /* requirePost */ \n\n\nc_0xd5aef18d(0xc423a3520cd2651d8569627688b38e1d4a45c5f7af93b0c915ecb78fd2f3adff); /* line */ \n        c_0xd5aef18d(0xe0ae80afd1faa04c7f4925859e433b81f89b63abf1df539be68a637210f569d3); /* statement */ \nbytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\nc_0xd5aef18d(0xcd873f541b6deead7f31786a76f730b171c1ba307fa743b4d9fb04ee0f6d9e86); /* line */ \n        c_0xd5aef18d(0x14213b8159add3ece51db2c6b33149fd2768d1ce71f71cd49bd8a64dc9427a50); /* statement */ \nreturn (exists, value);\n    }\n\n    /**\n     * Computes the root hash for a trie with a single node.\n     * @param _key Key for the single node.\n     * @param _value Value for the single node.\n     * @return _updatedRoot Hash of the trie.\n     */\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\n        internal\n        pure\n        returns (bytes32 _updatedRoot)\n    {c_0xd5aef18d(0xfd49054b8934fc65088e3eee8e130380c12ae0a4f6918cbfc5bc59737335fcbc); /* function */ \n\nc_0xd5aef18d(0xee5c2c082e0c22da3b83254ececcbfe5cfa71ed0a4480ce558b0ca53031a929d); /* line */ \n        c_0xd5aef18d(0x912f6674b5abfe96ecc749b9ccf7693524e408755321ecb9cc628eaa7867bab9); /* statement */ \nreturn keccak256(_makeLeafNode(Lib_BytesUtils.toNibbles(_key), _value).encoded);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     * @param _proof Inclusion proof to walk through.\n     * @param _key Key to use for the walk.\n     * @param _root Known root of the trie.\n     * @return _pathLength Length of the final path\n     * @return _keyRemainder Portion of the key remaining after the walk.\n     * @return _isFinalNode Whether or not we've hit a dead end.\n     */\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256 _pathLength,\n            bytes memory _keyRemainder,\n            bool _isFinalNode\n        )\n    {c_0xd5aef18d(0xe1f611f601ffb82d503f3ce47328aedfb02df30b45ed102d7d00c39a4c896d7b); /* function */ \n\nc_0xd5aef18d(0xad834a9d02d83bbb854ec9588dd2b5b82d7a29e6ea3def8308b7799a217c99d9); /* line */ \n        c_0xd5aef18d(0x048ccfa6ded2fbb8becfa862d5eee4eaa96501d3705731fe05e004714380264a); /* statement */ \nuint256 pathLength = 0;\nc_0xd5aef18d(0xcebe34fe161170bd413954fb4e71b48f7f84068f19651cc011d987c230c45693); /* line */ \n        c_0xd5aef18d(0x27a90ad0cbe12afdd2be76305607d962d10994c75d4cac10b256c8caadac7cef); /* statement */ \nbytes memory key = Lib_BytesUtils.toNibbles(_key);\n\nc_0xd5aef18d(0xc691e79a218b4db999f9fff5b7ca1bc9844c65c4a89a2af996fd490ef6c1736e); /* line */ \n        c_0xd5aef18d(0x366dfc1d22f145aa4f21f8003abe5fc8b40ae56ade24cd5c29fee131d94f9008); /* statement */ \nbytes32 currentNodeID = _root;\nc_0xd5aef18d(0x6cde4de3b7bb5a375ed680052d64b340a9588d75200c766ae66167aa788323ee); /* line */ \n        c_0xd5aef18d(0x8c6f94520ed1da23e491553d86859fb4b9811544ba10374c9a42767c892365ef); /* statement */ \nuint256 currentKeyIndex = 0;\nc_0xd5aef18d(0x968f3592853d117b19991cfce06edccd216ab57a89b17c20e7160e91c257ca8e); /* line */ \n        c_0xd5aef18d(0xfd8c1ba53d0ed8bc54300a122bbb924ce9c2ed9b4292110c1691a5293f5e0bbe); /* statement */ \nuint256 currentKeyIncrement = 0;\nc_0xd5aef18d(0x90bc93c8f763ad80ac03f7f1219093aa3f5676a067f53131e56714439899e856); /* line */ \n        c_0xd5aef18d(0xc005748528502c66e86212e9529353a648d41f89336004e27808dde6cbc4e96f); /* statement */ \nTrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\nc_0xd5aef18d(0xb478606a0c3f2b07e69c0436eaa8b2fd80c299c1e6f7fb9ad44755866dff8e51); /* line */ \n        c_0xd5aef18d(0xdc357359d56d1319960c79d39a45db6d5bfa9c15e5d386676878b97f32ac9aad); /* statement */ \nfor (uint256 i = 0; i < _proof.length; i++) {\nc_0xd5aef18d(0xdda3f4bfba50141e269b9f920f0c7c3e7941aa35fadba295215aeb0da34be7ac); /* line */ \n            c_0xd5aef18d(0x86ca88899034ed4888130ccdd38aac7dda4f434326f3764249db0b9f5ed303b5); /* statement */ \ncurrentNode = _proof[i];\nc_0xd5aef18d(0x1ac6ad52eb84e17b4c9e927c411aaf2d4f87b26c6657c8f430ac5360444436a2); /* line */ \n            c_0xd5aef18d(0xa0d1ac6fd2bc18b939c9b7c3c934ccf99f9eb3bb0863f729c2ca9194d0e12e7a); /* statement */ \ncurrentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\nc_0xd5aef18d(0x2381ffee746626208378d59caf9cae491d3b16c442ac02d75f28fc3fa6870162); /* line */ \n            c_0xd5aef18d(0x2269eadb376a53d4ccc81325e3dc3ac1ac6d46c406b4455a9a2d69989bd24827); /* statement */ \npathLength += 1;\n\nc_0xd5aef18d(0x4ac8002c6e357579cc5959f23e440cd114ead5cbf8282fd37f3372e1bac9edd5); /* line */ \n            c_0xd5aef18d(0x749c3232eb6f0a5f6698636f2005339b1c85d735dcf8341985389127e197d456); /* statement */ \nif (currentKeyIndex == 0) {c_0xd5aef18d(0x01a5801f984b15eb683d27870439b8d7bf8b4c18656b8d0830d9ecf6170ee99a); /* branch */ \n\n                // First proof element is always the root node.\nc_0xd5aef18d(0x4d954576745d33dc86dfdad64304aac204a1a33a4274f5831ee84e4d58a4b302); /* line */ \n                c_0xd5aef18d(0x1b998a1f98b10c8abac70d3099c1d3f60dcbe94dee49a5d35b7f10bacc5107e9); /* requirePre */ \nc_0xd5aef18d(0x3005f3a73b9147b3427129b79e518e6cc4dfb636468552ac0d81a37e97684bbc); /* statement */ \nrequire(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");c_0xd5aef18d(0xc50160289780bbcde1cb169b5ad6f8ba3eadffa1694b8284a1daf3bb56f4b586); /* requirePost */ \n\n            } else {c_0xd5aef18d(0x9cf2c41730f9353f1cafbf5d42fae34fcd3ef3ed0eb0140399c5f6f5f9ec1368); /* statement */ \nc_0xd5aef18d(0x6c781e55f115260aa16c394f321eb1d6dc3f31620614f9d9f51ee548d8aa98cb); /* branch */ \nif (currentNode.encoded.length >= 32) {c_0xd5aef18d(0xfaac906cf77a3cd812a2c6a64d4afc2a7bd29cfc69c63a803f71ff62c200b390); /* branch */ \n\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\nc_0xd5aef18d(0x589b616de1cc6aeab7c730b21763fb92fbeab60e5793242dd0512c0d41555bb0); /* line */ \n                c_0xd5aef18d(0x96477126e72aa5c97a78a94313712219eab9a7ae22acf60a9f0aac2d2e3a8c27); /* requirePre */ \nc_0xd5aef18d(0xdde6694f633ca62f58510cf6d83afc57f396584eda8ad7aa04a1e21fadaa808c); /* statement */ \nrequire(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid large internal hash\"\n                );c_0xd5aef18d(0xac9832cdd2dc8a94c392cde1b7597dc301c3cab509b371f0fed6e418e53d4a77); /* requirePost */ \n\n            } else {c_0xd5aef18d(0x5f726cd015ea32e436ee329e2b56058a67a0d34d75a418663c0c33af3060e9e4); /* branch */ \n\n                // Nodes smaller than 31 bytes aren't hashed.\nc_0xd5aef18d(0x2f9dc02e02167e0f1b2ec40d8e92019062083537923954b856a63905bc1653fc); /* line */ \n                c_0xd5aef18d(0x8b6789fe0445fac8205364f35eb47da495742b5fc5311d1eed834bad096a137d); /* requirePre */ \nc_0xd5aef18d(0xb1c97c79499b47a389bd4d2a765e2cd1cd923057212d5cdab8658c49b3604888); /* statement */ \nrequire(\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\n                    \"Invalid internal node hash\"\n                );c_0xd5aef18d(0x70085a6646ef972de2f5807d937f1ad63fd0404243c9f992f8af56134bdeb38a); /* requirePost */ \n\n            }}\n\nc_0xd5aef18d(0x4e2f0681f0adad54fa7fcd7ec71df84a4c294cae1084b9f3251b428406051428); /* line */ \n            c_0xd5aef18d(0x325175ea3f22da17eb79c0d54df5f79e0e99df633278f658665e88a7446ec220); /* statement */ \nif (currentNode.decoded.length == BRANCH_NODE_LENGTH) {c_0xd5aef18d(0x33f7be3aa1b9d4bc7df523ec72381e281d71f50f74ba99dbc2d915fcd23590ff); /* branch */ \n\nc_0xd5aef18d(0x6f9e99f99b91369e351d59cf6174b95266b1ba788ee47029e40a472ce2f2d16b); /* line */ \n                c_0xd5aef18d(0xe1f3a8ce550f92ba1e6b5a42b354b7defea4a4df87c0ae06b2216e94a2093c5c); /* statement */ \nif (currentKeyIndex == key.length) {c_0xd5aef18d(0x6b622714ce305b0531f940bb36d5ba86672498927b63f81152b880a72399ee47); /* branch */ \n\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\nc_0xd5aef18d(0x31c8d6a944b9b7140f0b95fc1fe89e1cdae696dc21a37a38eed007b56fed55a7); /* line */ \n                    break;\n                } else {c_0xd5aef18d(0xd9d2d27482a803a2491f698e00abf2d811213d3e767f7dd1bdbfd5c5830022b8); /* branch */ \n\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\nc_0xd5aef18d(0x168073860fa4b166d1f91d9840e1696d78e96fd881ba56aed8a6a5bf7375f22d); /* line */ \n                    c_0xd5aef18d(0x414b6d3809946a49b7647d7a1f58cc47b8020bf2c3065ef743f27dfeea9f43c2); /* statement */ \nuint8 branchKey = uint8(key[currentKeyIndex]);\nc_0xd5aef18d(0x15907c02eb84ee3a65d4cb1dc0447665a0a877ca5301874ea9188501b53d83ad); /* line */ \n                    c_0xd5aef18d(0xeb4ad551b4776fa9561349bd8e9143b509e0b6cf0a3b64829d0bfc9478c24252); /* statement */ \nLib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\nc_0xd5aef18d(0x4de86bd8249e9e29419b89618a50a0f4dd5b92642e7d0875b66ccfcc67970300); /* line */ \n                    c_0xd5aef18d(0x3c07ea522d61556d8a56943949c5b46d2b498838b8222c253bb278ae6e567b2f); /* statement */ \ncurrentNodeID = _getNodeID(nextNode);\nc_0xd5aef18d(0xe7dd7b514477a010e784096a66207bcbf78b26f1e3a77ae807b5c0d2b26d9c92); /* line */ \n                    c_0xd5aef18d(0x897c6c15b69ecb40b8d61e4b90f8596e96c2974eb542185c1a0e3eda7990ab5f); /* statement */ \ncurrentKeyIncrement = 1;\nc_0xd5aef18d(0xd59a8e6d38b4a189f24dc381a9a0688ac4a18184be8ff59c1f7490d04c4dc848); /* line */ \n                    continue;\n                }\n            } else {c_0xd5aef18d(0x033e800991799d1af0d8d9a9aa323f7d84940d7886e87d650d3173136cceeeec); /* statement */ \nc_0xd5aef18d(0x60eaf39fe448833fcf03d03a5a10510fcc2266f6a0f80c734529a0234d650bbc); /* branch */ \nif (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {c_0xd5aef18d(0xea7e477237a4389a21e136c22afdc42c20cb6981b5f8ad876a2929def3553469); /* branch */ \n\nc_0xd5aef18d(0x1963f785b062f4e9e1255611631565e5b52e40f4aa0c1a9ae441942a911e56ee); /* line */ \n                c_0xd5aef18d(0xf3c0a0ca28ebdb4ec6a09118e3a6f073b0e5733598709b4a9887d8a61740f0e2); /* statement */ \nbytes memory path = _getNodePath(currentNode);\nc_0xd5aef18d(0x2a470394200d5087db31bd2aef842cb7f78cf52a97efc6680dae3669f4be01c0); /* line */ \n                c_0xd5aef18d(0x9dc081e0e1e961832603dd1db26e524470b1bf8e89059a3c23699af910a2be30); /* statement */ \nuint8 prefix = uint8(path[0]);\nc_0xd5aef18d(0x7ff7de7743e4fbc4797fd368d6794aaef91aa8ccc5db71106f3c63d2f5e9ce15); /* line */ \n                c_0xd5aef18d(0x031f19fce2baf695850ed16cd51cdae0507c5e5d25f3021b38ee676ac0b4e1c4); /* statement */ \nuint8 offset = 2 - (prefix % 2);\nc_0xd5aef18d(0x7459d325f6d19ed552af3aac294c0a0583b2b5b62ff5d953957fa15cac2d5b50); /* line */ \n                c_0xd5aef18d(0x6f694ee7e5a60c9ffddaae2d5c5576e6bc3c55976d0da070340c754a12cbd42d); /* statement */ \nbytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\nc_0xd5aef18d(0x1c64d8eccb7c79105729485b0b08b167a758d8feb15f9cf9d3f181dd2d975ad8); /* line */ \n                c_0xd5aef18d(0x38322ac647467ca5ece44fd470b8af57c5e0eccec63b1acd75be1097ed15094a); /* statement */ \nbytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\nc_0xd5aef18d(0x51a7155b963acbb1532c65fb25bce2e2e8a31fa3b6e17c902db71ab07879f238); /* line */ \n                c_0xd5aef18d(0xdb789e78e9bb4f5e89deafab784c221d6ee5d5ffb37e96e8b80433e96eaf077d); /* statement */ \nuint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\nc_0xd5aef18d(0xe775534c5ba839844b929de032df6088c6161e6bc7ecbc8e9045f88a1a536cef); /* line */ \n                c_0xd5aef18d(0xd8e4c45620fa46ea1bc120aae3408cf4b3fde8c3896f9293beda0172ad737946); /* statement */ \nif (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {c_0xd5aef18d(0xcacff8be4573c8776bec67a15f89db9e3018b7838714cc9cc4f4fc8e05c8938e); /* branch */ \n\nc_0xd5aef18d(0x9d4337eb0c278304cf7bf5a04d3633fe8231c88c55fb203d6b1c80df07a550fe); /* line */ \n                    c_0xd5aef18d(0x26d0361e3972c2b68ee1d5f46c34365515684cf16caafa089c6496437c72e914); /* statement */ \nif (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {c_0xd5aef18d(0x0b453c482b0ff6b83b5e698f2a6b4875595e671f50b01fe318c5f12bd647367e); /* branch */ \n\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\nc_0xd5aef18d(0xcd56ab3a25e7e55e694c9c3c7f04646a2b63e0cdb33d2510a8286541bd9f3a2f); /* line */ \n                        c_0xd5aef18d(0xdb8cd90da256fa5405a71bfd811b17695a2235e8cc43519fc6a274eeba8af5bb); /* statement */ \ncurrentKeyIndex += sharedNibbleLength;\n                    }else { c_0xd5aef18d(0xce686660ed7a93d17ba11dee97381929e0a50370b722d3f54e7f394aa2b56c69); /* branch */ \n}\n\n                    // We've hit a leaf node, so our next node should be NULL.\nc_0xd5aef18d(0xe2b31c50f73acc6cfbabec8ad34083a7eec5a899f799fa792ff11e4275d4d55b); /* line */ \n                    c_0xd5aef18d(0xe7245db326a0a64d6f42c3cc0a3a6e81f5b08b5a27920fd78cd03e5ca84e6a8b); /* statement */ \ncurrentNodeID = bytes32(RLP_NULL);\nc_0xd5aef18d(0x5eccc8a76c0dcd019b3e9354040ceb8e36e6133af7bdc0facfaaa49bddcf8e19); /* line */ \n                    break;\n                } else {c_0xd5aef18d(0x1614b6d9b19535cbf444fcaa87c5c9be7abbe3354cbede8d9b29f13646848f86); /* statement */ \nc_0xd5aef18d(0x59f2e2f46174d8d6ce52968a35d71b13cf64183c81a679686dbf78ccf5e7285f); /* branch */ \nif (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {c_0xd5aef18d(0x0dac9491b3de8d2773b30cf474f76bcc87a4fa6ed60ff0be0a14220fce5f8339); /* branch */ \n\nc_0xd5aef18d(0x5629fb69342a43bd96558d7a850529d8ec231ed8c0941cf3a86a5b9cf31ade9e); /* line */ \n                    c_0xd5aef18d(0xe076ff1895cff2475aa8a7514d0d5d6e1910fae1b8d3d0cf3287160372cb6fee); /* statement */ \nif (sharedNibbleLength != pathRemainder.length) {c_0xd5aef18d(0x2523328e76d898bb9481b9504d91c397a3a1b453b3e17ec8d0574e460c152dce); /* branch */ \n\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\nc_0xd5aef18d(0x91e799aefa63b72aacf95fdc4dd8fb7a1e89301c1fafd36f707843fb3521fb7f); /* line */ \n                        c_0xd5aef18d(0xb5e2f19a1f217336f9e2f7565703a0a53ebbc1d77ab697ddacefc6dcedac2952); /* statement */ \ncurrentNodeID = bytes32(RLP_NULL);\nc_0xd5aef18d(0xd9489d812b5d7a474b02462b798759523aebde611812f4f16e03739a9c24917c); /* line */ \n                        break;\n                    } else {c_0xd5aef18d(0x06fd540868200ff1de115dff2fa33b034898f89d7f825b3a66b187ae7d78ed8d); /* branch */ \n\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\nc_0xd5aef18d(0x746532e96ed041f5ea408c15e8357e5290c7ee3da98c84b8d37c98d8f0cfaff7); /* line */ \n                        c_0xd5aef18d(0xea3b476c6530d943323a7a3c79194a20dc59e04d94530a275ea56df2d82a220c); /* statement */ \ncurrentNodeID = _getNodeID(currentNode.decoded[1]);\nc_0xd5aef18d(0x8bd05d419e0da18e2edd5d70dcb771783f6246edba4ce31873628dc6ebfd191f); /* line */ \n                        c_0xd5aef18d(0xfa44d5fe4c34179a5c8408c0a1112b2fd80a0357c71d35eb99ddec5bf17d2b5a); /* statement */ \ncurrentKeyIncrement = sharedNibbleLength;\nc_0xd5aef18d(0x091684ecb167008452ef0acfd14d38b0ee80a98084e074fd6806ea9516d3d15f); /* line */ \n                        continue;\n                    }\n                } else {c_0xd5aef18d(0x494035ca9e4297a30ce0f0d2a0b2b3e8a24cf8c7948966b76a7badcfe3f6b692); /* branch */ \n\nc_0xd5aef18d(0xf4a1f386f4f9bea611714ca03b13624c170453de342fb45bc7cc96da9777e534); /* line */ \n                    c_0xd5aef18d(0x2b68ce3ace81c185848a8a0c3a34af3bf6dbafd2dd1ab06963c16004aecfaf00); /* statement */ \nrevert(\"Received a node with an unknown prefix\");\n                }}\n            } else {c_0xd5aef18d(0x91e681047190d88f0bb72527c62bfdf1b8b231a2eccedc68da08b871e8af01d2); /* branch */ \n\nc_0xd5aef18d(0xdd488d9ebfab84fa6c5c33c0cfc48274d5f773a73f8ca09ce9a29f1f3a897f4b); /* line */ \n                c_0xd5aef18d(0xe9d1cfe935ede18d9da5b2030f43eccfdcf27f5450cee58a6705b096ba7a66a7); /* statement */ \nrevert(\"Received an unparseable node.\");\n            }}\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\nc_0xd5aef18d(0x7a87f96f23af5779fe0be061fe666f5fefe1f660183f09e1fbb48fd80e8059c3); /* line */ \n        c_0xd5aef18d(0xdcf76398e3b0b30ba4b60ed3646003f25a72dda5cd1c5b10b505396536ea8793); /* statement */ \nbool isFinalNode = currentNodeID == bytes32(RLP_NULL);\nc_0xd5aef18d(0x3f419a3e698775bfd6a595e7f0a8353b174c59277ea7284cb42c50a24335448d); /* line */ \n        c_0xd5aef18d(0x3a6aefd802be240b94ca8a2aaea4b226728348cc80c029e02fc8d6c134ac9759); /* statement */ \nreturn (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Creates new nodes to support a k/v pair insertion into a given Merkle trie path.\n     * @param _path Path to the node nearest the k/v pair.\n     * @param _pathLength Length of the path. Necessary because the provided path may include\n     *  additional nodes (e.g., it comes directly from a proof) and we can't resize in-memory\n     *  arrays without costly duplication.\n     * @param _key Full original key.\n     * @param _keyRemainder Portion of the initial key that must be inserted into the trie.\n     * @param _value Value to insert at the given key.\n     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.\n     */\n    function _getNewPath(\n        TrieNode[] memory _path,\n        // slither-disable-next-line variable-scope\n        uint256 _pathLength,\n        bytes memory _key,\n        bytes memory _keyRemainder,\n        bytes memory _value\n    ) private pure returns (TrieNode[] memory _newPath) {c_0xd5aef18d(0xb8af59ebcf310b54bd0f05c501ea7653e69fae0fe6ad77bf3fdc6fa31196e496); /* function */ \n\nc_0xd5aef18d(0x19dd610b2b655d3a0f2ff79d4278f9eac457bd435dee63782743379c799993c5); /* line */ \n        c_0xd5aef18d(0xa0455eaf32840fd1062518b6cea97b58b0afd23edffa64b2f9d4f01ac22cc78a); /* statement */ \nbytes memory keyRemainder = _keyRemainder;\n\n        // Most of our logic depends on the status of the last node in the path.\nc_0xd5aef18d(0x105ce5d7823f196af3790a5ec02a96ccd055374f3bb1fe0bde58314261ae3e53); /* line */ \n        c_0xd5aef18d(0xd369c19d0975da5f349c2011867ce393eda30396bc630989497171b7909e336c); /* statement */ \nTrieNode memory lastNode = _path[_pathLength - 1];\nc_0xd5aef18d(0xa1bee3403768fb0a2dbd6851329527cbd2ce0152d295db6f6b2b921e48d38316); /* line */ \n        c_0xd5aef18d(0x89bea62de9362e6effafef82e6e9bc378678070764844b2fb145f3d368467e72); /* statement */ \nNodeType lastNodeType = _getNodeType(lastNode);\n\n        // Create an array for newly created nodes.\n        // We need up to three new nodes, depending on the contents of the last node.\n        // Since array resizing is expensive, we'll keep track of the size manually.\n        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.\nc_0xd5aef18d(0x4f215776a4612f7ba2d7d7ead485ea283b78b297eb2eee6189756b4a7b12412b); /* line */ \n        c_0xd5aef18d(0xc1052336eb0bd9fe441d6b8f9872647f7ed4c1c329e6781105b874e76f46ac5f); /* statement */ \nTrieNode[] memory newNodes = new TrieNode[](3);\nc_0xd5aef18d(0x560ddccc7e4699e45fa59492e4e391959c0ba9107e866a646b55b81e330450d3); /* line */ \n        c_0xd5aef18d(0x75cecbe9d68d554534a25fd5a372f3707e1e56b28f96dc22f774c46243e8d386); /* statement */ \nuint256 totalNewNodes = 0;\n\n        // solhint-disable-next-line max-line-length\n        // Reference: https://github.com/ethereumjs/merkle-patricia-tree/blob/c0a10395aab37d42c175a47114ebfcbd7efcf059/src/baseTrie.ts#L294-L313\nc_0xd5aef18d(0xdbce11ed34692501410469f1f90f259a93fb9add28a0f0ddfe75608d13be57df); /* line */ \n        c_0xd5aef18d(0x6bcb785bd151d731afaf22b9cb0886a712c12d525ae55544ee6cce91bae3219a); /* statement */ \nbool matchLeaf = false;\nc_0xd5aef18d(0x691f17200c77d1cfda778c61a0aacf417cb8880e888db698ef925446bf17d5f1); /* line */ \n        c_0xd5aef18d(0xd85cda26115cba9bb5043124e94c248cc447abd81c6c98d5eebfc499418b3343); /* statement */ \nif (lastNodeType == NodeType.LeafNode) {c_0xd5aef18d(0x2b2c0b514097adced54ec880c837972ce503b33b9c8515bda051073b7b9853bc); /* branch */ \n\nc_0xd5aef18d(0x84538bfec59a75161210cdbf619ef4d7ca30eda121e421af5893ae2d77743316); /* line */ \n            c_0xd5aef18d(0xe0e4369e00fc5abeb51326058c4e68f7229bed124585bf1477d73e35593b8947); /* statement */ \nuint256 l = 0;\nc_0xd5aef18d(0x8427587f08ebfdb18b99b572159b1045833447f3f51b8f095b7269379792e683); /* line */ \n            c_0xd5aef18d(0x1c35ff3f53d2ee48b2ae6c6d36f6ba3002ffb3a425a080cbd1ccdf191f1db174); /* statement */ \nif (_path.length > 0) {c_0xd5aef18d(0x4d905099d671d890f4b8956f934ad514e1b12918f09a2cd2e5d7d2a6e3788559); /* branch */ \n\nc_0xd5aef18d(0xdd880cb06fde31ddba278a63e52858e5bb85433c28acd20a9a09809b697f85e4); /* line */ \n                c_0xd5aef18d(0xf5e4367693cd2d3de38650cc7d484c8610c82e47f2d1e4aaee28cf17c79dc3c4); /* statement */ \nfor (uint256 i = 0; i < _path.length - 1; i++) {\nc_0xd5aef18d(0xb02a2f615e9405e0ffae11d95bbde984ec4752e0a977334bd4192384c1ab7700); /* line */ \n                    c_0xd5aef18d(0x40e27f1c49c6d602a399dc58de7a41bdded17d3643c42d2a7beb58c56bc8e514); /* statement */ \nif (_getNodeType(_path[i]) == NodeType.BranchNode) {c_0xd5aef18d(0x8d5e62ca08a24f38aa00e9f175903bba8643d1c10cc6a5d49cffcc10477cacf1); /* branch */ \n\nc_0xd5aef18d(0xabe14ee3b70078fa42bd9b1bdba07c800a9f0d13825d1255cf52959e1b60e119); /* line */ \n                        l++;\n                    } else {c_0xd5aef18d(0xfdcf933fef705844823697af9b497dce1e16f500678061100e6d665a277dfdba); /* branch */ \n\nc_0xd5aef18d(0xff3328cd256af23d8d9a7c54daa6b1698b9e7a7dbb913e44c07f504cc5b5586e); /* line */ \n                        c_0xd5aef18d(0x13a3bc602335e066e545eda70c3657d1490989d70919eb4497d7fbb6fd77e157); /* statement */ \nl += _getNodeKey(_path[i]).length;\n                    }\n                }\n            }else { c_0xd5aef18d(0x3c4b50e2fec2e78b67d43fdf27dfe257f5db812d9cac75f494fe55a931613027); /* branch */ \n}\n\nc_0xd5aef18d(0x0753735b8c5926e26138e7b63503e49c47efd4b5c9fee64593ad78d8e5f7ab92); /* line */ \n            c_0xd5aef18d(0xa4bc0fc365a9ff12897eaca07c082c6ce29cc224a655fcdaf9a686eb5a5be45d); /* statement */ \nif (\n                _getSharedNibbleLength(\n                    _getNodeKey(lastNode),\n                    Lib_BytesUtils.slice(Lib_BytesUtils.toNibbles(_key), l)\n                ) ==\n                _getNodeKey(lastNode).length &&\n                keyRemainder.length == 0\n            ) {c_0xd5aef18d(0x5cc41b19760868824a5be15699b9f440cf511f5f9fe5b90e2c5ae3c47e39a2bc); /* branch */ \n\nc_0xd5aef18d(0x4a3a9d95abf519d50068cb4c0a75488de6bbae2e791cec26334c3bbbece8f3f7); /* line */ \n                c_0xd5aef18d(0x734ec7bfd8ff1966c0bb691f7fd390acaf82b880c7dcfd2ce5bbe4646c9d1a4b); /* statement */ \nmatchLeaf = true;\n            }else { c_0xd5aef18d(0x48d5088a7f0ac2e581bddd0bec69a1c8efd935f5b4466fe9c74a19f69655ca11); /* branch */ \n}\n        }else { c_0xd5aef18d(0x91a37a7d102ba98d34e9413a95e4709b1a0e33199c5be695ed02ceefb963eac2); /* branch */ \n}\n\nc_0xd5aef18d(0x4f69a094da39d7fbbdcf237c3abddfa2e514fee22769bbcd5136fce13e2b7b13); /* line */ \n        c_0xd5aef18d(0x77ae12bda715795ca7f240d2871fbb0e4bdc6ea918da3d74677a55030db2e9ad); /* statement */ \nif (matchLeaf) {c_0xd5aef18d(0x5dc75c02cafabf4fdcc569c41cd681f8ad6a568e49bfa2908a007d81e0570c4b); /* branch */ \n\n            // We've found a leaf node with the given key.\n            // Simply need to update the value of the node to match.\nc_0xd5aef18d(0xab24b45333ee085f48b0c48a9e2f07762e0e39d3e6418e69019969e987cc188c); /* line */ \n            c_0xd5aef18d(0x0a6c9dbac9991cb06e8e4951063d6c5406624aef8328801aa0ad21ddca7ba3ce); /* statement */ \nnewNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);\nc_0xd5aef18d(0x4477ae7a0a00418d62e69dd403637cbaa4c1da572ca596fe6d00f0bff990606b); /* line */ \n            c_0xd5aef18d(0x99c5a4a5744a51fc0e4a5811980770dfbc030b0a35375b3e57739c3621645bd6); /* statement */ \ntotalNewNodes += 1;\n        } else {c_0xd5aef18d(0x258cb3651a248b387b9cd8725a1fa1cde2e2146032169c4d504c39852d124caf); /* statement */ \nc_0xd5aef18d(0xd3d19cdf4e30e8c8c69dca837420272f27ed81a686deec14db0c6abd51ba12f1); /* branch */ \nif (lastNodeType == NodeType.BranchNode) {c_0xd5aef18d(0x00f1cf46cb3c843cc6676729541312e7eea12ec2b422a07cd12b21e27af0d96a); /* branch */ \n\nc_0xd5aef18d(0x362688fba1a94bad13e854fec8d08a1d0a50a6a618d7bf2d1896b5e2873f0beb); /* line */ \n            c_0xd5aef18d(0xaed72eb73ba4d1e807c56c68073733c6b95d5a67c97903cc48ee16aff0c15dd9); /* statement */ \nif (keyRemainder.length == 0) {c_0xd5aef18d(0xf3c1ff59d7697162b08389c30ea20a3dd8607128929f7fccce7e09ef7b7defe4); /* branch */ \n\n                // We've found a branch node with the given key.\n                // Simply need to update the value of the node to match.\nc_0xd5aef18d(0x47f4e41cb762fd86db9a514581f229abffb6ed7ef6e988f98cdc8b9cae8a3b4b); /* line */ \n                c_0xd5aef18d(0x515ca62f23506a41bed64d201103509ac9cc35d407b1a73004626da443bee5b4); /* statement */ \nnewNodes[totalNewNodes] = _editBranchValue(lastNode, _value);\nc_0xd5aef18d(0xe652323734ff3ff7b967aebde4e2700f88b72951796744d560510a4de5d766a2); /* line */ \n                c_0xd5aef18d(0xe791398e19c527072003100637fa2db87b710c252c301522821c8e56b4b47916); /* statement */ \ntotalNewNodes += 1;\n            } else {c_0xd5aef18d(0xaa41cf45d74788063725395a6284a5f735065c8bc0d99b3760c2a2203e642a53); /* branch */ \n\n                // We've found a branch node, but it doesn't contain our key.\n                // Reinsert the old branch for now.\nc_0xd5aef18d(0xd40891ef3143c31e9dbf3014af6c62227308238c59523c95883bab69fa1d5749); /* line */ \n                c_0xd5aef18d(0x57d065c931660ce0da1949542cf4896406154f8952fa4e1b170753f43968a236); /* statement */ \nnewNodes[totalNewNodes] = lastNode;\nc_0xd5aef18d(0xd8dc9d7b8828523e15723ca5188c4d3c6a06bc6095f7d19b22a38f07a18a7616); /* line */ \n                c_0xd5aef18d(0xc1937f51612ebfb0acab45737a07d9e19d6cb90ed4878f559b5b6f9bca54880f); /* statement */ \ntotalNewNodes += 1;\n                // Create a new leaf node, slicing our remainder since the first byte points\n                // to our branch node.\nc_0xd5aef18d(0xd28cd86c02ba47d5b0b129d0f78e7b730a6c28d5ffd820054241dd5292738ff7); /* line */ \n                c_0xd5aef18d(0xe4d37799b16ab76cf7b6c8f2f5c7d4e326d77ceb77d2db0f6f740b5bc1842e11); /* statement */ \nnewNodes[totalNewNodes] = _makeLeafNode(\n                    Lib_BytesUtils.slice(keyRemainder, 1),\n                    _value\n                );\nc_0xd5aef18d(0x6b876eb9458d15be0dee4f489d8c912e7bd03fc1adf726721d8162480faf284c); /* line */ \n                c_0xd5aef18d(0x86b1a63f36e4215246aba9b72d4bea256b4e1989f1621073e94bec8274763b39); /* statement */ \ntotalNewNodes += 1;\n            }\n        } else {c_0xd5aef18d(0xaa0a75e473150dae6dc32f75cbb3c7816e64aa61223c62b8548c7162a90137cb); /* branch */ \n\n            // Our last node is either an extension node or a leaf node with a different key.\nc_0xd5aef18d(0xc51cc3c570edf26249d4385b0f8d269bff660368a92f4fba68e639b7e94b6879); /* line */ \n            c_0xd5aef18d(0x2c91118bcca7172de7c38210ae66ceefb707bc395b249d5602b23c647093ad60); /* statement */ \nbytes memory lastNodeKey = _getNodeKey(lastNode);\nc_0xd5aef18d(0x1e838b61d02bb021b942f216d6a2475c42432cd654501266a76b957405504163); /* line */ \n            c_0xd5aef18d(0x87d204181f946cdc95396555c2fe84932c53c5b33e5e8864b2196b8e2b0fc103); /* statement */ \nuint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);\n\nc_0xd5aef18d(0x3332888daf5e1fdfa329c9baa1c72b114c6b3640bf6f213af6480790fc9aec39); /* line */ \n            c_0xd5aef18d(0x81e4c3bb98319d1aff35a60930fc23fc604066d24898d2d63f485fc0caf79025); /* statement */ \nif (sharedNibbleLength != 0) {c_0xd5aef18d(0x0a20e554a8159f38c3f24ab053859fc85aa3e10e858e7f84e8acfc6361e1eeed); /* branch */ \n\n                // We've got some shared nibbles between the last node and our key remainder.\n                // We'll need to insert an extension node that covers these shared nibbles.\nc_0xd5aef18d(0xf8735969ab21df4aa2e98573c5e6d3f7c432f738982594042a4e46a21bcffc3e); /* line */ \n                c_0xd5aef18d(0xf3e2eccfee38ff5a0303543d94bb620cfb615689bb4a1aa8ab0887cea4be13bc); /* statement */ \nbytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);\nc_0xd5aef18d(0x181ac40ecb282f4b45978989e945b1b4ed72c46fbf934262fcea26e5f9cdf2d2); /* line */ \n                c_0xd5aef18d(0xccad23d22232bbf6e34436d01b4e0a98e7ae24d9959541e7b30a24309b470a15); /* statement */ \nnewNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));\nc_0xd5aef18d(0x4e0799f110a8aa99398f0ccaff828e5edba124fd19712be1d3e108e3fe29427d); /* line */ \n                c_0xd5aef18d(0x2c8029b65c4d11221a1265db5ae348f226c007770ebad0e4c1316d8574914bcd); /* statement */ \ntotalNewNodes += 1;\n\n                // Cut down the keys since we've just covered these shared nibbles.\nc_0xd5aef18d(0x418b0e372b9759150c7e6e25df3374883cbd0e3281157ff129b740b973accd68); /* line */ \n                c_0xd5aef18d(0xa9b12e57928f9f3c79e5ff978218c8820f6b69cffe536dfc0f6e45438e974aaf); /* statement */ \nlastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);\nc_0xd5aef18d(0x0465659d10642ec4936515ae05482100efa483cb2d28ae883684fc7f2860d931); /* line */ \n                c_0xd5aef18d(0x3e958d86357590446bb5851da26d0cabcc4dfef8d5ad250cf93e56bf23a5b7cb); /* statement */ \nkeyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);\n            }else { c_0xd5aef18d(0x3945daecf77a3df16eaa38dc7a6f76021cbd33e25178d776d1253e306bf612f7); /* branch */ \n}\n\n            // Create an empty branch to fill in.\nc_0xd5aef18d(0x8f1b6f94c43c3d1a07521d6c5ee551cc4353c1658807a9aa74c000117c4a1b79); /* line */ \n            c_0xd5aef18d(0xc1d20ed07b59c6a9c3c0dbd706312eb9cfaa3fc8d919a14039704b44366bf445); /* statement */ \nTrieNode memory newBranch = _makeEmptyBranchNode();\n\nc_0xd5aef18d(0xd26c4641fd600b0baa94933d3145281886200e16af1dd565c439f76e6069513c); /* line */ \n            c_0xd5aef18d(0xd6be0544dfbf6a58f2810b8b190ac6edd5639fd74b7a099a70e5b5e63aa581f5); /* statement */ \nif (lastNodeKey.length == 0) {c_0xd5aef18d(0xee11712d4807573700482961255ce5a586f2d01440b884e5aecd45cbc3c9e256); /* branch */ \n\n                // Key remainder was larger than the key for our last node.\n                // The value within our last node is therefore going to be shifted into\n                // a branch value slot.\nc_0xd5aef18d(0xd474781d064dd90cd7c4bd4ae2cbcec5c9624a26e411c2dd9fa03fac4e167dcf); /* line */ \n                c_0xd5aef18d(0x5b6e601b2f762555d325f934cd02e5917e157805fa80f238c4e42d96f4e325b7); /* statement */ \nnewBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));\n            } else {c_0xd5aef18d(0x6a06a4322b1c9cca72891c411814ef06cbb67668e839a6894421f6fddb4325fe); /* branch */ \n\n                // Last node key was larger than the key remainder.\n                // We're going to modify some index of our branch.\nc_0xd5aef18d(0x67fda383dcf34b6bd1c8381a937068632888ffcc91b565271dd40ff1f7ee5c8c); /* line */ \n                c_0xd5aef18d(0xde0706cd7c4aee2f353a96e5f10b453f351b382ca9733923ab1a249f42202858); /* statement */ \nuint8 branchKey = uint8(lastNodeKey[0]);\n                // Move on to the next nibble.\nc_0xd5aef18d(0xf78df7b5db0ec79057858bed37fd64353f0605b5c64a1d20f3bfe7c94314b455); /* line */ \n                c_0xd5aef18d(0x8a8dcda6b728569ce9bb9ac266bcd6322777ef3099cef1a1657be69d4c6b3327); /* statement */ \nlastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);\n\nc_0xd5aef18d(0x430527df14e7f56ffa6635d7df698e752f84bfacb2dd2470e4f168426c88cb10); /* line */ \n                c_0xd5aef18d(0x36b6cbaa98f9a58264471626378c97713311d22fd94180f9d472ad8c4c031418); /* statement */ \nif (lastNodeType == NodeType.LeafNode) {c_0xd5aef18d(0x6a74e0d0a2605853081f9e0efe4f0f67b9668e85cd7f5ae4f7f830e9ceae1c7e); /* branch */ \n\n                    // We're dealing with a leaf node.\n                    // We'll modify the key and insert the old leaf node into the branch index.\nc_0xd5aef18d(0xdda299103b07837283cc18df6c54490b4d4b9f5548f72dcb064acaa4f89ebf7c); /* line */ \n                    c_0xd5aef18d(0x1801a3809213d7104962b132bc12c570dc2bae7043e626535124f6d4462b958c); /* statement */ \nTrieNode memory modifiedLastNode = _makeLeafNode(\n                        lastNodeKey,\n                        _getNodeValue(lastNode)\n                    );\nc_0xd5aef18d(0x8a081a281c814ca5aed7fcbe20460d21ec1a6524b28460651663910854220dda); /* line */ \n                    c_0xd5aef18d(0x3d9a2e3c5237972a4ae6a83d6ea39960edf7a23f9b24d626b474b4275499efb4); /* statement */ \nnewBranch = _editBranchIndex(\n                        newBranch,\n                        branchKey,\n                        _getNodeHash(modifiedLastNode.encoded)\n                    );\n                } else {c_0xd5aef18d(0x33ff0099bbf030f533c59e336f399f8c7b3c5799c38c75ad6d7b211d0ab2e92c); /* statement */ \nc_0xd5aef18d(0x75e1c528a54925b5f5f89bb9b0e72ebfa751f703045c760d6d91632e747ec7bd); /* branch */ \nif (lastNodeKey.length != 0) {c_0xd5aef18d(0x782e82d17f79b040f1192199cd75280e0d41001b04dd99b99d5b8b31a92015d9); /* branch */ \n\n                    // We're dealing with a shrinking extension node.\n                    // We need to modify the node to decrease the size of the key.\nc_0xd5aef18d(0x2debdf640206a3c5a5d1c7ddefd115b3368ddcbe6ae4a9434c1eb01cdc35312c); /* line */ \n                    c_0xd5aef18d(0x4e94ddc29807824fd6e47fab2628ceecdf8aa53186f3d444d9a8f5fd3fbabcad); /* statement */ \nTrieNode memory modifiedLastNode = _makeExtensionNode(\n                        lastNodeKey,\n                        _getNodeValue(lastNode)\n                    );\nc_0xd5aef18d(0x900ed48494460a985b3d831c27e458db826e7672d6f3c1d7f565fc77defefbaf); /* line */ \n                    c_0xd5aef18d(0xdc96ed94cf6906932932a120d2f9f8a65f4ab83ab09fefc910764261cd46f0ca); /* statement */ \nnewBranch = _editBranchIndex(\n                        newBranch,\n                        branchKey,\n                        _getNodeHash(modifiedLastNode.encoded)\n                    );\n                } else {c_0xd5aef18d(0x5eec5fe94767c81c7efeb5d4e9d3dab571ad6e29eccfd058e1b8c1ac4ee8d7d6); /* branch */ \n\n                    // We're dealing with an unnecessary extension node.\n                    // We're going to delete the node entirely.\n                    // Simply insert its current value into the branch index.\nc_0xd5aef18d(0x396c05f514b82c8a8b43fa01938912b94888fa750d3bafadb598319ddb54ab2d); /* line */ \n                    c_0xd5aef18d(0x01434501b2df6a45f17d628c18acf618c91323c26407bf1561b956e3408a590b); /* statement */ \nnewBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));\n                }}\n            }\n\nc_0xd5aef18d(0xa5b6e6a9c14e875ad2698431ae308d66391d33722f435ae5ce7a5237e919de4c); /* line */ \n            c_0xd5aef18d(0x78d612b8433f3146b98280aeec2cce67763f65e41e9c0bd9bbec697b4a28d04c); /* statement */ \nif (keyRemainder.length == 0) {c_0xd5aef18d(0xa3ebc889451d0b677ead05659edfa68bd515aefe123226cdf66f2ffa25cbba46); /* branch */ \n\n                // We've got nothing left in the key remainder.\n                // Simply insert the value into the branch value slot.\nc_0xd5aef18d(0xfa24571e7a803c1eb59b937bfd615ea126bbe38e59e7a3f14ddf5264bbfad351); /* line */ \n                c_0xd5aef18d(0xd68b9e9db81742aaa27eb04f383f038c95eee3e5bfd5c24104675ef384149a98); /* statement */ \nnewBranch = _editBranchValue(newBranch, _value);\n                // Push the branch into the list of new nodes.\nc_0xd5aef18d(0x13e3b080191789bd36c093d4782ce1e55fe85905545e580e02559158c997fe0b); /* line */ \n                c_0xd5aef18d(0xcebbec9b657f0795ffdbb08195b5df7bc909c0a2bab2f45ea6c65052bf802055); /* statement */ \nnewNodes[totalNewNodes] = newBranch;\nc_0xd5aef18d(0x841e1d7b0dee16e4f7b7eb6aec86a8c7717f1304b3cbde572cfc8bb3a9f972ae); /* line */ \n                c_0xd5aef18d(0xa0dc51f1d28ecea83a74cc82c992806fb264a981fd8f94956f3bf352647b5cbf); /* statement */ \ntotalNewNodes += 1;\n            } else {c_0xd5aef18d(0xf4ce6c28885b10efb88ae7bd1ef7783e2bbcb5b950ca9a3c0ddc5cc8576b284c); /* branch */ \n\n                // We've got some key remainder to work with.\n                // We'll be inserting a leaf node into the trie.\n                // First, move on to the next nibble.\nc_0xd5aef18d(0x961d3fc07fd93a3e2c7dc1b96e5f6f6abcc110dfcd09fc4f69b69205cab7829f); /* line */ \n                c_0xd5aef18d(0x644d9056a9519702f5b6f4357b5db2db8584d56bb0e8c572178d50f29f6b8d9a); /* statement */ \nkeyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);\n                // Push the branch into the list of new nodes.\nc_0xd5aef18d(0x52d39d14559ec36fe4d7b67c937636b2b7fb1b572bc8861abdd621f3f45f1ad9); /* line */ \n                c_0xd5aef18d(0x93e7a4692240f3d5ab0ce526b154cb79944bf92e58acb5df2fe121a75d3dcfaa); /* statement */ \nnewNodes[totalNewNodes] = newBranch;\nc_0xd5aef18d(0x7c8eacf362fd1bb6a63f0b554e754601ef149956f354ede6fbc3354a5f5a138f); /* line */ \n                c_0xd5aef18d(0xc5c6f53f51b42f5a4ca0be7fe3b72cd7bb1fb7a862384884804cf85aadab1f68); /* statement */ \ntotalNewNodes += 1;\n                // Push a new leaf node for our k/v pair.\nc_0xd5aef18d(0xdb5a4d4932456af3e0e083b2ee410768f42453965fc692c7b5f4e198107eeedf); /* line */ \n                c_0xd5aef18d(0xea606428b4b5b2f27b743079dd1825bfe5c276c5b8b29cb32f2b517fde86a10b); /* statement */ \nnewNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);\nc_0xd5aef18d(0xb0ac5c780b87d62d3776e2dc5d47b9c977be9e00afa70adee357f4dadc66b493); /* line */ \n                c_0xd5aef18d(0x754f0e6f0620d57ba499d390594d2ef2f6448a8c10c50428c5ee6c6ce09ade72); /* statement */ \ntotalNewNodes += 1;\n            }\n        }}\n\n        // Finally, join the old path with our newly created nodes.\n        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.\nc_0xd5aef18d(0xe6fbec919f7b16c1db1f97bf7ee282a8a8457e8ab39f8998c2711096a6093760); /* line */ \n        c_0xd5aef18d(0xbfe0eda4f046304812846625c698fc5911572f7410f62f52951ab3599040ac09); /* statement */ \nreturn _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);\n    }\n\n    /**\n     * @notice Computes the trie root from a given path.\n     * @param _nodes Path to some k/v pair.\n     * @param _key Key for the k/v pair.\n     * @return _updatedRoot Root hash for the updated trie.\n     */\n    function _getUpdatedTrieRoot(TrieNode[] memory _nodes, bytes memory _key)\n        private\n        pure\n        returns (bytes32 _updatedRoot)\n    {c_0xd5aef18d(0xa66e0b4d2d1e4312fd2ab367b7c4b49be2c470f8896fad51f68890aa4c938d40); /* function */ \n\nc_0xd5aef18d(0x326d83eea499e3b404f449227d4c07133269584c23bf938bc3d72db601c2fc85); /* line */ \n        c_0xd5aef18d(0xa3bb782e0a583390460f22909d151a68fdc01970fd671a71f7619ce353f9b1ed); /* statement */ \nbytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        // Some variables to keep track of during iteration.\n        // slither-disable-next-line uninitialized-local\nc_0xd5aef18d(0x28285d5360a144f025215205344acbfcdb7d8ffc25e9bcf68e1b5dc67378f86b); /* line */ \n        c_0xd5aef18d(0x5103b6860b47375fce35fbbeb574936d0c6a4dfee06fe809484dacba97513ade); /* statement */ \nTrieNode memory currentNode;\nc_0xd5aef18d(0xee09f0086bab1069789a9718d6c2cbe3bc2f63e73976616ec4aadcb58e9886b1); /* line */ \n        c_0xd5aef18d(0x9c154a14669a309dd90756fd72c88a4ef8b40e5c371c2d3246f50903a42cea7c); /* statement */ \nNodeType currentNodeType;\n        // slither-disable-next-line uninitialized-local\nc_0xd5aef18d(0x13a97febf282a5a24b670e136c2cc9c28bd9fe7bfed8adbaeb2171b1465544fb); /* line */ \n        c_0xd5aef18d(0xaee93db5ec6a4ec49ae4ae6eb07fa0aef0077593d939613b0dfaefb29039e92c); /* statement */ \nbytes memory previousNodeHash;\n\n        // Run through the path backwards to rebuild our root hash.\nc_0xd5aef18d(0xa40808c994c828cb72e183bcbb2bc5d0f529a46b66177dcd33e17a1dbcc95785); /* line */ \n        c_0xd5aef18d(0xb0418776bb83073c7789d8d41b9dbf3c0d4564d4f4edb2ce867266d0d98115bb); /* statement */ \nfor (uint256 i = _nodes.length; i > 0; i--) {\n            // Pick out the current node.\nc_0xd5aef18d(0x6a1dfe7970622510a119f73bc70fefb05506071ae32d48619c81e3fc01ad081d); /* line */ \n            c_0xd5aef18d(0xf42474a6bbd90946ab9106fc4e1070dfe7c775cf1d6be2442eb772ad37aa46f7); /* statement */ \ncurrentNode = _nodes[i - 1];\nc_0xd5aef18d(0x80932af3736eb0495b743a057e5d90c492007b6f85eed6df538ac0204904e8bd); /* line */ \n            c_0xd5aef18d(0x37a1538cdecc71b724c7a706a34483ae0e04bdc378726d180c5b880a7872c46a); /* statement */ \ncurrentNodeType = _getNodeType(currentNode);\n\nc_0xd5aef18d(0x35d36d1fa9b388ab2392e5bb0d8c78c70d99288c8a3ed8cd4d0e6de263670283); /* line */ \n            c_0xd5aef18d(0x763eb09eb8a52cd55d51c8f33d51787b0af11e2292eac089f11b96006edd69c7); /* statement */ \nif (currentNodeType == NodeType.LeafNode) {c_0xd5aef18d(0x3fef122e1a648fa90abaad95c43b279ec41cca0206d0ef3a251e7402193f75e6); /* branch */ \n\n                // Leaf nodes are already correctly encoded.\n                // Shift the key over to account for the nodes key.\nc_0xd5aef18d(0xfd662ca7ad7c92e4678d60b5d9cafdb6f33df8dcdbb8ca57ed7b726f755d5588); /* line */ \n                c_0xd5aef18d(0x16eab91ecef728d4fcda6cb7ee4c5c248f5b2adbe52b35ed4bee7c592d8c6146); /* statement */ \nbytes memory nodeKey = _getNodeKey(currentNode);\nc_0xd5aef18d(0x320c880b0396b6028b4a8782fbaeb3d66550cc6b2f94045a735bdaa83c0daf9e); /* line */ \n                c_0xd5aef18d(0xdfd1fc4558b895ed0790403949c2b9d29d5237504c7ec85deb80d86efcc1ed62); /* statement */ \nkey = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\n            } else {c_0xd5aef18d(0x17ae5619c5201613615398c28aea7e5512f8b42d52502d388bd3a68656b466d7); /* statement */ \nc_0xd5aef18d(0x9b5155cf694440e38d464579bd2dc50316860c6c65c3a25ca9cac499c81f58a4); /* branch */ \nif (currentNodeType == NodeType.ExtensionNode) {c_0xd5aef18d(0x1939f943af7bd1d21c70d753cd1104e28b0f6978745d2a2b73ba4ccc8c9962db); /* branch */ \n\n                // Shift the key over to account for the nodes key.\nc_0xd5aef18d(0xab267496e3adf9b212c212482ee8abe179065beeb7202ab496ce644417ea0aec); /* line */ \n                c_0xd5aef18d(0x0478f141eec6b1cc4660ce0b288d9241681265310f8faf5a0f40c43169b31296); /* statement */ \nbytes memory nodeKey = _getNodeKey(currentNode);\nc_0xd5aef18d(0xf21530413c9a4f7210c3e2b2e7fcf59078742bf79623f66eb6215d93879f9013); /* line */ \n                c_0xd5aef18d(0x5faa3bbae7cad50c574a32e3f85b9e9f01e346d25ab0091e32ca50146b8cbc9d); /* statement */ \nkey = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\n\n                // If this node is the last element in the path, it'll be correctly encoded\n                // and we can skip this part.\nc_0xd5aef18d(0x997bd471847d7b5a71c2988ed872a5bcb6b681e1fcd31be428f7d2fb0e52e3bd); /* line */ \n                c_0xd5aef18d(0x1118b95e27f9ed5041e15d4c3f63a71127b390be532590fcbc4ac11858a3c9cb); /* statement */ \nif (previousNodeHash.length > 0) {c_0xd5aef18d(0x6d1350ec85b929bb36f8da2ab6674365c2bde6664beafea15fb76f21a50b348e); /* branch */ \n\n                    // Re-encode the node based on the previous node.\nc_0xd5aef18d(0xd7477d3e96a1656009c44223d5da5d8e9fcb00d175e3db3a10eff7cba244ea9b); /* line */ \n                    c_0xd5aef18d(0xa493933dcff4b91ac5562b302d95dd330af2ffed63f6aa362880828275b40a0e); /* statement */ \ncurrentNode = _editExtensionNodeValue(currentNode, previousNodeHash);\n                }else { c_0xd5aef18d(0x1fce6d5e4246115be9bba62d51939e35411215b792b588bbded80287585b873b); /* branch */ \n}\n            } else {c_0xd5aef18d(0xe24fa2f5c2eff812c4c4020f2d3651edc71cb0c5a0f799c94b5fe243b6871907); /* statement */ \nc_0xd5aef18d(0xb5d0f444335cf875b83e63e15082008610e3acbaa0332f2bd27413f247871309); /* branch */ \nif (currentNodeType == NodeType.BranchNode) {c_0xd5aef18d(0x841ee6a8eb8f0069ee0e2e5c1a82ec8a45fb619f9d70e7fad2539e4b3d36764a); /* branch */ \n\n                // If this node is the last element in the path, it'll be correctly encoded\n                // and we can skip this part.\nc_0xd5aef18d(0x6c5afd7d7c9ad92000d34728dfb63befda4893d1501b35065e8c59c306285b4e); /* line */ \n                c_0xd5aef18d(0x45dc7692b1d517525505f8b7a124dbc5db11b4a4c4c95283519d87bf03718048); /* statement */ \nif (previousNodeHash.length > 0) {c_0xd5aef18d(0x1cdc51e1492a49b0907428049a53b3bdd7097a323d32a4346a460b66836ecf89); /* branch */ \n\n                    // Re-encode the node based on the previous node.\nc_0xd5aef18d(0x5a2b4f38d3de5b32bf78b56d7cf047c80dda667d807213c1a7756ba1a80be907); /* line */ \n                    c_0xd5aef18d(0x35b6f8a1f68709b2ace4b9a319111d4c94e3ace5515daed3c86b8ef2f1b76b29); /* statement */ \nuint8 branchKey = uint8(key[key.length - 1]);\nc_0xd5aef18d(0x5414f8ef31e5c2119efa2515cc4b8d2d372d4259db09a31f9b86c5791a91bd43); /* line */ \n                    c_0xd5aef18d(0x8b90a52c803847b6939cd416e7c288910f3d2f3b763fcd24705be1cf45e7246e); /* statement */ \nkey = Lib_BytesUtils.slice(key, 0, key.length - 1);\nc_0xd5aef18d(0xc413897b7d8332a8173ea365a3d32b6b08d7b0b52fa84815c9b7a61d5df6255e); /* line */ \n                    c_0xd5aef18d(0x57716ab4b95714a18cf1c49a27e53c74d9d16c14e8e7c98e7b6526ce6ff2ab29); /* statement */ \ncurrentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);\n                }else { c_0xd5aef18d(0x324e4795109da4b54260e657d7ac6202794006dd1a972ce0103294b9762b20f1); /* branch */ \n}\n            }else { c_0xd5aef18d(0x4c53a4a916843facd9d400c28534869bc1e30b010ebeda23f8c53517e402f11c); /* branch */ \n}}}\n\n            // Compute the node hash for the next iteration.\nc_0xd5aef18d(0x2df6abd871c675ef2ef3a7f1faa661ec34b212ce1f1e3f61102b994cd6936890); /* line */ \n            c_0xd5aef18d(0xba823c9b277082414e0fa9404134eba2b884e330accf9746dc7a32fdb0e91e35); /* statement */ \npreviousNodeHash = _getNodeHash(currentNode.encoded);\n        }\n\n        // Current node should be the root at this point.\n        // Simply return the hash of its encoding.\nc_0xd5aef18d(0x02bbab524ccdff76f7f613a7dd6bf2490f1fc72992349c7db63fa2eb6966c8a2); /* line */ \n        c_0xd5aef18d(0x5b952d3d0abbba40a0cea982b0c076f5f87c1d8d605b95a0aa2338114aeff4fd); /* statement */ \nreturn keccak256(currentNode.encoded);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     * @param _proof RLP-encoded proof to parse.\n     * @return _parsed Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {c_0xd5aef18d(0x57fe8fbe6ddbcea80048defb0d93758ac44966dbce158bb6166852e2600852ff); /* function */ \n\nc_0xd5aef18d(0x9c4d48777d4a7db4641537ae160ce5ff113149d7b474d1adcbdf0f6552bd69f9); /* line */ \n        c_0xd5aef18d(0x68acb920bbdbca4e7a6afecb05496ffd921d98742f59c1effccc511cf60d6559); /* statement */ \nLib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\nc_0xd5aef18d(0xd66deeeaa30cf461b6d3b7500c0412271c66ea715db76e9bc61127d28c3ae734); /* line */ \n        c_0xd5aef18d(0x0ca895c7eb191cdca6a078192931d1606c265c98de2eddbf305abfba665ef26a); /* statement */ \nTrieNode[] memory proof = new TrieNode[](nodes.length);\n\nc_0xd5aef18d(0x7336a90a3db787a5125e6ca366405285950663ee724d7997b6fdcd12cf547e21); /* line */ \n        c_0xd5aef18d(0x9929b3ced808fa880b774fedd35e221cde663d6560211d642bf858648350dd40); /* statement */ \nfor (uint256 i = 0; i < nodes.length; i++) {\nc_0xd5aef18d(0x822b95b0cc138902dba5a925e05ae7657e8e8dec7f69ded39db44b47c38a4c0b); /* line */ \n            c_0xd5aef18d(0xdafae0c06f90626a50db9f7be479502aa8a1121c22fc899d6f27e95f6f31a38f); /* statement */ \nbytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\nc_0xd5aef18d(0x4fe0e4612bbbccbc4095176779bbefe39a81c37c66474f808709843cc58bb560); /* line */ \n            c_0xd5aef18d(0x6f54e0684c62dd84aa3b990cf7ffac74fceefdf28b7deb2d163339a9c29a6f9e); /* statement */ \nproof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\n        }\n\nc_0xd5aef18d(0x5009049ada51c0ac91086a11f1753a07ddb32e195766d810aaf56c0743af0c6d); /* line */ \n        c_0xd5aef18d(0xd9745d71ed7c68258d1dd04c9468414ab5949f0fb47301eb6d66a1120f830896); /* statement */ \nreturn proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the\n     * \"hash\" within the specification, but nodes < 32 bytes are not actually\n     * hashed.\n     * @param _node Node to pull an ID for.\n     * @return _nodeID ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {c_0xd5aef18d(0x71b7f4bb91acb1f4d50840bb6667919f322331a9172091be313a53c3d7870bd6); /* function */ \n\nc_0xd5aef18d(0x4bdcc7a4b74813208edebe8e8bdb3c81c91d1a4febe1d2a0131d1f3b2f08fb55); /* line */ \n        c_0xd5aef18d(0x99fe52e1db2c17889974a0ebaaf46d05dcdf8d6c93a26c3ea3e100665f0f3f31); /* statement */ \nbytes memory nodeID;\n\nc_0xd5aef18d(0x81eb764a8c40e545de01bf98ce82bc92a65aa9ccdfd2b8c16355163680a41f5d); /* line */ \n        c_0xd5aef18d(0x4e1c65ecd3feee07b040bec4f5338e9a5868ca9eeb1cccfe89fb110ba90c2975); /* statement */ \nif (_node.length < 32) {c_0xd5aef18d(0xbf63af7892249b90727d54dbbc8abfc3fcf9d8ea8706d4d215f7bab88f1fda42); /* branch */ \n\n            // Nodes smaller than 32 bytes are RLP encoded.\nc_0xd5aef18d(0xdbfbdb662a6f9aa01433da898084d1f59539691176e68e4189ee0de750c23817); /* line */ \n            c_0xd5aef18d(0x72d7f727b6ca4f7427663140714a6934d7845e2bb55c020e11ef4719591171b9); /* statement */ \nnodeID = Lib_RLPReader.readRawBytes(_node);\n        } else {c_0xd5aef18d(0x5d76ecf4e34540c91ffa4a03f969c7e193eab142df052fc59c919de257feda3f); /* branch */ \n\n            // Nodes 32 bytes or larger are hashed.\nc_0xd5aef18d(0x6bdf473738f03e643b2d7e50bf7e5c26cc2fe65c26bb38641453072c6ab6260c); /* line */ \n            c_0xd5aef18d(0x366eca2415a49ff3f797d1d367cba923d0bee5733ef76cb74ccb962bb105a9ab); /* statement */ \nnodeID = Lib_RLPReader.readBytes(_node);\n        }\n\nc_0xd5aef18d(0x7a3632db832a47f5485df893eab9a25272ba73e7f2df67eabe7a1cd325af7ab5); /* line */ \n        c_0xd5aef18d(0x7feae6804363c1c08b7bf06284b3d8933c3cd3df6b349f4285e4aa77f4cdc7da); /* statement */ \nreturn Lib_BytesUtils.toBytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     * @param _node Node to get a path for.\n     * @return _path Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {c_0xd5aef18d(0x9898f92602e8377dd823ed6f94da5673df6878065a758be070af23a6c6ac10a4); /* function */ \n\nc_0xd5aef18d(0xaf15111b104ad752b4c734d04748807676a77704c49491d56c7c7687272d9111); /* line */ \n        c_0xd5aef18d(0xa39008d9da1fd7b1662fcbd26bc78640de87e85702d2be10802d0bb35eb6b9fb); /* statement */ \nreturn Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the key for a leaf or extension node. Keys are essentially\n     * just paths without any prefix.\n     * @param _node Node to get a key for.\n     * @return _key Node key, converted to an array of nibbles.\n     */\n    function _getNodeKey(TrieNode memory _node) private pure returns (bytes memory _key) {c_0xd5aef18d(0x04bc9e35876ce72ccfe980ad3541916b1ddcf2f48da7795a8820a9ff89817e8c); /* function */ \n\nc_0xd5aef18d(0xbde7d3d63d78869b23476c57e510f137c64e31f22438b5763af07019acddffef); /* line */ \n        c_0xd5aef18d(0xe519a6a653471a5beac2cd15e8b2feb7028f52e8114a5f8fb8252f0e938147f4); /* statement */ \nreturn _removeHexPrefix(_getNodePath(_node));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     * @param _node Node to get a value for.\n     * @return _value Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {c_0xd5aef18d(0xdb3283cead7cf6084fcd017e896b1b3774e855c190026d1efd16317a50de4f4c); /* function */ \n\nc_0xd5aef18d(0xd3af5d3b7b02d68385efc5d935693df4ff4dd1226ded2d8a9ebcb012429787fd); /* line */ \n        c_0xd5aef18d(0xc779e76d8e642717c6874b217334f18da5716a1e43c93b1f1cc2ea3b960c9e7e); /* statement */ \nreturn Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes\n     * are not hashed, all others are keccak256 hashed.\n     * @param _encoded Encoded node to hash.\n     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.\n     */\n    function _getNodeHash(bytes memory _encoded) private pure returns (bytes memory _hash) {c_0xd5aef18d(0xaff04292c3b79162937a4950f69bd56cbd55b11a6e984551fd94b5161122f161); /* function */ \n\nc_0xd5aef18d(0x470ea2322947703a31e35346b3c4a07e90683b5afb090311f7450c3d8c7fe658); /* line */ \n        c_0xd5aef18d(0x3b57e6c6ffdcbab998fbbe13fd5e4a19d7cc392c1ff4f6f99f9a3550082fcb75); /* statement */ \nif (_encoded.length < 32) {c_0xd5aef18d(0xacb5e2e430652f7633a166e767a107a990809757aad1029cd34148b0e7a909b1); /* branch */ \n\nc_0xd5aef18d(0xf11c94d5f94e3545be474acbb737d841a663d5c57e5eb76af6a90902a8b363fc); /* line */ \n            c_0xd5aef18d(0xb298ade1096e246f001a705033b8ae4b4ead7bb4d2a39ef0f65f7ef057dfc480); /* statement */ \nreturn _encoded;\n        } else {c_0xd5aef18d(0xac6998dcd34238c9c79566a78337eed2d9b72529568a4ddb6221dc7271ec6bac); /* branch */ \n\nc_0xd5aef18d(0x6e2748292cd4de0c09d59900dc9b8d88a4f02867a13832613cad141441d9cf12); /* line */ \n            c_0xd5aef18d(0x43c0abad1c5a8035f2d4a1247bef2ad49ed5962e995817244462f9e3ffc97ff5); /* statement */ \nreturn abi.encodePacked(keccak256(_encoded));\n        }\n    }\n\n    /**\n     * @notice Determines the type for a given node.\n     * @param _node Node to determine a type for.\n     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.\n     */\n    function _getNodeType(TrieNode memory _node) private pure returns (NodeType _type) {c_0xd5aef18d(0x4aecae9923e7ad312088160195b60c96f094203b3e53c593b18e04e5a1a9298c); /* function */ \n\nc_0xd5aef18d(0xac1da4e67bcf8ba0772f5dd9b6989f44d1a0b73f49bb2154586855803e4ecf5f); /* line */ \n        c_0xd5aef18d(0xb398005ea3720e28a2e098c1cb4c1717de14f674d66bf420c9ddfad56a9259e2); /* statement */ \nif (_node.decoded.length == BRANCH_NODE_LENGTH) {c_0xd5aef18d(0x75a34718dd9b2a5cbdeebcbb0d4db2c91a7271559076f7e62ac87da60874a3c2); /* branch */ \n\nc_0xd5aef18d(0x809827ab819fb09d5964c32d1fabedeb95a1d9174dc093072a0ea06244d26cb8); /* line */ \n            c_0xd5aef18d(0xfd3a7f983cf5ce57ede2119ae4bd1da1b9260a854c0fd432d175b7f3a7384225); /* statement */ \nreturn NodeType.BranchNode;\n        } else {c_0xd5aef18d(0x3ef6059ec4e8c22a79f513f2434ef9bb3ad90f4aa69a94840b2ad35122cf13ea); /* statement */ \nc_0xd5aef18d(0xf6aaf33ce11089ed4b7581db63a72e128d087c7acef77fc6300708284141244c); /* branch */ \nif (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {c_0xd5aef18d(0xfaa7c403f483419d9d5be2c78e214c287463c05dd46c3ca65696614417b47362); /* branch */ \n\nc_0xd5aef18d(0xd40d681b281df0c693b2dea7ed44325f22d3072a7c508edc8c7fbc70128ff72c); /* line */ \n            c_0xd5aef18d(0xb362ab7d0fe0e592c50af25683043a21b0e176eb7ea3f0dd004d1b34565f45cf); /* statement */ \nbytes memory path = _getNodePath(_node);\nc_0xd5aef18d(0xa70cd35c949493cc7fb5cee9e906e591222159e121e543bed29d183917f295d5); /* line */ \n            c_0xd5aef18d(0xb4fba571c76afbf6c26a54bc869e72dcef4713e3176ad8e3b068987ce196bd7a); /* statement */ \nuint8 prefix = uint8(path[0]);\n\nc_0xd5aef18d(0x5c310bfacd291ccc5bd51a672cb54f4ec0af39fc86a3fb6546400ad9ff624b20); /* line */ \n            c_0xd5aef18d(0xe2b32a782e24c99c31bcf60c1a1fb80d401c8dc1ac49fc5cf1a66c35be4a925c); /* statement */ \nif (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {c_0xd5aef18d(0xf1c56c17e7ddf8da84b8906a21b4e420bf26a5c2262df6fe706d88b56b9dc529); /* branch */ \n\nc_0xd5aef18d(0x69480c897172bcd0899fde1d44b901b3c318b9691e46da9f2f092cd1ea0efe6c); /* line */ \n                c_0xd5aef18d(0x369323172af852f1e96fa950e42dd051a5c4af53b6e2fc7122c7591f810c92a8); /* statement */ \nreturn NodeType.LeafNode;\n            } else {c_0xd5aef18d(0xe1a20f38fd10429c87d47569a0246b2fb4edd3067c329c92339c72cd237349b7); /* statement */ \nc_0xd5aef18d(0x39cf18825f13a9dbfb7acea12c2192422a8c25e0e1801da636cc96fb30ad8270); /* branch */ \nif (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {c_0xd5aef18d(0x58c737aeb4e7c5ce35b25c5331a336a694fcb21350d5726e01ee5d51687e35af); /* branch */ \n\nc_0xd5aef18d(0x203ba9441268b27621844e071a4ee73da9ff638e7595ef62be485152f2bead10); /* line */ \n                c_0xd5aef18d(0x91d5784e58ed685e724b4963a696cef27a6b4689e9533c94f3e3bc07b7089b60); /* statement */ \nreturn NodeType.ExtensionNode;\n            }else { c_0xd5aef18d(0x0957c0e36539435433867e398b27e97df0bbe4cad589ed07f62a52a25f06c929); /* branch */ \n}}\n        }else { c_0xd5aef18d(0xdd4b96678330cb79eb74b23f1407dfaeaf69cce34a17d101328da284f5216823); /* branch */ \n}}\n\nc_0xd5aef18d(0xe679785ceec718535aa7d564c719fa9566239aed6446f0331d02ceb821bb5ade); /* line */ \n        c_0xd5aef18d(0x2f4c2075b80f5ea080cfe05e457d4f1e309fef090c00e543b474f7bbfead93d2); /* statement */ \nrevert(\"Invalid node type\");\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two\n     * nibble arrays.\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     * @return _shared Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256 _shared)\n    {c_0xd5aef18d(0x7d17a8100b5dbfefd4263fc744c3ff78fdb2a51a99ef8b8f4bf083582e42b0c8); /* function */ \n\nc_0xd5aef18d(0x2a5975075e0cb3b5b40ca6326760cfd06f99840dbc1f0fc84a6d9bffef2d1dd2); /* line */ \n        c_0xd5aef18d(0x6d02982438f03a4fef393b8107d1ad8266315cd659fa21e3c69c0332ab013d51); /* statement */ \nuint256 i = 0;\nc_0xd5aef18d(0x92191f43770bd087aa65ecef1967c4a2a95eada27904cb367cc621101d5cd510); /* line */ \n        c_0xd5aef18d(0xfa030c90a256bc1c0d9c6844cc2499897a0d91188d3becd66ab1b0114199507e); /* statement */ \nwhile (_a.length > i && _b.length > i && _a[i] == _b[i]) {\nc_0xd5aef18d(0x335cd9286919b34852d002c6554483c6f17d49aaaad02c61fa78b69b8e8ef9ac); /* line */ \n            i++;\n        }\nc_0xd5aef18d(0x71babc40efe58cbda9a19b5a94165ca8be59fb2832c7add4b5e75ea27f1c3eac); /* line */ \n        c_0xd5aef18d(0x65161b5d99dbeeed0555cd580b10fb22104b563881a6b9a1e8bd347d431c924f); /* statement */ \nreturn i;\n    }\n\n    /**\n     * @notice Utility; converts an RLP-encoded node into our nice struct.\n     * @param _raw RLP-encoded node to convert.\n     * @return _node Node as a TrieNode struct.\n     */\n    function _makeNode(bytes[] memory _raw) private pure returns (TrieNode memory _node) {c_0xd5aef18d(0xb0bd1adad66b6b4ac3f99b2023cd9df9385a2130db27df94178b81bf90c3361a); /* function */ \n\nc_0xd5aef18d(0x32e1016366c1e88cbe62a07f9133f546d4e62b89b604da9bad84450c81311b35); /* line */ \n        c_0xd5aef18d(0x7e4b180e2ffa1cc3111c8d44a4b292cdbffaf21c8c474f610275c1bc928b331e); /* statement */ \nbytes memory encoded = Lib_RLPWriter.writeList(_raw);\n\nc_0xd5aef18d(0xb86d026822f814a1551c47b279ecb52395a004f8fc27fc57f9d5f9f455a53d9b); /* line */ \n        c_0xd5aef18d(0x892883cc9ab97d50ad51a50038d6bcad3027c035b021d7665862d2635d180224); /* statement */ \nreturn TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\n    }\n\n    /**\n     * @notice Utility; converts an RLP-decoded node into our nice struct.\n     * @param _items RLP-decoded node to convert.\n     * @return _node Node as a TrieNode struct.\n     */\n    function _makeNode(Lib_RLPReader.RLPItem[] memory _items)\n        private\n        pure\n        returns (TrieNode memory _node)\n    {c_0xd5aef18d(0x95e245442de4a8c0afb32cb98be9240da2b4bf6a24b4ac84a8da7d4af18b1ece); /* function */ \n\nc_0xd5aef18d(0xccbfaac1770ae73d3e97e5fa25313137189f2427bacee8a5e75d18f923f948cb); /* line */ \n        c_0xd5aef18d(0xc54551286b5cf1d50eea612d8e3b58c5fbb8c7013ff8b67d153f961edacb77d4); /* statement */ \nbytes[] memory raw = new bytes[](_items.length);\nc_0xd5aef18d(0x7d2c6bdc951546f142c1f9fdc2105d115d733ae1d021ada59e67bba90ebfd021); /* line */ \n        c_0xd5aef18d(0xc18308dfad72460692398a334396cdb6fe69c2c3aa671b95a7a6507eeb5b3e89); /* statement */ \nfor (uint256 i = 0; i < _items.length; i++) {\nc_0xd5aef18d(0x3f90de90c8729f33a3bcf33b53eac358c73801fee7c2bb2f1886c0cc1f01bb46); /* line */ \n            c_0xd5aef18d(0x5d354984ccdbb351b4c5ad2114c13ca966acf22f28bc9b74d86350ca741cc8a7); /* statement */ \nraw[i] = Lib_RLPReader.readRawBytes(_items[i]);\n        }\nc_0xd5aef18d(0x89394b636d7c67ed2c11891b44aa71f4ec34124b2b7e8ebe379957ce69eafa2c); /* line */ \n        c_0xd5aef18d(0x03727d88dcf6d9027cd2780e4663c7fff0cf06be6b85156241d6aa7acda5ef44); /* statement */ \nreturn _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates a new extension node.\n     * @param _key Key for the extension node, unprefixed.\n     * @param _value Value for the extension node.\n     * @return _node New extension node with the given k/v pair.\n     */\n    function _makeExtensionNode(bytes memory _key, bytes memory _value)\n        private\n        pure\n        returns (TrieNode memory _node)\n    {c_0xd5aef18d(0xfe5941f012a99153875c4aec4e783c642671219b0487e30c3d94069649a14a73); /* function */ \n\nc_0xd5aef18d(0xd25ea2cdc8d0de6049b205b734d4f12cfb1124795a40394f77fbbb351fdfd25f); /* line */ \n        c_0xd5aef18d(0x3bd55c29519a24a10c578a1ce8fff29acb565d5a6473c7b235a68ef26b5bcce7); /* statement */ \nbytes[] memory raw = new bytes[](2);\nc_0xd5aef18d(0xf3b4092a15e04826a642b0a37d40e59ec2d751bc2009c260b1c76d870967b045); /* line */ \n        c_0xd5aef18d(0xc0e9288cbb284ec18235b4b569b3b265e8c227043142a6effc3692d6b84e3cd8); /* statement */ \nbytes memory key = _addHexPrefix(_key, false);\nc_0xd5aef18d(0x61ee808ace072bc99ee1ee982d316e8b93a22c291515d4a9b2522c3a60a8d307); /* line */ \n        c_0xd5aef18d(0xeada6304831badcb7c35b3bf024139622593c0b73e31f28d0c8edc08f6733bf9); /* statement */ \nraw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\nc_0xd5aef18d(0x20caa8b33f63db4466e36327da748705635d06181c15f80c94cb25259472e6a5); /* line */ \n        c_0xd5aef18d(0x1a96cdb8284a585125cb0457b995bebfbafcf6d8ac7dc50bfab43890d5f43172); /* statement */ \nraw[1] = Lib_RLPWriter.writeBytes(_value);\nc_0xd5aef18d(0x7acc24bfb65299e62b5dbaa19c24d1b4cea077bc269a09c06718294bf767424f); /* line */ \n        c_0xd5aef18d(0x86a7a38496f7b0c5b74ff1bac48b07d3e0c44b1fc75dfe9a254419d5edc6ec78); /* statement */ \nreturn _makeNode(raw);\n    }\n\n    /**\n     * Creates a new extension node with the same key but a different value.\n     * @param _node Extension node to copy and modify.\n     * @param _value New value for the extension node.\n     * @return New node with the same key and different value.\n     */\n    function _editExtensionNodeValue(TrieNode memory _node, bytes memory _value)\n        private\n        pure\n        returns (TrieNode memory)\n    {c_0xd5aef18d(0x6a7713e36ef84df926ceec363dedf2fc9727b5bd5b5d8ecdda4a53b0645ac15b); /* function */ \n\nc_0xd5aef18d(0x6e738e2b15176953072ab7af3ad645b74c80ae4d5e73321b119f8fc1dcbcf3c8); /* line */ \n        c_0xd5aef18d(0xd06a80127fab4c1682d7f4d393665e53deb8f7d8d2f256999d4da524af65597e); /* statement */ \nbytes[] memory raw = new bytes[](2);\nc_0xd5aef18d(0x7d1c5c09eb673e9576bd1ec8bab61ddc4279e23cc268821fd220e2e54a975542); /* line */ \n        c_0xd5aef18d(0x07e62a6ad5a6235d68929414429358bca046ebc4801cf10b7eb387afcb430b65); /* statement */ \nbytes memory key = _addHexPrefix(_getNodeKey(_node), false);\nc_0xd5aef18d(0x5f05f4114ecd3b993e74c512b785a93b9192f6b1cb768bb423196d9113257b3d); /* line */ \n        c_0xd5aef18d(0x91a659c92912e45898e44225b8f14295091d595219f952cbda7bd1e0017f4810); /* statement */ \nraw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\nc_0xd5aef18d(0x8cea6780a4dca1bcf7e3a53bd1e1619212a60f307fcc687ea3e53e71cb4d497a); /* line */ \n        c_0xd5aef18d(0x9525511a1fde6a7c3640fef07e3dfdc38d9ea5e793709ce74ac2451122ff8839); /* statement */ \nif (_value.length < 32) {c_0xd5aef18d(0xe0a1655facef9cde3bc66a46956cfd02c26c53c999e54b46d57ea738eb5ca4cc); /* branch */ \n\nc_0xd5aef18d(0x21f9808030a197cf7d4bd1f14037922a17ae047eca65ec0e566cb855e856b837); /* line */ \n            c_0xd5aef18d(0xdf45140816e4cc805e7041550c6764272c29fb63e366597e556919193896cd58); /* statement */ \nraw[1] = _value;\n        } else {c_0xd5aef18d(0x6b23af1b7f8eba015c2de45f55b539787e0c31384259b5d5757ef6ad66584b6f); /* branch */ \n\nc_0xd5aef18d(0x8610678d31dd7766edc53bd84d0520c3e18a8f7cac1d7934eeeb9923edaa1976); /* line */ \n            c_0xd5aef18d(0xc278ddfdeaf2c63077153d41edd5dab8734693d2ff8ef0aea060bf40c8e15bd5); /* statement */ \nraw[1] = Lib_RLPWriter.writeBytes(_value);\n        }\nc_0xd5aef18d(0x617fa3971871b0dde56f1265d20816de1de9ebc4af48faf559cf91116bf22c1a); /* line */ \n        c_0xd5aef18d(0xa3c2e2aa32b878bd7b9bdafae293fb332648617104c2443900c82c3e515005ba); /* statement */ \nreturn _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates a new leaf node.\n     * @dev This function is essentially identical to `_makeExtensionNode`.\n     * Although we could route both to a single method with a flag, it's\n     * more gas efficient to keep them separate and duplicate the logic.\n     * @param _key Key for the leaf node, unprefixed.\n     * @param _value Value for the leaf node.\n     * @return _node New leaf node with the given k/v pair.\n     */\n    function _makeLeafNode(bytes memory _key, bytes memory _value)\n        private\n        pure\n        returns (TrieNode memory _node)\n    {c_0xd5aef18d(0x2f4a830f854319d5beccaa2f7e4f05d95f5ae0994ac7e7ed475c4af1b67060b7); /* function */ \n\nc_0xd5aef18d(0x5583a82d8e9698cde13ffabec72fdac318c2aa76b0df406b93bdd8022aae628b); /* line */ \n        c_0xd5aef18d(0x200f883c51008835683faea391084ba1d4d4712c58eade791f54e67e2de5fa3c); /* statement */ \nbytes[] memory raw = new bytes[](2);\nc_0xd5aef18d(0x40db2876d9c0f66f6ba0f39dd77609639ffb0cd7b3466d3559a3aea71c7042c0); /* line */ \n        c_0xd5aef18d(0xbf8f5903e01da03d24140cf4d77d25973162930827371e24dcecfbc0a84866a1); /* statement */ \nbytes memory key = _addHexPrefix(_key, true);\nc_0xd5aef18d(0xd40724ca383121eaf49c25a7fbfe776cc87d1d318934a3b4724858fd8c9d4489); /* line */ \n        c_0xd5aef18d(0x5ae90608709846df530d745ed3378e1045285e0cde6962dc67652a3a2e2f4c08); /* statement */ \nraw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\nc_0xd5aef18d(0x4cb9057412b2da882bc9237e620209755f1f3ee3f510af50d1949877198f0d83); /* line */ \n        c_0xd5aef18d(0x59063a0911609319c7e9e6e5f2d6ed4a7f597c9133bc7fd55a98031186f49610); /* statement */ \nraw[1] = Lib_RLPWriter.writeBytes(_value);\nc_0xd5aef18d(0x71bb861c36b7b4a372f9c528ba5372d1f57ca546ca2bddf4974fde6a38857d16); /* line */ \n        c_0xd5aef18d(0x2aaa55ae5371a4111a8eae77d91189200ce9a4ad74028f559a90ec6830a2f776); /* statement */ \nreturn _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates an empty branch node.\n     * @return _node Empty branch node as a TrieNode struct.\n     */\n    function _makeEmptyBranchNode() private pure returns (TrieNode memory _node) {c_0xd5aef18d(0xc08cac6890478c72b59af124094aba71913c1ec210edb0d4685e39c069de3823); /* function */ \n\nc_0xd5aef18d(0xbca1daba9b56bf2704ed930f8c8a035b6c39a2b8f0e50e87da144974e48c641d); /* line */ \n        c_0xd5aef18d(0x2df3671da32e12c610f362578e28aa4d8911e6b88202ce49c7e0e3976ba20f4e); /* statement */ \nbytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);\nc_0xd5aef18d(0xc9ed11a2f2e02ade48c107703bd466c5e81d72b02700edf61cac0fd7a38acf5c); /* line */ \n        c_0xd5aef18d(0x0383b9050d38fce0c150a12a5197ad0b759fe27de84d3c36b60e3cb956f5a678); /* statement */ \nfor (uint256 i = 0; i < raw.length; i++) {\nc_0xd5aef18d(0x86bb9e5d43d2383eeb028fc5f5f58b111942f11b19157c93d98167d6117f73cd); /* line */ \n            c_0xd5aef18d(0x84a6fbaffd11f74241fc461a85e3e6cb22036144b090918bd1d6fa3c110772bc); /* statement */ \nraw[i] = RLP_NULL_BYTES;\n        }\nc_0xd5aef18d(0x931b27c46ef807db17a6791f4ba65673b35a86691f367c251e6e5644b5ccce61); /* line */ \n        c_0xd5aef18d(0xa2e12ce00fbeff5c5159ecbfbee13f66fbab6ef0c0850ad0d781958cd666433e); /* statement */ \nreturn _makeNode(raw);\n    }\n\n    /**\n     * @notice Modifies the value slot for a given branch.\n     * @param _branch Branch node to modify.\n     * @param _value Value to insert into the branch.\n     * @return _updatedNode Modified branch node.\n     */\n    function _editBranchValue(TrieNode memory _branch, bytes memory _value)\n        private\n        pure\n        returns (TrieNode memory _updatedNode)\n    {c_0xd5aef18d(0xc4f06c0a91155e4ddbf5a925679340d0bf1a11ff2defa0a2ec0370afe8d4edbc); /* function */ \n\nc_0xd5aef18d(0xd54acdd6849dbff4c78d79fb45c9065123cc6d013475979235a503d9cc31a119); /* line */ \n        c_0xd5aef18d(0xa8ba743beea0a13a88d5a20333565e441870ebb00957da70c493938d45cad075); /* statement */ \nbytes memory encoded = Lib_RLPWriter.writeBytes(_value);\nc_0xd5aef18d(0xae687ba819f24fa1644651e187fd3d9fa8b79a64c97e3f01ee9787b4e1a33294); /* line */ \n        c_0xd5aef18d(0xa94baf95f008809b18a2010f255276f2547d8de3694c4dc840ca3bf071d864a1); /* statement */ \n_branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);\nc_0xd5aef18d(0xaef1b4524a46b537c1a627d0b899f56496d9ce0d92cc4829eed0eae395ea940f); /* line */ \n        c_0xd5aef18d(0xc48afc639ed718008a780327e4946f0eba007b6b597c4e56e690ea5b30a5827c); /* statement */ \nreturn _makeNode(_branch.decoded);\n    }\n\n    /**\n     * @notice Modifies a slot at an index for a given branch.\n     * @param _branch Branch node to modify.\n     * @param _index Slot index to modify.\n     * @param _value Value to insert into the slot.\n     * @return _updatedNode Modified branch node.\n     */\n    function _editBranchIndex(\n        TrieNode memory _branch,\n        uint8 _index,\n        bytes memory _value\n    ) private pure returns (TrieNode memory _updatedNode) {c_0xd5aef18d(0x9883d37c8e23fecc930ab071ec914cf2a42ab2cb3c22f3c51c681348976bf68e); /* function */ \n\nc_0xd5aef18d(0x1aed35f6ef076cf092be1149743a419f80904601cd02efd36ab8da695f4ed014); /* line */ \n        c_0xd5aef18d(0x8683584a0463b6281b027a7b2cd75d6155891e0d148a197ef32f039388acd726); /* statement */ \nbytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);\nc_0xd5aef18d(0x55e7d10b7c7e2a43d6e232b7904af785e0f8ebb9cb8cff6f6cc4473773a626d7); /* line */ \n        c_0xd5aef18d(0x620f1713a8f3f5948effdd2bd73094a5aa3597fbf7c2a16ada635d3687631d16); /* statement */ \n_branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);\nc_0xd5aef18d(0xe266387bd3a581c0132297292c00c681c170cec8e03b3e5ef9411c7b3cbb5fe5); /* line */ \n        c_0xd5aef18d(0xd1595d0da54c8d19da672ce8dda711c9dce2a2716c0fa4439fbe4fefb346bb5d); /* statement */ \nreturn _makeNode(_branch.decoded);\n    }\n\n    /**\n     * @notice Utility; adds a prefix to a key.\n     * @param _key Key to prefix.\n     * @param _isLeaf Whether or not the key belongs to a leaf.\n     * @return _prefixedKey Prefixed key.\n     */\n    function _addHexPrefix(bytes memory _key, bool _isLeaf)\n        private\n        pure\n        returns (bytes memory _prefixedKey)\n    {c_0xd5aef18d(0xb6b9f756f427ef8194e1d4ca1ff651b897ff6eb691534fdf4f72654d23f1e561); /* function */ \n\nc_0xd5aef18d(0x37a20667a2329e3a01afe0111ed4648897c56f5fb0ceddffbbab3c0464a9edbd); /* line */ \n        c_0xd5aef18d(0xfd4c97a00086d3bff2aed454f9f89423f17256eda58a590f0d6b4755e65027cb); /* statement */ \nuint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);\nc_0xd5aef18d(0x8057131fface06ef24e5269176d858b9cbd7c46e95ab8b19c4f2a036fc3f8905); /* line */ \n        c_0xd5aef18d(0x250ad581c1fc69e1f8f7de189adb808af4f4c6c1f95be97e0ba89dc61b2fb054); /* statement */ \nuint8 offset = uint8(_key.length % 2);\nc_0xd5aef18d(0xcdf2f058556c808cad24dc859d0246f6b01d82caf78c87a47a020e9ebd1dfa55); /* line */ \n        c_0xd5aef18d(0x6588205a6b71f6300f7b39e9bdc4538499698eb7b48f3b9a50aacd8737ea9c37); /* statement */ \nbytes memory prefixed = new bytes(2 - offset);\nc_0xd5aef18d(0x028b47b0f05634b1f3800733104c3992718c3a854819f29ce4fba997616e244f); /* line */ \n        c_0xd5aef18d(0x6bef60019dc18f864cd0f3569ed3449e15ff690f63fccd33506682d6a5527719); /* statement */ \nprefixed[0] = bytes1(prefix + offset);\nc_0xd5aef18d(0x67ac310402d6ad0fba55e7310ff1771e2c93886e4cb3dfedbbe8a2c24c2fa97f); /* line */ \n        c_0xd5aef18d(0xc06b913613ebb766244fa8710a9e623466f26050adde78dad676f17d6389d9b8); /* statement */ \nreturn abi.encodePacked(prefixed, _key);\n    }\n\n    /**\n     * @notice Utility; removes a prefix from a path.\n     * @param _path Path to remove the prefix from.\n     * @return _unprefixedKey Unprefixed key.\n     */\n    function _removeHexPrefix(bytes memory _path)\n        private\n        pure\n        returns (bytes memory _unprefixedKey)\n    {c_0xd5aef18d(0x51d244ce4c9dbe63dcac2a490e2392fde818e7f81047d8cf559b6b70e5e01753); /* function */ \n\nc_0xd5aef18d(0x51b9c71d4631a7b48218a3ea92984b36da6fb62cb15f7e6a01be0db9028b2f9c); /* line */ \n        c_0xd5aef18d(0x02c6beb780529785b4f7115180085313e466f059c4a15ef664a85b54adcc960d); /* statement */ \nif (uint8(_path[0]) % 2 == 0) {c_0xd5aef18d(0xeb77a9fde67845ab17a7cc994f98e5ea84f0ed7b5be38a3c56219ddf574792c9); /* branch */ \n\nc_0xd5aef18d(0x629cdd8285cac71674c50e0864184465a5e4a20e29164fe6bb0740b672c994d1); /* line */ \n            c_0xd5aef18d(0xa4d9a14ae3dc2e3ab4c01355b118b82580124d8cbaad82cdeabb46acf0c9e462); /* statement */ \nreturn Lib_BytesUtils.slice(_path, 2);\n        } else {c_0xd5aef18d(0xff520375de41f0b6982427cd0f308b4b563b658384155d2b3898eb9001f1a3c6); /* branch */ \n\nc_0xd5aef18d(0x19061a92ef80d84f11ef9ba2aa30f382b0eef880ccee2f36d82f6f3ab4c24fad); /* line */ \n            c_0xd5aef18d(0x7a6bafd711cfc8472918272b040cc666952337fdf8821268ac6c4089b98c2cf1); /* statement */ \nreturn Lib_BytesUtils.slice(_path, 1);\n        }\n    }\n\n    /**\n     * @notice Utility; combines two node arrays. Array lengths are required\n     * because the actual lengths may be longer than the filled lengths.\n     * Array resizing is extremely costly and should be avoided.\n     * @param _a First array to join.\n     * @param _aLength Length of the first array.\n     * @param _b Second array to join.\n     * @param _bLength Length of the second array.\n     * @return _joined Combined node array.\n     */\n    function _joinNodeArrays(\n        TrieNode[] memory _a,\n        uint256 _aLength,\n        TrieNode[] memory _b,\n        uint256 _bLength\n    ) private pure returns (TrieNode[] memory _joined) {c_0xd5aef18d(0x73c14949624b82be0079ee85948d4befbdf568d83c2a73823b629ca762050557); /* function */ \n\nc_0xd5aef18d(0x958f6ac15087026480f68592b828c29fc6c18e0b3ed274d975d4b4d53ce4a8e2); /* line */ \n        c_0xd5aef18d(0xb01680d44ea8b187c19f24dc99210385a2e2f310edc9aaddef5d35206c3e267b); /* statement */ \nTrieNode[] memory ret = new TrieNode[](_aLength + _bLength);\n\n        // Copy elements from the first array.\nc_0xd5aef18d(0xbc6d219140ddf0858ca29fe4df453c54419f71b72e457785e34fc8ba9ae77ecf); /* line */ \n        c_0xd5aef18d(0xf8c82430894e278416bdf7b7fa79809504d169c96d22c29c246c936e05c16a3b); /* statement */ \nfor (uint256 i = 0; i < _aLength; i++) {\nc_0xd5aef18d(0x62c3cebb7d2550a4f5283017f56371cd9c35bdeb732cb88e004b7a0b34af3d6b); /* line */ \n            c_0xd5aef18d(0x772ea2ab58c53edd5b00d24449faccc8bceb15945ec11bd43aa3e1a1a1efe8c5); /* statement */ \nret[i] = _a[i];\n        }\n\n        // Copy elements from the second array.\nc_0xd5aef18d(0x2afa5993570499a5c3304614f4240054cf42844a7085a24557146fef3fb423a1); /* line */ \n        c_0xd5aef18d(0xc8ce146d306531880c7590593d64bb7d61159eb6f496140776ac8d1cca792f9b); /* statement */ \nfor (uint256 i = 0; i < _bLength; i++) {\nc_0xd5aef18d(0x9c63bff29cc276656eae4f078bf66a002501eddc4215572e5d7f547885967371); /* line */ \n            c_0xd5aef18d(0xa6d0d8ea6e8dc22e8645c7c67a2942099f61910e2e3c7f1eb06a6a37e1735c2f); /* statement */ \nret[i + _aLength] = _b[i];\n        }\n\nc_0xd5aef18d(0x101a11ca7f05323c23fe13d44dd9d5eaaa04371432c1cb88a73420f9d5e80fb9); /* line */ \n        c_0xd5aef18d(0xd63eae6571587811e88359e390816757b9f2bbc5d0e87575766ddcf793759d42); /* statement */ \nreturn ret;\n    }\n}\n"
    },
    "contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/L2/messaging/IL2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x7ee6440f(bytes32 c__0x7ee6440f) pure {}\n\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL2CrossDomainMessenger\n */\ninterface IL2CrossDomainMessenger is ICrossDomainMessenger {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) external;\n}\n"
    },
    "contracts/L2/messaging/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xd65868c9(bytes32 c__0xd65868c9) pure {}\n\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\nimport { Lib_CrossDomainUtils } from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\nimport { Lib_DefaultValues } from \"../../libraries/constants/Lib_DefaultValues.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Interface Imports */\nimport { IL2CrossDomainMessenger } from \"./IL2CrossDomainMessenger.sol\";\nimport { iOVM_L2ToL1MessagePasser } from \"../predeploys/iOVM_L2ToL1MessagePasser.sol\";\n\n/**\n * @title L2CrossDomainMessenger\n * @dev The L2 Cross Domain Messenger contract sends messages from L2 to L1, and is the entry point\n * for L2 messages sent via the L1 Cross Domain Messenger.\n *\n */\ncontract L2CrossDomainMessenger is IL2CrossDomainMessenger {\nfunction c_0x198fb849(bytes32 c__0x198fb849) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => bool) public relayedMessages;\n    mapping(bytes32 => bool) public successfulMessages;\n    mapping(bytes32 => bool) public sentMessages;\n    uint256 public messageNonce;\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n    address public l1CrossDomainMessenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _l1CrossDomainMessenger) {c_0x198fb849(0x55fdb7d4db787d8f53f75477e3f80d5285ddacacf7a393641813d3d5492a4f19); /* function */ \n\nc_0x198fb849(0xf0cb0f2046e1e725ff0dfebb2aafdf9be27a154f361aa88df758c7bfc975a4d8); /* line */ \n        c_0x198fb849(0x0613b190486eee100ac02e9c7b88b039268d0b1fe26618ab7439a2fc8deb4c99); /* statement */ \nl1CrossDomainMessenger = _l1CrossDomainMessenger;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // slither-disable-next-line external-function\n    function xDomainMessageSender() public view returns (address) {c_0x198fb849(0xedea7284feb0b9004481cc53a2677501d3f11a6b1b241040e71aa3c9142d7766); /* function */ \n\nc_0x198fb849(0xd01467f9c397d6d1a713711274dc6f934b4d5a1504dbc665f7acfad2a5aad927); /* line */ \n        c_0x198fb849(0x140ea6d7f0408bd3a935595747de384e34a39281e08d6fa061b112e44f92221a); /* requirePre */ \nc_0x198fb849(0xbf3cc3b7e72cf6e0d9ae8fdb24e36ff9b1ac073e84a0b7805a7a3cf00b91f4cb); /* statement */ \nrequire(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );c_0x198fb849(0x480f8de3a44e767c63a345fd89e036b51abc631fb140c186fd397e0ba4c7b3cc); /* requirePost */ \n\nc_0x198fb849(0x486cc3ac33edab01109db1782c7c4e229db5fca16a9e8a650f6a7d535466489f); /* line */ \n        c_0x198fb849(0x60e010a569ecaf6e1d0b21ee129da13f6a5eac1396660a8f208a3e3f8890d30d); /* statement */ \nreturn xDomainMsgSender;\n    }\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    // slither-disable-next-line external-function\n    function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    ) public {c_0x198fb849(0x64e6c58a6b7385e333a836d0ce93bf0521d0369c86e92a80bfae3b47ad6ef056); /* function */ \n\nc_0x198fb849(0x5944f610ff9031e557c6f71910b27dcbaaa3877801ec365f49f9dd1e3a01f6ae); /* line */ \n        c_0x198fb849(0x0ac012d87cd95c2be2b735394733ec462c63c4fb0e400a70fed7101ff35db8d8); /* statement */ \nbytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            messageNonce\n        );\n\nc_0x198fb849(0x2d4a260568ec5614f7d70d11ec7b199bc065e8c678ae98b3a7d8dbf4518e4bee); /* line */ \n        c_0x198fb849(0x8772b0038c0bd2b80015e72821e381209848f4f052d41eb78b53ddc4120aacf1); /* statement */ \nsentMessages[keccak256(xDomainCalldata)] = true;\n\n        // Actually send the message.\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events\nc_0x198fb849(0x4f468ff66403eec2a09cb86c6254da31c733602e273c7976179b90ca34b47bf7); /* line */ \n        c_0x198fb849(0xcd49aba52e5e840ab4b91d23c4fbcc22d024a434a4bf94f2586eb3730c77cd7d); /* statement */ \niOVM_L2ToL1MessagePasser(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER).passMessageToL1(\n            xDomainCalldata\n        );\n\n        // Emit an event before we bump the nonce or the nonce will be off by one.\n        // slither-disable-next-line reentrancy-events\nc_0x198fb849(0xa11ee4daef7ca651d61eb2c7887d3a44353699c93415f78f2ed8bf8afaf82912); /* line */ \n        c_0x198fb849(0xa369e2158fc0a72e0145ba4402b922e12c533287b730a966f22c2716e519a213); /* statement */ \nemit SentMessage(_target, msg.sender, _message, messageNonce, _gasLimit);\n        // slither-disable-next-line reentrancy-no-eth\nc_0x198fb849(0xcefd58bbbbfcedcabbb3a2e1b2dd033556093fc0991da91c8e99728f9265e8e0); /* line */ \n        c_0x198fb849(0x06a40c4a625027853d9eb00de6d4f8d9748c3e97087bf852a4b63062cc6b183e); /* statement */ \nmessageNonce += 1;\n    }\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @inheritdoc IL2CrossDomainMessenger\n     */\n    // slither-disable-next-line external-function\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) public {c_0x198fb849(0x33561339719279ed13f954ea12eed034c15b8cd71b15ec6021fc3bc2a5e9d214); /* function */ \n\nc_0x198fb849(0x3535ca670b6b59541a6b999cb448add4ab284e82ea3b6473af4ae6d7d15404c8); /* line */ \n        c_0x198fb849(0x12ad7aa2ccc310d4e0816af0e8d9feaf63c7f2b91058017e90954f6abd293d9b); /* requirePre */ \nc_0x198fb849(0xd3ec29f6e9ec07185b6bbca8539c5c59fdaf2e0c1a35e483734f4c5cb2245a8d); /* statement */ \nrequire(\n            AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1CrossDomainMessenger,\n            \"Provided message could not be verified.\"\n        );c_0x198fb849(0x4abcc231122053a4a5762d664cd73a20bbfd6ccafb21135d706a73a344780a0a); /* requirePost */ \n\n\nc_0x198fb849(0x699d6e5720a4fc0fc67869f88eef8d52d7a21e3dd0ced18ed98ff888e8cefd42); /* line */ \n        c_0x198fb849(0xf232214f97213a9820d43ae6b0fdbfdf75fea3a1311e575ede8e8926dfe7394f); /* statement */ \nbytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\nc_0x198fb849(0xe3ae7b4425a4e8f547a22c087c5f792c2bf86c535520a5548020a842a5e4fb17); /* line */ \n        c_0x198fb849(0x4833a083185febf1c291aed89bdeb1e089a1a1b2fd479a22dab1dbf103b1b7dd); /* statement */ \nbytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\nc_0x198fb849(0x6fd89d4253f368a6a12d122d14c7af62c4a1da9eb210cac2e02b2a52a9d0a389); /* line */ \n        c_0x198fb849(0x694df1d6ed8dee5b2a5c087593e422da48b614d0e848db3621b2b6ee8e8b0e1d); /* requirePre */ \nc_0x198fb849(0x5809e2409f88a946db24e2bc922e47e96cd06c610ad4b3c89cfb349aca2e5d04); /* statement */ \nrequire(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );c_0x198fb849(0xa04811e34fbbde7f3bd3414d646561b2c79747795f1d274cdfd13ac4cec86651); /* requirePost */ \n\n\n        // Prevent calls to OVM_L2ToL1MessagePasser, which would enable\n        // an attacker to maliciously craft the _message to spoof\n        // a call from any L2 account.\nc_0x198fb849(0xe49967a87d539c9ae54b11f3e2a815e964d175ba58c8adc4e8c184975deae11a); /* line */ \n        c_0x198fb849(0xedde9fda332819be99da0ecbe0162acd7151b0834df52dd43e209e77ff8609c7); /* statement */ \nif (_target == Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER) {c_0x198fb849(0x26b8059a5f35fab62eb21ebb6e9201863e9f4a1c83c725d755d8f2cfcec16707); /* branch */ \n\n            // Write to the successfulMessages mapping and return immediately.\nc_0x198fb849(0x191864d0e8cfb6f0c9040b3b8ab66b00ad52d1ed44e3b9a27bd91463f16476c2); /* line */ \n            c_0x198fb849(0xd971c472b97147933975a2a9a6a8cfaedd32fd012b2ea3639ab623d2e9c24bb2); /* statement */ \nsuccessfulMessages[xDomainCalldataHash] = true;\nc_0x198fb849(0xe57a91296fc31076dae3fb0a79b54d7cdd5036a5929921cdb9f5557b1c777283); /* line */ \n            c_0x198fb849(0xf1f594607b1b6ace6d4cf421c3fc10b2ea91bdc0a146dd632288d57ae1ec4d4d); /* statement */ \nreturn;\n        }else { c_0x198fb849(0x7b4fb8b789f8889a9117ae781d23d629cb5ca95d7adfb5a3f9aa4a59b548cafc); /* branch */ \n}\n\nc_0x198fb849(0x92c9d43f2c6cb969f9b1daedd2f0e8fd4c2496982452693e130a9323ed56ab3d); /* line */ \n        c_0x198fb849(0x337ca31b677f7a617251a66792f5d21a08f9962c123f388e2f4277d72f599a4f); /* statement */ \nxDomainMsgSender = _sender;\n        // slither-disable-next-line reentrancy-no-eth, reentrancy-events, reentrancy-benign\nc_0x198fb849(0x604b19694850c549ab165f711f05f6bb5721dd3419aa67010af7e07fe73fc5b7); /* line */ \n        c_0x198fb849(0xb40e92af89a1e76e1d816f4360e6bca7d64a4a4aa1a7ae660f55c1a13ffeca22); /* statement */ \n(bool success, ) = _target.call(_message);\n        // slither-disable-next-line reentrancy-benign\nc_0x198fb849(0xb2584f698a5693084015c6a9ab93baa040b68734daf71c825ecd1e3504e3f6cc); /* line */ \n        c_0x198fb849(0x717cfba295d14974e05d700fd26c78e342462b3c8d597ee41733bbbce08265f9); /* statement */ \nxDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\nc_0x198fb849(0xb8ba6af1f697449f2b6ff648dff8869f996789fa1e24d62e59fe4735a2d102f3); /* line */ \n        c_0x198fb849(0x398eae369af1a3c56117f44cbdbf95e0ed342935bc590d7220dec705d84c81e9); /* statement */ \nif (success == true) {c_0x198fb849(0x3e8bc25b938174f3917d92990c9815b38fb046bd4145442d592c077763dde867); /* branch */ \n\n            // slither-disable-next-line reentrancy-no-eth\nc_0x198fb849(0x5be893a5ff062e6e1e5f69a07e73b67c855dc9f7ea9dec9a04050e5879e5d6fc); /* line */ \n            c_0x198fb849(0x25456a423788899efa40f0d2e80977252c5e4d2854a7b9609455964b7b09d460); /* statement */ \nsuccessfulMessages[xDomainCalldataHash] = true;\n            // slither-disable-next-line reentrancy-events\nc_0x198fb849(0x061fb32d7fa7cc980f551c0129bb3e7d256dcb61f5f8a849c53adc6aa988e611); /* line */ \n            c_0x198fb849(0x5cddcb62d167ac70f5dac2b76d48a0ba43acd168c02c5e1f441a832bd3208dd6); /* statement */ \nemit RelayedMessage(xDomainCalldataHash);\n        } else {c_0x198fb849(0xdb7f356ab999c9cdbd9a8d63fd72d32649148c8726ba6be16c26dbde65b1ac36); /* branch */ \n\n            // slither-disable-next-line reentrancy-events\nc_0x198fb849(0x51312e4f59541c06f38834a83d11a3d1c910f9250d4e5cb7d26660020356697a); /* line */ \n            c_0x198fb849(0x547ebb6fa081ca477becd40b8f09e01f399ed5e28572e5e1c49034996301ab63); /* statement */ \nemit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\nc_0x198fb849(0xae06803402a3262c15710dbc46008f02f178fcfd17b7ae9c0de1de9340dd0412); /* line */ \n        c_0x198fb849(0x7379191f461f904cdd1df950ba3e34f44d933d873c09211132d7336584e70f35); /* statement */ \nbytes32 relayId = keccak256(abi.encodePacked(xDomainCalldata, msg.sender, block.number));\n\n        // slither-disable-next-line reentrancy-benign\nc_0x198fb849(0x229fdc9740be649fb6710ccd2e19079821fea1206e2c8d665074cb41a1aa2d0f); /* line */ \n        c_0x198fb849(0x13ac8ac6a85993503d80069d04ab926f251f8413a130cb41b2050ad3f5c13b4e); /* statement */ \nrelayedMessages[relayId] = true;\n    }\n}\n"
    },
    "contracts/L2/predeploys/iOVM_L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xd0043e77(bytes32 c__0xd0043e77) pure {}\n\n\n/**\n * @title iOVM_L2ToL1MessagePasser\n */\ninterface iOVM_L2ToL1MessagePasser {\n    /**********\n     * Events *\n     **********/\n\n    event L2ToL1Message(uint256 _nonce, address _sender, bytes _data);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function passMessageToL1(bytes calldata _message) external;\n}\n"
    },
    "contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xcf3504ba(bytes32 c__0xcf3504ba) pure {}\n\n\n/* Interface Imports */\nimport { iOVM_L2ToL1MessagePasser } from \"./iOVM_L2ToL1MessagePasser.sol\";\n\n/**\n * @title OVM_L2ToL1MessagePasser\n * @dev The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n * of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n * _verifyStorageProof function, which verifies the existence of the transaction hash in this\n * contract's `sentMessages` mapping.\n */\ncontract OVM_L2ToL1MessagePasser is iOVM_L2ToL1MessagePasser {\nfunction c_0xac7c9426(bytes32 c__0xac7c9426) public pure {}\n\n    /**********************\n     * Contract Variables *\n     **********************/\n\n    mapping(bytes32 => bool) public sentMessages;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Passes a message to L1.\n     * @param _message Message to pass to L1.\n     */\n    // slither-disable-next-line external-function\n    function passMessageToL1(bytes memory _message) public {c_0xac7c9426(0x7f3b95a75d513b92c4c2657d57950fa502861ab8228f35e1a173979875de70c3); /* function */ \n\n        // Note: although this function is public, only messages sent from the\n        // L2CrossDomainMessenger will be relayed by the L1CrossDomainMessenger.\n        // This is enforced by a check in L1CrossDomainMessenger._verifyStorageProof().\nc_0xac7c9426(0xcdfa0044f273410bce252082d292c4c2c637553ee5e07e4f440e4dae5c8bb612); /* line */ \n        c_0xac7c9426(0x0447b81b684377bda000f6e91fc95fec01b08e192dfc463f02a10f5e4f1e3a0d); /* statement */ \nsentMessages[keccak256(abi.encodePacked(_message, msg.sender))] = true;\n    }\n}\n"
    },
    "contracts/L2/predeploys/OVM_SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x3b523ece(bytes32 c__0x3b523ece) pure {}\n\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardBridge } from \"../messaging/L2StandardBridge.sol\";\n\n/**\n * @title OVM_SequencerFeeVault\n * @dev Simple holding contract for fees paid to the Sequencer. Likely to be replaced in the future\n * but \"good enough for now\".\n */\ncontract OVM_SequencerFeeVault {\nfunction c_0x8d05aca4(bytes32 c__0x8d05aca4) public pure {}\n\n    /*************\n     * Constants *\n     *************/\n\n    // Minimum ETH balance that can be withdrawn in a single withdrawal.\n    uint256 public constant MIN_WITHDRAWAL_AMOUNT = 15 ether;\n\n    /*************\n     * Variables *\n     *************/\n\n    // Address on L1 that will hold the fees once withdrawn. Dynamically initialized within l2geth.\n    address public l1FeeWallet;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l1FeeWallet Initial address for the L1 wallet that will hold fees once withdrawn.\n     * Currently HAS NO EFFECT in production because l2geth will mutate this storage slot during\n     * the genesis block. This is ONLY for testing purposes.\n     */\n    constructor(address _l1FeeWallet) {c_0x8d05aca4(0xc47d892832d4aaf8e15b94e23dea1600fca26823aee3d66796509a60112ba74b); /* function */ \n\nc_0x8d05aca4(0x006024ad671e6a7aaeaffeb72834f74dd6f61d10fe353b69146a005edeee313e); /* line */ \n        c_0x8d05aca4(0x42050b4e81fd773a8424a92107faabb72d1ea9c3ca31f370eedf036125019de7); /* statement */ \nl1FeeWallet = _l1FeeWallet;\n    }\n\n    /************\n     * Fallback *\n     ************/\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {}\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    // slither-disable-next-line external-function\n    function withdraw() public {c_0x8d05aca4(0x470a396e234f57b4bea06381a9fbe63d8c6d720610e1ee7483ddeb6bfb04fd7f); /* function */ \n\nc_0x8d05aca4(0x484cb014cf9370a47c956b94fdcb17e15c9ffe0bfc9b10730bd9ed2765778fd3); /* line */ \n        c_0x8d05aca4(0x3f3284791f59e4ab62c5f707651b086ad8e8f605af305caa8307e8fb141f19e1); /* requirePre */ \nc_0x8d05aca4(0x68c203a699f092facec1af3b87b99847f8f2ac4ee68800e683c156c06c08c1a0); /* statement */ \nrequire(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            // solhint-disable-next-line max-line-length\n            \"OVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );c_0x8d05aca4(0x254013bf1b6d0da630a45f232387b83d2fd774fdedb54887741f912bc5f33a3b); /* requirePost */ \n\n\nc_0x8d05aca4(0x12166c3259c349499849ff7d699ccdb3ebb154451a0ccace27eba17036dd058a); /* line */ \n        c_0x8d05aca4(0x5539d84e75107dd4b3a1f8c4bf50aeb8b33fc1c5ef589dd7337aa482b4fc38ea); /* statement */ \nL2StandardBridge(Lib_PredeployAddresses.L2_STANDARD_BRIDGE).withdrawTo(\n            Lib_PredeployAddresses.OVM_ETH,\n            l1FeeWallet,\n            address(this).balance,\n            0,\n            bytes(\"\")\n        );\n    }\n}\n"
    },
    "contracts/L2/messaging/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xb4103aeb(bytes32 c__0xb4103aeb) pure {}\n\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"../../L1/messaging/IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"../../L1/messaging/IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"./IL2ERC20Bridge.sol\";\n\n/* Library Imports */\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { IL2StandardERC20 } from \"../../standards/IL2StandardERC20.sol\";\n\n/**\n * @title L2StandardBridge\n * @dev The L2 Standard bridge is a contract which works together with the L1 Standard bridge to\n * enable ETH and ERC20 transitions between L1 and L2.\n * This contract acts as a minter for new tokens when it hears about deposits into the L1 Standard\n * bridge.\n * This contract also acts as a burner of the tokens intended for withdrawal, informing the L1\n * bridge to release L1 funds.\n */\ncontract L2StandardBridge is IL2ERC20Bridge, CrossDomainEnabled {\nfunction c_0xa2e66294(bytes32 c__0xa2e66294) public pure {}\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l1TokenBridge;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l2CrossDomainMessenger Cross-domain messenger used by this contract.\n     * @param _l1TokenBridge Address of the L1 bridge deployed to the main chain.\n     */\n    constructor(address _l2CrossDomainMessenger, address _l1TokenBridge)\n        CrossDomainEnabled(_l2CrossDomainMessenger)\n    {c_0xa2e66294(0x940054d458145a3df5cf2497e140e53fee7d30ab04d9f3cc3ff442693a291cd8); /* function */ \n\nc_0xa2e66294(0x6932d19f6603d48f6cb54ca77a57d11683c2900cde1b5fe8e3f7129415d088e2); /* line */ \n        c_0xa2e66294(0xe2c87a46cc8f2762d1dac3476b0766aab0da22493358b0de47ee029914908683); /* statement */ \nl1TokenBridge = _l1TokenBridge;\n    }\n\n    /***************\n     * Withdrawing *\n     ***************/\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external virtual {c_0xa2e66294(0xb2724328034753609999c1a9d5189b289a5d0673e3a0ba1ff72faede94f99330); /* function */ \n\nc_0xa2e66294(0x2a5c6a47492952493dde731d1c8a6eabf6e15ae8bbbea43454b65fa62fbc77f1); /* line */ \n        c_0xa2e66294(0x056eaa763533780837dc54b7b7ccb5e6a1fe7cab4a06e70ea924bf53d6e597fa); /* statement */ \n_initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _l1Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external virtual {c_0xa2e66294(0xa08666885216143f48026dcbb5fe1e975f2223711e61a6ae4c9a63bd26c755e1); /* function */ \n\nc_0xa2e66294(0xe2ea3b28835e8ef2c440786945133c24c8a75e22ba6d099d4c41568c81929f50); /* line */ \n        c_0xa2e66294(0xefd7142e5634868a415ba41a7419fe124e41bde4974ab0574d9ee0a41b5f490d); /* statement */ \n_initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _l1Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for withdrawals by burning the token and informing\n     *      the L1 token Gateway of the withdrawal.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _from Account to pull the withdrawal from on L2.\n     * @param _to Account to give the withdrawal to on L1.\n     * @param _amount Amount of the token to withdraw.\n     * @param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) internal {c_0xa2e66294(0x9c28cf9a78b575411be9f4c996357872668163d18f0eb738bc0640cd9a890ae4); /* function */ \n\n        // When a withdrawal is initiated, we burn the withdrawer's funds to prevent subsequent L2\n        // usage\n        // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0xe4f2c603c729ebd367401a8d4099b312fcc8beabcb8e8f1045ee4ed0b2b6d908); /* line */ \n        c_0xa2e66294(0x0278d950fa57e3420b69d9cd93ffaf727905eb7fdd27db5975a4ddff6870844a); /* statement */ \nIL2StandardERC20(_l2Token).burn(msg.sender, _amount);\n\n        // Construct calldata for l1TokenBridge.finalizeERC20Withdrawal(_to, _amount)\n        // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x818c98683aa2a58f7f4d2f79513ca21ff6edcac17e6e908fd3df3cca30e8496b); /* line */ \n        c_0xa2e66294(0x165c1dc64b4f38610a1ecb5928fbe002fa25760e17db0fee2e15c0631591e8be); /* statement */ \naddress l1Token = IL2StandardERC20(_l2Token).l1Token();\nc_0xa2e66294(0x053f945567ab7502f5ce9194683572b504924c8fa8efd6272b58e995955e8310); /* line */ \n        c_0xa2e66294(0x53cfa94a499fabbf1dd9a0444256a2eaa26ceae7e02ba38b0086b5267bd4c540); /* statement */ \nbytes memory message;\n\nc_0xa2e66294(0x7f046e0bf9f2d051bebb64e70bba86e38b89f0dff4cca2fb3705c0cb812cae6d); /* line */ \n        c_0xa2e66294(0xa74875e7eb8f491766dc9d3fc93ca9c18b888533f794700e79b01d6ee2ebb783); /* statement */ \nif (_l2Token == Lib_PredeployAddresses.OVM_ETH) {c_0xa2e66294(0x3ec3e12c038c5880b2a40c516fa5c5fe39dfe6637ffa2a3a51d804c6e24cfe59); /* branch */ \n\nc_0xa2e66294(0x79ee9cd3e38858340163ad1a691e2050b7a19942ff650ded6d91adeb4f5ee642); /* line */ \n            c_0xa2e66294(0xc62d72ecec4fc5df47a784dee635a0f14117bff1f3d7a50377ab84aa647f8012); /* statement */ \nmessage = abi.encodeWithSelector(\n                IL1StandardBridge.finalizeETHWithdrawal.selector,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        } else {c_0xa2e66294(0xe1889909c9551037ad9bcb14e9ecb21ceccd8ad89ae0160bda921184fbdf6e8c); /* branch */ \n\nc_0xa2e66294(0x6ff91be3aa307a75b2952090cccc4d6c794b4c6b708a48370ca259692ebcb2da); /* line */ \n            c_0xa2e66294(0x48edd18cc61c000e0230f6dedecba21a3fc1bd7d3adb707823b9659d95e57dcf); /* statement */ \nmessage = abi.encodeWithSelector(\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\n                l1Token,\n                _l2Token,\n                _from,\n                _to,\n                _amount,\n                _data\n            );\n        }\n\n        // Send message up to L1 bridge\n        // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x7244877b66026570728f07375c63e1ad860bab462fcc3d0aa5ceee35967b48e6); /* line */ \n        c_0xa2e66294(0x17ef5189c2e476d261a17831cc31c0f95b78b229540c9f141ec3b91c5b261943); /* statement */ \nsendCrossDomainMessage(l1TokenBridge, _l1Gas, message);\n\n        // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0xd0e2eea754e782267ba0c758371a4dc457d0dd8c013dd90879407ae58b6d7bf5); /* line */ \n        c_0xa2e66294(0x6507fa202bcc23a9105a3e5f205bce542c3c0b1ace5c494009ae91747b107be5); /* statement */ \nemit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount, _data);\n    }\n\n    /************************************\n     * Cross-chain Function: Depositing *\n     ************************************/\n\n    /**\n     * @inheritdoc IL2ERC20Bridge\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external virtual onlyFromCrossDomainAccount(l1TokenBridge) {c_0xa2e66294(0x6045405ec27668abbd50a373392e18407837efe2bc227f257ff53dd5dae6c743); /* function */ \n\n        // Check the target token is compliant and\n        // verify the deposited token on L1 matches the L2 deposited token representation here\nc_0xa2e66294(0x1f412ca488a3e1b4beaab05c90859d476ea46ea26736d22bba43846dc5be439f); /* line */ \n        c_0xa2e66294(0x1fd566c68997168640a42d65e3e8d46ea326906899d1543eb957b9eed30e6c46); /* statement */ \nif (\n            // slither-disable-next-line reentrancy-events\n            ERC165Checker.supportsInterface(_l2Token, 0x1d1d8b63) &&\n            _l1Token == IL2StandardERC20(_l2Token).l1Token()\n        ) {c_0xa2e66294(0xfd1d8965fc54c6885f922caeb9268738d148b8e3ad3ecc84fb457abfd74e516d); /* branch */ \n\n            // When a deposit is finalized, we credit the account on L2 with the same amount of\n            // tokens.\n            // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x3b79c7a68270fc0c284f59e2f042ceaf4eeb9f20f1b7b79a665855f76c8299bb); /* line */ \n            c_0xa2e66294(0x87f43c2afb84703a6d645d8d9e7032878cdd18fbcd17e8b6dfdd0314c709f040); /* statement */ \nIL2StandardERC20(_l2Token).mint(_to, _amount);\n            // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x11e5838107de0a0243ad4524b1faf9e37e2a21376ed17af2f712433b4275a003); /* line */ \n            c_0xa2e66294(0x8c25ceae0ab0488ca9802595adcf5c6ae84bf2de2509f7c16d9f7761053d5856); /* statement */ \nemit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n        } else {c_0xa2e66294(0xdac070c64a709708481af08c9366808b165e015d53a5acd612f4a5b4a5286a3c); /* branch */ \n\n            // Either the L2 token which is being deposited-into disagrees about the correct address\n            // of its L1 token, or does not support the correct interface.\n            // This should only happen if there is a  malicious L2 token, or if a user somehow\n            // specified the wrong L2 token address to deposit into.\n            // In either case, we stop the process here and construct a withdrawal\n            // message so that users can get their funds out in some cases.\n            // There is no way to prevent malicious token contracts altogether, but this does limit\n            // user error and mitigate some forms of malicious contract behavior.\nc_0xa2e66294(0x210e7ac67d0910fc44622af6b9658104a52c933c8bbb8d8dc944340f6d28bd4e); /* line */ \n            c_0xa2e66294(0xd7f9f098308ea4f3220949ba542b21fedc36058eaae145c6222e4c2f7367508b); /* statement */ \nbytes memory message = abi.encodeWithSelector(\n                IL1ERC20Bridge.finalizeERC20Withdrawal.selector,\n                _l1Token,\n                _l2Token,\n                _to, // switched the _to and _from here to bounce back the deposit to the sender\n                _from,\n                _amount,\n                _data\n            );\n\n            // Send message up to L1 bridge\n            // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x23040aca731308cd82d2e8f4f8492134e096091287026dc85cbfa86cb78fc699); /* line */ \n            c_0xa2e66294(0x8d6447b1134a15288ac08bd78f45a4574faa8941c52eca69d032ed3128163847); /* statement */ \nsendCrossDomainMessage(l1TokenBridge, 0, message);\n            // slither-disable-next-line reentrancy-events\nc_0xa2e66294(0x7533329c1cc476f71a11ae784192a37c957f77e9d36133940ecf6961cf3d039e); /* line */ \n            c_0xa2e66294(0x19b8f34070f7f3ff146d2cf46e0e097a6b3eade93fa5d777b67504c744b0fff6); /* statement */ \nemit DepositFailed(_l1Token, _l2Token, _from, _to, _amount, _data);\n        }\n    }\n}\n"
    },
    "contracts/L1/messaging/IL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\nimport \"./IL1ERC20Bridge.sol\";\n\n/**\n * @title IL1StandardBridge\n */\ninterface IL1StandardBridge is IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev Deposit an amount of the ETH to the caller's balance on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\n\n    /**\n     * @dev Deposit an amount of ETH to a recipient's balance on L2.\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called\n     * before the withdrawal is finalized.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/L1/messaging/IL1ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title IL1ERC20Bridge\n */\ninterface IL1ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L2 bridge contract.\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address);\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _amount Amount of the ERC20 to deposit\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the\n     * L1 ERC20 token.\n     * This call will fail if the initialized withdrawal from L2 has not been finalized.\n     *\n     * @param _l1Token Address of L1 token to finalizeWithdrawal for.\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _from L2 address initiating the transfer.\n     * @param _to L1 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _data Data provided by the sender on L2. This data is provided\n     *   solely as a convenience for external contracts. Aside from enforcing a maximum\n     *   length, these contracts provide no guarantees about its content.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/L2/messaging/IL2ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xdbb1ef9e(bytes32 c__0xdbb1ef9e) pure {}\n\n\n/**\n * @title IL2ERC20Bridge\n */\ninterface IL2ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L1 bridge contract.\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external returns (address);\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _to L1 adress to credit the withdrawal to.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\n     * L1StandardTokenBridge.\n     * @param _l1Token Address for the l1 token this is called with\n     * @param _l2Token Address for the l2 token this is called with\n     * @param _from Account to pull the deposit from on L2.\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     * @param _data Data provider by the sender on L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "contracts/libraries/bridge/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\nfunction c_0x52711346(bytes32 c__0x52711346) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {c_0x52711346(0xfb44ee638285d08c1cac5a29ba14bd5e640a7058eb86700b40aa1914b3594b3d); /* function */ \n\nc_0x52711346(0xa31bfb549c18ca1e5c15243ea0edbeeb44c0c02c787502873a92cb8d20c934b6); /* line */ \n        c_0x52711346(0xe1b9892b9b97f20018ebab9088f57b2d6ad62e5409b274fec685ee77d1da5291); /* statement */ \nmessenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {c_0x52711346(0x86812c68450d0c4ed6490c918f3937e98500bdfcbe8bfe76bb6e465b40d69282); /* function */ \n\nc_0x52711346(0xa63dc6b941da7699fc5911c9a34e842a4877d43eff2ae20a183e871cbc8944c2); /* line */ \n        c_0x52711346(0xb882aef2c5028d42e422069c26947dd614330c825a344a2594e7e008c9845ad5); /* requirePre */ \nc_0x52711346(0x63993c765f48901c3a19706489065e0bd04e6ce059f66967508e76757f8db8c1); /* statement */ \nrequire(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );c_0x52711346(0x08e9e8f45271f341c35002c9016d25d33f1bfbbb6c22c453816d537d0fbf79d5); /* requirePost */ \n\n\nc_0x52711346(0x94d29cb20e2997e20628d21c5c5f13e81e1111aa4f83394965570391684ceb7a); /* line */ \n        c_0x52711346(0x1728c69c6f506b543e14c5ea8f29f944b15ceb344ee2c8301c6e111bf725d9c4); /* requirePre */ \nc_0x52711346(0x3314f412677c9739524215adbbe7e9e4a860b94554fb1f1dbc5d3eb027700904); /* statement */ \nrequire(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );c_0x52711346(0x03c4c1ad53102829b27b132ea4affa777b3ce22d2bbb223bfbab23d88233846a); /* requirePost */ \n\n\nc_0x52711346(0x63eaccca61daf1f83a11983aa90043d0b73fdbc205ba954988271b6a86e871ba); /* line */ \n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {c_0x52711346(0x2ee0fa5b456c0c23ffff8ba5120337097c8a3261292e2483bf1e985bd5ac9897); /* function */ \n\nc_0x52711346(0xb99778046bc2e0bcb78f262bf6ef60ed1f3034b8ad9fff68b9ec4c1bd1ff79a6); /* line */ \n        c_0x52711346(0xcee4fb8042a23a5ec66252e09ebe772decdc340e3715a5fa734ce9c7134b7a25); /* statement */ \nreturn ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {c_0x52711346(0x46c9d82ba34c2556fd9649d204054eb5332b70be7d5fce6d450829c2c13f08f1); /* function */ \n\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\nc_0x52711346(0x062f1c49c8aa698b7c9622431569e1a78d221c2419cd2d56e673c395344d5786); /* line */ \n        c_0x52711346(0x71430b4c96dca3921eed6320f41233a642a98f94a3d1df3413b67765d6d127b2); /* statement */ \ngetCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "contracts/standards/IL2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xed37f58c(bytes32 c__0xed37f58c) pure {}\n\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IL2StandardERC20 is IERC20, IERC165 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/standards/L2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x791d1b81(bytes32 c__0x791d1b81) pure {}\n\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IL2StandardERC20.sol\";\n\ncontract L2StandardERC20 is IL2StandardERC20, ERC20 {\nfunction c_0x91dfe917(bytes32 c__0x91dfe917) public pure {}\n\n    address public l1Token;\n    address public l2Bridge;\n\n    /**\n     * @param _l2Bridge Address of the L2 standard bridge.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _l2Bridge,\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {c_0x91dfe917(0x2e6202835d4e259ecd6779559290965a672c621bd64fbe7e64c801fcb191d931); /* function */ \n\nc_0x91dfe917(0x6b97f2bfbc75610f5fa84b6d77ca78d7e8fb699a84bddcc5a1ec71146713351e); /* line */ \n        c_0x91dfe917(0xe0ec3171cb8355cdda0dd965fa692b78369f9f1d0e4ad05df24839d2de549027); /* statement */ \nl1Token = _l1Token;\nc_0x91dfe917(0x32da0ae98296000dfb58f53777caddfc35216f075b8eb4f6502895210e3d5b01); /* line */ \n        c_0x91dfe917(0x54c7c953745d8c37a4e6c5517a3a1008657046e82aef7db47f21cc9b8296e8cf); /* statement */ \nl2Bridge = _l2Bridge;\n    }\n\n    modifier onlyL2Bridge() {c_0x91dfe917(0xe55c4777494d923d3a99954baf5d77a61a29e55ea6592d6b11169b4bab37d7f1); /* function */ \n\nc_0x91dfe917(0xd65868d80b88c982611a208232e3c6407232d4708b670337b4c28026e83d80c7); /* line */ \n        c_0x91dfe917(0x111379c2178bb2d89786ec3af4d83343d0753fd2dc63458d47aced406c0dbc3b); /* requirePre */ \nc_0x91dfe917(0xf518c7374ccda61b61adeb7697f193e148ae215aa43c3d75ccdfeb5cf4aad553); /* statement */ \nrequire(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");c_0x91dfe917(0x7022c1c3a7f768ba3fa0d64ab84afc82dd5c489c45c2f1aacb97dc6308b5296f); /* requirePost */ \n\nc_0x91dfe917(0x7045f0f3ba735f21adcd179abeb9752db520732b86be477b14ba335058da009e); /* line */ \n        _;\n    }\n\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {c_0x91dfe917(0x3bcc49938421b187f23ce8296e92cd2189b0a7e43b87b67223719a8b43b7b477); /* function */ \n\nc_0x91dfe917(0x4083f46c42fc4a77ff21ac2235da5839871ac6377ab53c9303a560c3f61364d9); /* line */ \n        c_0x91dfe917(0xadd2dc0d3937d64e1f146f96da4382494eb76d10425a171b75c077b2cfd6a27e); /* statement */ \nbytes4 firstSupportedInterface = bytes4(keccak256(\"supportsInterface(bytes4)\")); // ERC165\nc_0x91dfe917(0x7dce5d7d625920e75ed7acbe4f7dd56700a222efeb8e4ad8c736d94991a7671c); /* line */ \n        c_0x91dfe917(0x0d8f5eaf491450fd5cd7bc04a085a2632d6c6f9fb198b9eac4d55f183fa44d94); /* statement */ \nbytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^\n            IL2StandardERC20.mint.selector ^\n            IL2StandardERC20.burn.selector;\nc_0x91dfe917(0xe6304dd220bd32a23e42e0d1ba5486d68a80fe4ce0182ae7c655f4711eda2710); /* line */ \n        c_0x91dfe917(0x7e3ccd42a9a8d3c98c966e0e1bf94eb3e4c583e0474519e53ddf280e737c64fa); /* statement */ \nreturn _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface;\n    }\n\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual onlyL2Bridge {c_0x91dfe917(0x795032a8ffa712e5aa3b98a62abe9c3664c084552a1bc691622d95a19c0d586a); /* function */ \n\nc_0x91dfe917(0x54ffd748bceee9593f44db786eb4c8f01c08796e5ca37606d16d22dca924f507); /* line */ \n        c_0x91dfe917(0x21191913bcc0f9c17b8380871ba05fccbe76835878ccacff99e892d74f8578ee); /* statement */ \n_mint(_to, _amount);\n\nc_0x91dfe917(0x8d0fc278653063af1f423668623ab53ca6f61a7412df1e564d7b6d5d24bbfc4a); /* line */ \n        c_0x91dfe917(0xce74fbcb0b2d2db1e859f648f8abbe584f7895e02ffa0422a818e1e2fcd8d2dd); /* statement */ \nemit Mint(_to, _amount);\n    }\n\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual onlyL2Bridge {c_0x91dfe917(0xf8f052f1c035c859bc8b542596e80fd49da402473e6a84cc731ca553df984b5c); /* function */ \n\nc_0x91dfe917(0x6afcafb14e784864d4b3da70d329c002f15140a8068b88918fc8d7e052c02dd8); /* line */ \n        c_0x91dfe917(0x222858469a2e1219bf937fe26716b75672e1f03ac558847311fa51c3d28fa374); /* statement */ \n_burn(_from, _amount);\n\nc_0x91dfe917(0xa1019a181384ca1986164abe500527e383f5c9d4192e1d35a5d7516abc2854d4); /* line */ \n        c_0x91dfe917(0xa6b3b2d1832d2d43e94334242fc562e62e9fce4114194a170446c3a45c6de3f0); /* statement */ \nemit Burn(_from, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/L2/predeploys/OVM_ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x04386372(bytes32 c__0x04386372) pure {}\n\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\n\n/**\n * @title OVM_ETH\n * @dev The ETH predeploy provides an ERC20 interface for ETH deposited to Layer 2. Note that\n * unlike on Layer 1, Layer 2 accounts do not have a balance field.\n */\ncontract OVM_ETH is L2StandardERC20 {\nfunction c_0xe95e0e20(bytes32 c__0xe95e0e20) public pure {}\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor()\n        L2StandardERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"ETH\")\n    {c_0xe95e0e20(0xb6098bef7cd028ba2be107bd6611b66ee45124457834262064ca93cd1f2cf144); /* function */ \n}\n\n    // ETH ERC20 features are disabled until further notice.\n    // Discussion here: https://github.com/ethereum-optimism/optimism/discussions/1444\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {c_0xe95e0e20(0x919dcf9a9c5c7641e62e35ade5869966f6b4b0b13645eda6a676fd7676522526); /* function */ \n\nc_0xe95e0e20(0x0db20ee72861f7b35cc1dd31a88e90201b9ea75b7d74cad46a880cffef99373a); /* line */ \n        c_0xe95e0e20(0x84248e16be4d03c25f199cee8c4ea8aa618585184bd4fcc639052bbb48a19ad2); /* statement */ \nrevert(\"OVM_ETH: transfer is disabled pending further community discussion.\");\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {c_0xe95e0e20(0x359adc41ede58db4c1cbdcaf8d5ad6fb8ca7e25529f23545d5d1cd9f2e059429); /* function */ \n\nc_0xe95e0e20(0x22545afebc394b6251be533f03bde43d9c1d5895cd8e718a46c52b9534d55b5e); /* line */ \n        c_0xe95e0e20(0xe37f3a374406bc95b1aed8700e9218d68095a9dce069bb362b858a444f803ee6); /* statement */ \nrevert(\"OVM_ETH: approve is disabled pending further community discussion.\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {c_0xe95e0e20(0x18c0fbfb4838c9b46a3db467477cff6ed547d00842bf57a0aa7e4486c25a5b74); /* function */ \n\nc_0xe95e0e20(0x22996727fe18484e622283e0a2384bb02e598a11a124f3d2e9cb2b2d3f7aba19); /* line */ \n        c_0xe95e0e20(0xc17637319f329a01d18cb29f895ac2cf24762f4fa16cbab65b3bc98cba2d63b3); /* statement */ \nrevert(\"OVM_ETH: transferFrom is disabled pending further community discussion.\");\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {c_0xe95e0e20(0x056b54cd51f1c115dd0f11c88fbdfe6b2e6f1cfb68bf7694224b7f50b2e1c238); /* function */ \n\nc_0xe95e0e20(0x8ca9f35d35d7ac3c8805e3729a1c43f363c4accfd0af2a3087d66e9bd06883c9); /* line */ \n        c_0xe95e0e20(0x415cfc30ed842941a65294c89891c1d0d5d3e2c2ed2933d446b10a2f358ddb62); /* statement */ \nrevert(\"OVM_ETH: increaseAllowance is disabled pending further community discussion.\");\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {c_0xe95e0e20(0x5e0703e67617f8825c710bef8817ddc31b1a9843a2b49259f9df6749985f74d2); /* function */ \n\nc_0xe95e0e20(0xe44552853700f66bc394bfb932386196c58d9c04d0952cd5d8ea1fbeedcb0d7c); /* line */ \n        c_0xe95e0e20(0xa1c70426ff82fe5842e614141a0e6ac518ab6caf9df8993d3048671c4c85341f); /* statement */ \nrevert(\"OVM_ETH: decreaseAllowance is disabled pending further community discussion.\");\n    }\n}\n"
    },
    "contracts/L2/teleportr/TeleportrDisburser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\nfunction c_0xd6fc3b79(bytes32 c__0xd6fc3b79) pure {}\n\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TeleportrDisburser\n */\ncontract TeleportrDisburser is Ownable {\nfunction c_0x16931334(bytes32 c__0x16931334) public pure {}\n\n    /**\n     * @notice A struct holding the address and amount to disbursement.\n     */\n    struct Disbursement {\n        uint256 amount;\n        address addr;\n    }\n\n    /// The total number of disbursements processed.\n    uint256 public totalDisbursements;\n\n    /**\n     * @notice Emitted any time the balance is withdrawn by the owner.\n     * @param owner The current owner and recipient of the funds.\n     * @param balance The current contract balance paid to the owner.\n     */\n    event BalanceWithdrawn(address indexed owner, uint256 balance);\n\n    /**\n     * @notice Emitted any time a disbursement is successfuly sent.\n     * @param depositId The unique sequence number identifying the deposit.\n     * @param to The recipient of the disbursement.\n     * @param amount The amount sent to the recipient.\n     */\n    event DisbursementSuccess(uint256 indexed depositId, address indexed to, uint256 amount);\n\n    /**\n     * @notice Emitted any time a disbursement fails to send.\n     * @param depositId The unique sequence number identifying the deposit.\n     * @param to The intended recipient of the disbursement.\n     * @param amount The amount intended to be sent to the recipient.\n     */\n    event DisbursementFailed(uint256 indexed depositId, address indexed to, uint256 amount);\n\n    /**\n     * @notice Initializes a new TeleportrDisburser contract.\n     */\n    constructor() {c_0x16931334(0x39bbaedb82e6743a336be557192fb64c205b1c7023985a2169da77cfa38456e7); /* function */ \n\nc_0x16931334(0x24db5b5cfdf4200d735f11046f2ae1a70f4558a5d72f76885640a569c06c07cf); /* line */ \n        c_0x16931334(0x317e8430390de1cd59d658f9aa2e38e3fc3ede461a2882fce72bce93ad4b1163); /* statement */ \ntotalDisbursements = 0;\n    }\n\n    /**\n     * @notice Accepts a list of Disbursements and forwards the amount paid to\n     * the contract to each recipient. The method reverts if there are zero\n     * disbursements, the total amount to forward differs from the amount sent\n     * in the transaction, or the _nextDepositId is unexpected. Failed\n     * disbursements will not cause the method to revert, but will instead be\n     * held by the contract and availabe for the owner to withdraw.\n     * @param _nextDepositId The depositId of the first Dispursement.\n     * @param _disbursements A list of Disbursements to process.\n     */\n    function disburse(uint256 _nextDepositId, Disbursement[] calldata _disbursements)\n        external\n        payable\n        onlyOwner\n    {c_0x16931334(0x2ada5d99a5213ee4ca2bb15d1f40a59e356e720b5882c0781678a5e06b9ddb59); /* function */ \n\n        // Ensure there are disbursements to process.\nc_0x16931334(0x7a7334b1d6bfe4bd15a6309ce921c6474f6768575c5e38d2b2ce7acc447ba591); /* line */ \n        c_0x16931334(0xb807ae02c58a5c6be11b494711fb222a14e0d7e215117e68acdd94a81151ba74); /* statement */ \nuint256 _numDisbursements = _disbursements.length;\nc_0x16931334(0x21ab292895678d1873f05582fb6da03baffcd8dbbf67acb7d05adbe92e38f273); /* line */ \n        c_0x16931334(0x807737600e915e0ac1bda9d244b1b42f3883b11d61a3714e96412ab37d49aa0d); /* requirePre */ \nc_0x16931334(0xc1dafb9e03ad5f719e2b448b24a8dec5f2278a2d3a090d11212eccbf65b3b9dc); /* statement */ \nrequire(_numDisbursements > 0, \"No disbursements\");c_0x16931334(0x23dbf8b6555265ebf2ff79777f7ef74ba63f296fc3b5440ee3f186724f49d63d); /* requirePost */ \n\n\n        // Ensure the _nextDepositId matches our expected value.\nc_0x16931334(0x0f09cdc510c9eeadb6f4ffed3990e7ce53a93e2d1026c772e2303eb967ae6456); /* line */ \n        c_0x16931334(0x442b40ff3f756dfe83209f66d82504cceb390151b2ea76b7ce2bce481ddb3b0e); /* statement */ \nuint256 _depositId = totalDisbursements;\nc_0x16931334(0xb14a4d7d74c1e2df0ad5d1ac6189bd833e51ed69416aa7c504d01606d755c7ef); /* line */ \n        c_0x16931334(0x1338effe85e1ba3bde809611b8cd8ff762211afaccab634e6b6449395abbd822); /* requirePre */ \nc_0x16931334(0xc20c000c8553b2152a7a80ac43c52f1b7ba7cbd04b533472fc0fd7fd7057f680); /* statement */ \nrequire(_depositId == _nextDepositId, \"Unexpected next deposit id\");c_0x16931334(0xb25de3d3bad93e8f821dbd0a8d2aeb60bfa371bf7f2593187e3d6f3012cbbd13); /* requirePost */ \n\nc_0x16931334(0xc1437f73ab0f757f501060cc8e214fb6e895e2c11fdec90f1c26c337259cb3b2); /* line */ \n        unchecked {\n            totalDisbursements += _numDisbursements;\n        }\n\n        // Ensure the amount sent in the transaction is equal to the sum of the\n        // disbursements.\nc_0x16931334(0x60fb755f4c85c0f5e4fc55a59a862d71795ee75dd9aebd26397347a776a44380); /* line */ \n        c_0x16931334(0x961eebfc60945127454266e3a2aa59e195e493c917f20887f27522f65f6138f3); /* statement */ \nuint256 _totalDisbursed = 0;\nc_0x16931334(0x4a4656352b6110f616892179a43a4db2d257323981851d33e20f1d032afa8101); /* line */ \n        c_0x16931334(0x03453438aaa639cf92f4b9a0819dd07143a378d1d08840fd1091d6142cbd37ea); /* statement */ \nfor (uint256 i = 0; i < _numDisbursements; i++) {\nc_0x16931334(0xa06b97308620cba29f8f5270af06b6b2b47882e99ef6a3ab7cb6ae3dff36e6c7); /* line */ \n            c_0x16931334(0x1def478f38c0910e76e6a9de11aea3e47f48c79346e34413455d16858a227f74); /* statement */ \n_totalDisbursed += _disbursements[i].amount;\n        }\nc_0x16931334(0x1bd35d5e9c2fadd60189746ebf51278308a09575bc3dacb8a2ce127511f4bd5b); /* line */ \n        c_0x16931334(0x6ed34bb8ab9df4b9f1295d0d512d642d3757c3c47b131b126385d85398623470); /* requirePre */ \nc_0x16931334(0x6140d5c902a63db76a3285429152fb3a87752f7db4120de3c9d932f328bc3050); /* statement */ \nrequire(_totalDisbursed == msg.value, \"Disbursement total != amount sent\");c_0x16931334(0x18246eeaf0026a3e2c4ac32cbc1dc0606e82d2890a32165286e3d0a8c95fd7a4); /* requirePost */ \n\n\n        // Process disbursements.\nc_0x16931334(0x70b83d9371755905523d6f1e944a8b8692c0959960315ee55559fafd7c2c52bf); /* line */ \n        c_0x16931334(0x21baa28c2eb7d3242d4afa89ad217acdeea738ab84a007f3e8aa489d3ce867c8); /* statement */ \nfor (uint256 i = 0; i < _numDisbursements; i++) {\nc_0x16931334(0xcdf5d58952d1caa81fdfa362bb2eeb66956f151aa2b33f407f9833563b20496e); /* line */ \n            c_0x16931334(0x82fdec1cc8aa1098d9a8242384eaea39f90e5593c12b39cb109348a772e9fafe); /* statement */ \nuint256 _amount = _disbursements[i].amount;\nc_0x16931334(0xaaf73602f455fb6fc88332cf7f6d0caabacde6b54d461dc6eb9a7ee12bb2b574); /* line */ \n            c_0x16931334(0x0d14c42168fe96cb818965cb522ed1023d13f8dc0ab098cdf8760c35932c9cdf); /* statement */ \naddress _addr = _disbursements[i].addr;\n\n            // Deliver the dispursement amount to the receiver. If the\n            // disbursement fails, the amount will be kept by the contract\n            // rather than reverting to prevent blocking progress on other\n            // disbursements.\n\n            // slither-disable-next-line calls-loop,reentrancy-events\nc_0x16931334(0x4fccbbc284abd163c3c18f168872dc29d4fac77f01fc1cf5f9992b361605dc4f); /* line */ \n            c_0x16931334(0x14f24022c2530a4720a223a36c798ed655b1320c21a7fb1cd078146c936b2770); /* statement */ \n(bool success, ) = _addr.call{ value: _amount, gas: 2300 }(\"\");\nc_0x16931334(0x990d01d9292bbf5a72b844d9e480c435f5bf3f28c6a3cf01231653128d574a29); /* line */ \n            c_0x16931334(0xbeb05d1cb9e0c8962b3fbce755095395f809190d1f56a0305f52d745ed2be608); /* statement */ \nif (success) {c_0x16931334(0x926cdb8fa3eec76098df0921133fbad388217c8a5f07adf0e3652e64344ff667); /* statement */ \nc_0x16931334(0xcf258c3a8696678566a6fd532ee096e27d2a9dc64bcc87d8fccf2c9df4068555); /* branch */ \nemit DisbursementSuccess(_depositId, _addr, _amount);}\n            else {c_0x16931334(0x9065e1e3bc2a1b35f85ca394361800750d7ccf66381f3e69fe4faefe0e5cc78f); /* statement */ \nc_0x16931334(0x57081b0378c1c31ae18ff29ec060b75a2fcf8bec375989be94d0d303a4f00211); /* branch */ \nemit DisbursementFailed(_depositId, _addr, _amount);}\n\nc_0x16931334(0x9de3918864af83d66c46c014e27703f1021307042aef5dcf52b75516706ddd8b); /* line */ \n            unchecked {\n                _depositId += 1;\n            }\n        }\n    }\n\n    /**\n     * @notice Sends the contract's current balance to the owner.\n     */\n    function withdrawBalance() external onlyOwner {c_0x16931334(0xfe92f91ad70fcc788c91b5c6377091fddb1bb4643da297f26117462bd94f49fd); /* function */ \n\nc_0x16931334(0x1703157428668d098e51859c561d5296ef183d7c69ae701c20e674a9fb1fc99d); /* line */ \n        c_0x16931334(0xa3bdcd2326103ecf302266dfd6c4af18da60b0396e4465dbc816f02baf137a4d); /* statement */ \naddress _owner = owner();\nc_0x16931334(0xbcfc6ad7959841cabcf36b03dfcd357d7d622acca2ba6e9a43b2372593a2b1f4); /* line */ \n        c_0x16931334(0x627056f9061efb209e979f60571640480c8dc859fd3b1446b24f901abd471d78); /* statement */ \nuint256 balance = address(this).balance;\nc_0x16931334(0x872f745d610a98fff77a703564a28bce54c15938fd721d2bb1c1c96b29f02cc0); /* line */ \n        c_0x16931334(0xc7b520880199ff8ecee4cb60a0f2910d8beafd85c2a5d75e88cd45146cbd88c8); /* statement */ \nemit BalanceWithdrawn(_owner, balance);\nc_0x16931334(0xbb13c854fee71d4d649f60251494946a1dc47696ecdbc5239eebd0f0e09dedb6); /* line */ \n        c_0x16931334(0x848adaf7559bcfbc99734e73f7109730b5e7d6c9dac716b49e5293cd159045da); /* statement */ \npayable(_owner).transfer(balance);\n    }\n}\n"
    },
    "contracts/L2/predeploys/OVM_GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x52e91b95(bytes32 c__0x52e91b95) pure {}\n\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title OVM_GasPriceOracle\n * @dev This contract exposes the current l2 gas price, a measure of how congested the network\n * currently is. This measure is used by the Sequencer to determine what fee to charge for\n * transactions. When the system is more congested, the l2 gas price will increase and fees\n * will also increase as a result.\n *\n * All public variables are set while generating the initial L2 state. The\n * constructor doesn't run in practice as the L2 state generation script uses\n * the deployed bytecode instead of running the initcode.\n */\ncontract OVM_GasPriceOracle is Ownable {\nfunction c_0x22910892(bytes32 c__0x22910892) public pure {}\n\n    /*************\n     * Variables *\n     *************/\n\n    // Current L2 gas price\n    uint256 public gasPrice;\n    // Current L1 base fee\n    uint256 public l1BaseFee;\n    // Amortized cost of batch submission per transaction\n    uint256 public overhead;\n    // Value to scale the fee up by\n    uint256 public scalar;\n    // Number of decimals of the scalar\n    uint256 public decimals;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address that will initially own this contract.\n     */\n    constructor(address _owner) Ownable() {c_0x22910892(0xabe954ab1b250045ec47d3dff93b2ee94aa0de54348d74978b5584cd0364f9b4); /* function */ \n\nc_0x22910892(0x9b38d58dc34768fb9157058195a471419f59adb1d783a47adb97a96449270ff9); /* line */ \n        c_0x22910892(0x18e81b1f2b651d85286f142466cae950bedc970e2b06fa74cdf3fbbbf2b6356f); /* statement */ \ntransferOwnership(_owner);\n    }\n\n    /**********\n     * Events *\n     **********/\n\n    event GasPriceUpdated(uint256);\n    event L1BaseFeeUpdated(uint256);\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Allows the owner to modify the l2 gas price.\n     * @param _gasPrice New l2 gas price.\n     */\n    // slither-disable-next-line external-function\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {c_0x22910892(0x503e694c1d7e5eb4187d02712b004cab08fffae3ece50c18a7acdf58d5e1a08c); /* function */ \n\nc_0x22910892(0xe3e7303084bc98a5ff22f7d6f89463e706ab714fd785adf0c91c093abf24efdf); /* line */ \n        c_0x22910892(0x921d6afa7038e05a65927b7d8daf3c0c54b8c627e74000fab9ac02f98c61ac9a); /* statement */ \ngasPrice = _gasPrice;\nc_0x22910892(0x111931c93e855427028ce09b482c8a192bce8053d348dd3cb1d8a0aa4aafc35b); /* line */ \n        c_0x22910892(0x8fdcdaf34becd88fce5ea56cdbaa29e51c44596b6e71ee507a287a66c839dfc6); /* statement */ \nemit GasPriceUpdated(_gasPrice);\n    }\n\n    /**\n     * Allows the owner to modify the l1 base fee.\n     * @param _baseFee New l1 base fee\n     */\n    // slither-disable-next-line external-function\n    function setL1BaseFee(uint256 _baseFee) public onlyOwner {c_0x22910892(0x5f3788dbf76a6b0dbed6bcb7e10b03c6fab7bbfde35f718e031fbb166d861540); /* function */ \n\nc_0x22910892(0x1afa5e0c8ac3c3c78e710296942bee2fbec956c007a89532248b477d93c6ed4f); /* line */ \n        c_0x22910892(0xd964126fb239d61928a1e7e2a3672cdf13fbab41e7484496f12b258bbb4771c4); /* statement */ \nl1BaseFee = _baseFee;\nc_0x22910892(0x9c0e13895892f1e5c8987723cd838f356c61e880288a6613cf9fb4871eb50b7b); /* line */ \n        c_0x22910892(0xa2c5047ecaa3f399ad6924d6eff8e2fc5ef15485155c78c7492ef6dbfe9155ec); /* statement */ \nemit L1BaseFeeUpdated(_baseFee);\n    }\n\n    /**\n     * Allows the owner to modify the overhead.\n     * @param _overhead New overhead\n     */\n    // slither-disable-next-line external-function\n    function setOverhead(uint256 _overhead) public onlyOwner {c_0x22910892(0x9b2b3de05ec6a2a34051547d2ce9efa10a9fa1beaee140586b14c71d0c6ed1b1); /* function */ \n\nc_0x22910892(0x817dd4b1de470bdf3f5168cc83de5f3e65880b721792735a252628b68c56de79); /* line */ \n        c_0x22910892(0x72099219084e76c6eba1bf789f3940012bca15837538ac1b88fe14c00415436a); /* statement */ \noverhead = _overhead;\nc_0x22910892(0x73d6edbbd399658bcd252486aec0983922623c18b019bcd13f341d4af74dd597); /* line */ \n        c_0x22910892(0x0eda0092c3de7bd24f293395004dfa0797602a66b868e22ec19274a54ce9958e); /* statement */ \nemit OverheadUpdated(_overhead);\n    }\n\n    /**\n     * Allows the owner to modify the scalar.\n     * @param _scalar New scalar\n     */\n    // slither-disable-next-line external-function\n    function setScalar(uint256 _scalar) public onlyOwner {c_0x22910892(0xad3efbccc5c96224e33e559366a37293d1e5ce6e45ed41f875c58511c3701211); /* function */ \n\nc_0x22910892(0x608947a3d6cb6f8b57f0ade9f9fa3b55540c87d75b624bbaf706ce1cd8430169); /* line */ \n        c_0x22910892(0x291ae29dee695bd9cea073eca6ee7c1c93b8d8ab12c04033f3703713cdcfab48); /* statement */ \nscalar = _scalar;\nc_0x22910892(0xbc8e01d835c1b9a296f5b9af60902ec87da958aa529095ebf02ad16e2d2c1605); /* line */ \n        c_0x22910892(0x2d81ec438809b9380763ea76cd60d2cb609a98bb8c12479866b6c8cb86d91d31); /* statement */ \nemit ScalarUpdated(_scalar);\n    }\n\n    /**\n     * Allows the owner to modify the decimals.\n     * @param _decimals New decimals\n     */\n    // slither-disable-next-line external-function\n    function setDecimals(uint256 _decimals) public onlyOwner {c_0x22910892(0x17c0a68dd3c8da353287e7c0de59ebddd2e1f9cfd573994917b31f8cb7484523); /* function */ \n\nc_0x22910892(0x44f22fe01a89181690e2632e244e9040e7e6a5fe8c908dc3ca4ee8841c03a048); /* line */ \n        c_0x22910892(0x30f200519f7bd0ef543aa4e4a2177449ddecf83897679d5560cd654dcbae6cf7); /* statement */ \ndecimals = _decimals;\nc_0x22910892(0x7bf2d3abacc52cf64adf6c32aa946e194305d0a5869a7556ac93bda469674fbc); /* line */ \n        c_0x22910892(0x73626f1d62d31811b03e2820df23fe76d87d8277555dc626496d91917cca68ce); /* statement */ \nemit DecimalsUpdated(_decimals);\n    }\n\n    /**\n     * Computes the L1 portion of the fee\n     * based on the size of the RLP encoded tx\n     * and the current l1BaseFee\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return L1 fee that should be paid for the tx\n     */\n    // slither-disable-next-line external-function\n    function getL1Fee(bytes memory _data) public view returns (uint256) {c_0x22910892(0x84e64e3e0efb964d5cf9083ef8853580fdb143bfdcd0f10c487dfe78a9cfc724); /* function */ \n\nc_0x22910892(0x2f2f894c8ef3c8b09e172449fbf62314ac9f920c9af65b59a652ee086725f0b6); /* line */ \n        c_0x22910892(0xd310be08eeb3d8c0b6953647f2fc3d23e15e23ed2e8eb4e6912a4abeeeacf63b); /* statement */ \nuint256 l1GasUsed = getL1GasUsed(_data);\nc_0x22910892(0xc10b73481ecc28bc8a7a52ad87207e2f4394cd00969a68f53a70478d9885d7cc); /* line */ \n        c_0x22910892(0x6d333df9cb589cef17f21774e25b277f1efcabffbba95fe81a614404d785ec8f); /* statement */ \nuint256 l1Fee = l1GasUsed * l1BaseFee;\nc_0x22910892(0x019e6172afd6020f8313351a6c96b512dab6cc4e84f56a79be9b9fd7f3f3c35e); /* line */ \n        c_0x22910892(0xd6613d28137431942c54360d7f25890b7faa7c38aee893dac1d1b60c2de00d26); /* statement */ \nuint256 divisor = 10**decimals;\nc_0x22910892(0x9f01b104d8b014e4609a5288fbf1c5c4ae780cfb0e2cf290a473153fa43bab4d); /* line */ \n        c_0x22910892(0x883b8140a8974ef9be52617ccfb7a0ca1cb952bdffa516f422ad82686ffa7769); /* statement */ \nuint256 unscaled = l1Fee * scalar;\nc_0x22910892(0x1efcca2184073c42654ef313eb2faa62f6d6fa8e69a673b640101e5309c8be0c); /* line */ \n        c_0x22910892(0x3c60606e4ab5b50b7ab651cf2614bee73a1481bdf88a893a123fbd49b53eb23e); /* statement */ \nuint256 scaled = unscaled / divisor;\nc_0x22910892(0x3c4d90807a69489d4f4a44677e75ad4dde27c80a28f971c27fd711828b23fcac); /* line */ \n        c_0x22910892(0x06302770116c02d4f52e2fe4455e0b5753aeb513765f8cd3b10367aa61c26245); /* statement */ \nreturn scaled;\n    }\n\n    // solhint-disable max-line-length\n    /**\n     * Computes the amount of L1 gas used for a transaction\n     * The overhead represents the per batch gas overhead of\n     * posting both transaction and state roots to L1 given larger\n     * batch sizes.\n     * 4 gas for 0 byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L33\n     * 16 gas for non zero byte\n     * https://github.com/ethereum/go-ethereum/blob/9ada4a2e2c415e6b0b51c50e901336872e028872/params/protocol_params.go#L87\n     * This will need to be updated if calldata gas prices change\n     * Account for the transaction being unsigned\n     * Padding is added to account for lack of signature on transaction\n     * 1 byte for RLP V prefix\n     * 1 byte for V\n     * 1 byte for RLP R prefix\n     * 32 bytes for R\n     * 1 byte for RLP S prefix\n     * 32 bytes for S\n     * Total: 68 bytes of padding\n     * @param _data Unsigned RLP encoded tx, 6 elements\n     * @return Amount of L1 gas used for a transaction\n     */\n    // solhint-enable max-line-length\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {c_0x22910892(0x487a5f42802d4dfaaef048288ff06cba1a91fc2d486cc5f6712b9673cd6ab84a); /* function */ \n\nc_0x22910892(0x7af867dc80c00a060e02e698b7d938e2b90c54158aa99294035feb6def0829a9); /* line */ \n        c_0x22910892(0x8464841c283e667092c1274b442585fa0b1aa6f7bb4f111eab52ffab4db54a8b); /* statement */ \nuint256 total = 0;\nc_0x22910892(0xb2234893bfd4200e82be07441102413cf0c8b840a7a161a4ad9a09c98665ebd5); /* line */ \n        c_0x22910892(0xb87c0e47ca34213e4cc380b5726a7b22e199978833cc5675b764a7daa3f11fd1); /* statement */ \nfor (uint256 i = 0; i < _data.length; i++) {\nc_0x22910892(0xbf20bfea57b42bc93346f5b6686c8c819adc5386b6dd975371bc31d3789a9805); /* line */ \n            c_0x22910892(0xb61fd2cf7b9baa34f184ce6f712f6122278dda70924de60f45d7e40b2821ddd2); /* statement */ \nif (_data[i] == 0) {c_0x22910892(0xdc9ae9de64817be753693e0216d27dd67175e42644151acd847d0c3ed9d33a7c); /* branch */ \n\nc_0x22910892(0x98adca15747503d8a629727e69a4c8957a7439fdf31a7f3df62a9a80604230a5); /* line */ \n                c_0x22910892(0xa2689cb567927574271b3d0bc0732d4fa66851ad00529ef874a1a0876840bb0f); /* statement */ \ntotal += 4;\n            } else {c_0x22910892(0x23314da24fcafaa8111de3802528ec7b306c9fba5a44e65a87356a331ac4d4da); /* branch */ \n\nc_0x22910892(0x7959dbf19dd8905f584ac86edf55f980cda362fbd1ae187135785bf540adad12); /* line */ \n                c_0x22910892(0xf88a7f715ce80d02bdf3b91669139b321d552fd610fff714fc65bb008549f900); /* statement */ \ntotal += 16;\n            }\n        }\nc_0x22910892(0x1166f93edf445a0b77fbd884b0cbcc8e36a5763a46aecb3d2d876ddc5e195f34); /* line */ \n        c_0x22910892(0x7f089eb71796a8e06a828e66c8a9c19a914c8cb2d46032ae97ad5bfb356cdded); /* statement */ \nuint256 unsigned = total + overhead;\nc_0x22910892(0xed66bc7c744ecc63a1b9a511ef086e17ecb717e97f423328c0a64ed6344f2f84); /* line */ \n        c_0x22910892(0xb7e6039f84c94b24fa87e77ffa0ae0a74caad95932be5e5585e02504099187cd); /* statement */ \nreturn unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/L1/teleportr/TeleportrDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\nfunction c_0xc21aea82(bytes32 c__0xc21aea82) pure {}\n\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title TeleportrDeposit\n *\n * Shout out to 0xclem for providing the inspiration for this contract:\n * https://github.com/0xclem/teleportr/blob/main/contracts/BridgeDeposit.sol\n */\ncontract TeleportrDeposit is Ownable {\nfunction c_0xbf18ea64(bytes32 c__0xbf18ea64) public pure {}\n\n    /// The minimum amount that be deposited in a receive.\n    uint256 public minDepositAmount;\n    /// The maximum amount that be deposited in a receive.\n    uint256 public maxDepositAmount;\n    /// The maximum balance the contract can hold after a receive.\n    uint256 public maxBalance;\n    /// The total number of successful deposits received.\n    uint256 public totalDeposits;\n\n    /**\n     * @notice Emitted any time the minimum deposit amount is set.\n     * @param previousAmount The previous minimum deposit amount.\n     * @param newAmount The new minimum deposit amount.\n     */\n    event MinDepositAmountSet(uint256 previousAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted any time the maximum deposit amount is set.\n     * @param previousAmount The previous maximum deposit amount.\n     * @param newAmount The new maximum deposit amount.\n     */\n    event MaxDepositAmountSet(uint256 previousAmount, uint256 newAmount);\n\n    /**\n     * @notice Emitted any time the contract maximum balance is set.\n     * @param previousBalance The previous maximum contract balance.\n     * @param newBalance The new maximum contract balance.\n     */\n    event MaxBalanceSet(uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @notice Emitted any time the balance is withdrawn by the owner.\n     * @param owner The current owner and recipient of the funds.\n     * @param balance The current contract balance paid to the owner.\n     */\n    event BalanceWithdrawn(address indexed owner, uint256 balance);\n\n    /**\n     * @notice Emitted any time a successful deposit is received.\n     * @param depositId A unique sequencer number identifying the deposit.\n     * @param emitter The sending address of the payer.\n     * @param amount The amount deposited by the payer.\n     */\n    event EtherReceived(uint256 indexed depositId, address indexed emitter, uint256 indexed amount);\n\n    /**\n     * @notice Initializes a new TeleportrDeposit contract.\n     * @param _minDepositAmount The initial minimum deposit amount.\n     * @param _maxDepositAmount The initial maximum deposit amount.\n     * @param _maxBalance The initial maximum contract balance.\n     */\n    constructor(\n        uint256 _minDepositAmount,\n        uint256 _maxDepositAmount,\n        uint256 _maxBalance\n    ) {c_0xbf18ea64(0x0064b7c3d2e027eba5da5f5280491bfce7932df45fdf2e0891110c3dc3e84bf4); /* function */ \n\nc_0xbf18ea64(0x0754617f84d3b5fc04f16a0983e82c729cb6d2698f728b30dfa934b5add90169); /* line */ \n        c_0xbf18ea64(0x1cd5d3f0acece0d68e6ccf8bfd89b818133486ea9f082a4b9b7b11b6000baad5); /* statement */ \nminDepositAmount = _minDepositAmount;\nc_0xbf18ea64(0x30791823e64606c8be3e7feb8b103685a5aaff26eaa6bd2c7f3ce310352527be); /* line */ \n        c_0xbf18ea64(0x33d8a274a292fb8ba3cc7d2b767284bf7dc0c506646d5443215dab914e4ca6e8); /* statement */ \nmaxDepositAmount = _maxDepositAmount;\nc_0xbf18ea64(0x50d9a49460146742cae39d07048c68aa13de2a770bed641810140d7a8973a70d); /* line */ \n        c_0xbf18ea64(0x3d77b70ed2057214d5cd1b0ee90db5bba75d46a8e2c1c1175b1c3c6c7477c142); /* statement */ \nmaxBalance = _maxBalance;\nc_0xbf18ea64(0x942240fbaf8b00e69532f2fbe4ea09bf8f15876f36c4a0d73a3ece54aa0a5229); /* line */ \n        c_0xbf18ea64(0x94060d265c2e1f35f4230c634aaf7f14185d0a42d6d8d5f35fe5492ece57cc0c); /* statement */ \ntotalDeposits = 0;\nc_0xbf18ea64(0x2c650db3dc7a065d861e08f687272c0e3d1fd605cd167042d67953202666742f); /* line */ \n        c_0xbf18ea64(0x1b7587159c5f1160ede69f194a9e5c933514c192042fd3415bf2deb3f8f74b07); /* statement */ \nemit MinDepositAmountSet(0, _minDepositAmount);\nc_0xbf18ea64(0x14fdcec951a67568c0b528dd486521f51bdc14f531d71f850fa0bd2d9c458294); /* line */ \n        c_0xbf18ea64(0x59bcf0476adddb53cd05f64c33dcc191fa4a0a2cbb042239cce51dd2fc7b4b9a); /* statement */ \nemit MaxDepositAmountSet(0, _maxDepositAmount);\nc_0xbf18ea64(0xd10cdaddea1cf4d5c38c657c8184253dab5a819c5e4b0c88869a9564fd4b4c49); /* line */ \n        c_0xbf18ea64(0xd8d1727cb6b16868521109e26db98e2148155c06bb992b0a0cb83f313921eb91); /* statement */ \nemit MaxBalanceSet(0, _maxBalance);\n    }\n\n    /**\n     * @notice Accepts deposits that will be disbursed to the sender's address on L2.\n     * The method reverts if the amount is less than the current\n     * minDepositAmount, the amount is greater than the current\n     * maxDepositAmount, or the amount causes the contract to exceed its maximum\n     * allowed balance.\n     */\n    receive() external payable {\nc_0xbf18ea64(0x5e91eb4e146243c5fc10218c63813d75795efa063ee048a70076cb6ecc61587d); /* line */ \n        c_0xbf18ea64(0x73260b5f05e45d61e42c373897b87998b1a5a7bd70f9af562c4b361e04f0379d); /* requirePre */ \nrequire(msg.value >= minDepositAmount, \"Deposit amount is too small\");c_0xbf18ea64(0x23991968fdcb96adbea8af7b4742a78253230d9f76ee5eff35c987310043166a); /* requirePost */ \n\nc_0xbf18ea64(0x249aaae9e0e29e3e4031f40b7d96a68f16ea91f027ace995e46bfdaeffc6f391); /* line */ \n        c_0xbf18ea64(0xbce8df54e38e3ccc6f9f6481c255cd9804ade53c913156b5c2da09a92946cb23); /* requirePre */ \nrequire(msg.value <= maxDepositAmount, \"Deposit amount is too big\");c_0xbf18ea64(0x2bd55ff7de06b7bc9a18ccd9faec6cc761628852dff2df2d03f1f08dc28285d6); /* requirePost */ \n\nc_0xbf18ea64(0x8ad51416e28945719acfb674a9f9e6907225e745b1f9e523e751b4be1bdaac4e); /* line */ \n        c_0xbf18ea64(0xff12f46047487761ec7b26043d01a917e9aecfcdd47cd91d771c8ea30d37e8b8); /* requirePre */ \nrequire(address(this).balance <= maxBalance, \"Contract max balance exceeded\");c_0xbf18ea64(0x003763c76368796ee311ec1b0ddfd3708e87b99464363f5ac0147716b637edb1); /* requirePost */ \n\n\nc_0xbf18ea64(0x79e71c65a22716d1eba9afec74511a85d8fe55b5f6a98109655aaf23bbcf27f0); /* line */ \n        emit EtherReceived(totalDeposits, msg.sender, msg.value);\nc_0xbf18ea64(0x1da34b6132b7d28e2dd5dcc9cc69abac10b228d460afab0c9cfbc955300ed96c); /* line */ \n        unchecked {\n            totalDeposits += 1;\n        }\n    }\n\n    /**\n     * @notice Sends the contract's current balance to the owner.\n     */\n    function withdrawBalance() external onlyOwner {c_0xbf18ea64(0xc6b27d465e4053b68a3388de9da95b673c18eb4989d1008c2e06915f910a0660); /* function */ \n\nc_0xbf18ea64(0x2fca1e77c51979dc28ae8dc9fc4db5c9ce9be137728cb0a61cecdd0d78850eb1); /* line */ \n        c_0xbf18ea64(0xec90bc2e2104a1823652f6828778f93075a8d31d8e3ac2bfd179ffcbfe51739b); /* statement */ \naddress _owner = owner();\nc_0xbf18ea64(0xb45dbc3fc05181c7356e9244306dddabaf0b75b05688c615d0e7a4833ce1b988); /* line */ \n        c_0xbf18ea64(0xbc38348ea4a9b5cb61c62ee5badf6ec802094b56806baef5ac173cb7461a82d1); /* statement */ \nuint256 _balance = address(this).balance;\nc_0xbf18ea64(0xf96c8825c2177b3c21775b49f255faad2ce4e7da2e10326bacd5248e8b712dff); /* line */ \n        c_0xbf18ea64(0xd43f2aaa632b9ffeb71c574863f0f8a1552a8f75769c81b9552396c6190eff41); /* statement */ \nemit BalanceWithdrawn(_owner, _balance);\nc_0xbf18ea64(0x3c0d0013f3a63b85c4bd529a45060dc1444fc884d2c8cc3cc575aa3a4710e278); /* line */ \n        c_0xbf18ea64(0x5b79781fe133b568105927be0b812215d4bec71e3c2215d5d4758c9bac65c627); /* statement */ \npayable(_owner).transfer(_balance);\n    }\n\n    /**\n     * @notice Sets the minimum amount that can be deposited in a receive.\n     * @param _minDepositAmount The new minimum deposit amount.\n     */\n    function setMinAmount(uint256 _minDepositAmount) external onlyOwner {c_0xbf18ea64(0xb433caf62ec08507ab7af9b492ca9c31d5bcdd278f6004a28794eb4106b5cf3e); /* function */ \n\nc_0xbf18ea64(0x897c1d74774bdd740f697ebe75144626bd7a18205b591e95d5ad4f8de174ea70); /* line */ \n        c_0xbf18ea64(0xd9e9dc42b180f2f843f8d913ef4d43c5f8f8bea2ec782b7a740d2561a257cde2); /* statement */ \nemit MinDepositAmountSet(minDepositAmount, _minDepositAmount);\nc_0xbf18ea64(0x8da41a211fc748f0027d0993815cc4ca3cc376d4ae4b4471d749b0984a572399); /* line */ \n        c_0xbf18ea64(0x4aa4ae558612ce08434cb24e0473deb7e6c2752c6a90ce39f24fd88b9cfe6d7d); /* statement */ \nminDepositAmount = _minDepositAmount;\n    }\n\n    /**\n     * @notice Sets the maximum amount that can be deposited in a receive.\n     * @param _maxDepositAmount The new maximum deposit amount.\n     */\n    function setMaxAmount(uint256 _maxDepositAmount) external onlyOwner {c_0xbf18ea64(0xfee123fad7ec16093a6435cf2c5d00b4571ad879afd34fb5bbb0d90914f78981); /* function */ \n\nc_0xbf18ea64(0x23b16a5b6e035bf28fefd8536d3d907084332ed11eaad0c731ab33bdf63728ab); /* line */ \n        c_0xbf18ea64(0xe3990e89e60d0565ab8d3b4f20893f23ea714ef00b2b971bfdca4ed564f9d7bc); /* statement */ \nemit MaxDepositAmountSet(maxDepositAmount, _maxDepositAmount);\nc_0xbf18ea64(0x7dcc232dd4ea9159fcc353f5151cc835e78ec60204ecd0bd7d926246ba5419ab); /* line */ \n        c_0xbf18ea64(0xe638d78dd410ed0ed44e18bb848eaffdebe2397f929549a92d78c434746b5a19); /* statement */ \nmaxDepositAmount = _maxDepositAmount;\n    }\n\n    /**\n     * @notice Sets the maximum balance the contract can hold after a receive.\n     * @param _maxBalance The new maximum contract balance.\n     */\n    function setMaxBalance(uint256 _maxBalance) external onlyOwner {c_0xbf18ea64(0xce1bcd2174ef6ef3da0e36105bd18a71486b853321242fc762fb2a5064cb2e53); /* function */ \n\nc_0xbf18ea64(0x96e568f68ceba0bb138445fe1d28ff043c88b4482d666e86c6663627a794d00e); /* line */ \n        c_0xbf18ea64(0x83921b77b4f8764a56568881a61495190986808cf7eaa1d617e46cd7e7b52f73); /* statement */ \nemit MaxBalanceSet(maxBalance, _maxBalance);\nc_0xbf18ea64(0x5e9d45d2a21d81f43304c5d88d8c4b9fe0060aae15b5abf9547f24437e7f90fc); /* line */ \n        c_0xbf18ea64(0x819805374cc1d4a4ad5b35e7e174e0b0ecb50f725597510954c8cd97e051b567); /* statement */ \nmaxBalance = _maxBalance;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/L1/messaging/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0xb6c429b0(bytes32 c__0xb6c429b0) pure {}\n\n\n/* Interface Imports */\nimport { IL1StandardBridge } from \"./IL1StandardBridge.sol\";\nimport { IL1ERC20Bridge } from \"./IL1ERC20Bridge.sol\";\nimport { IL2ERC20Bridge } from \"../../L2/messaging/IL2ERC20Bridge.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/* Library Imports */\nimport { CrossDomainEnabled } from \"../../libraries/bridge/CrossDomainEnabled.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title L1StandardBridge\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\n * and listening to it for newly finalized withdrawals.\n *\n */\ncontract L1StandardBridge is IL1StandardBridge, CrossDomainEnabled {\nfunction c_0xc4c4c59c(bytes32 c__0xc4c4c59c) public pure {}\n\n    using SafeERC20 for IERC20;\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2TokenBridge;\n\n    // Maps L1 token to L2 token to balance of the L1 token deposited\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    // This contract lives behind a proxy, so the constructor parameters will go unused.\n    constructor() CrossDomainEnabled(address(0)) {c_0xc4c4c59c(0x07adc7f6a2075ff0f95871050fe99ad323d030054e04abdbbb44a6476a60a9e7); /* function */ \n}\n\n    /******************\n     * Initialization *\n     ******************/\n\n    /**\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     * @param _l2TokenBridge L2 standard bridge address.\n     */\n    // slither-disable-next-line external-function\n    function initialize(address _l1messenger, address _l2TokenBridge) public {c_0xc4c4c59c(0x8bac4debac7e12d655d37550ca25162bf2a1cce59be7c7709f0948b9b7595b58); /* function */ \n\nc_0xc4c4c59c(0x861b89f49bc5f334cf87195523243586a1b395d8e9106dfba693ce2fbc58cfa8); /* line */ \n        c_0xc4c4c59c(0xbb5dcbf9b732db312531e05ca2f6e12dbb70d918137ffd435886df282228fec5); /* requirePre */ \nc_0xc4c4c59c(0xb6790f445f2a0f8f6afbc7b6184ffdbcea9ffe61f11a51b3dcdfb60c2d280d8c); /* statement */ \nrequire(messenger == address(0), \"Contract has already been initialized.\");c_0xc4c4c59c(0xf48ed916b5bbd63e50f8895eb6501189cbf00bd7fc34447a5272efe3bf7872b2); /* requirePost */ \n\nc_0xc4c4c59c(0xff3273a840777a47597a638b7a7a8e91305a22f43ce7696dd8e476f0ec287690); /* line */ \n        c_0xc4c4c59c(0xb148fe3224c964bc1620a42eb230f414352bce5caa1420703a7b1ae0865cbcb1); /* statement */ \nmessenger = _l1messenger;\nc_0xc4c4c59c(0x157c7603f1160b87fd5af78e723ca886d41dcd795aaadb4a3eb382c33a950b45); /* line */ \n        c_0xc4c4c59c(0x735ef898a9d34462838675e536dfb9e6eeed425cbea9365327084b3b2469426f); /* statement */ \nl2TokenBridge = _l2TokenBridge;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /** @dev Modifier requiring sender to be EOA.  This check could be bypassed by a malicious\n     *  contract via initcode, but it takes care of the user error we want to avoid.\n     */\n    modifier onlyEOA() {c_0xc4c4c59c(0xe9b87191951ef13ffe2a77a57671dcb3da437c0da862c526e465fba946bef333); /* function */ \n\n        // Used to stop deposits from contracts (avoid accidentally lost tokens)\nc_0xc4c4c59c(0xaf693fed46f788d99a8c802db07d8270b5f970087a8df82c2f071c79fa5df950); /* line */ \n        c_0xc4c4c59c(0x20f1f9502e591ad4af8f9c82020c59879eac99f0fd9ca3bc892020ace0be0518); /* requirePre */ \nc_0xc4c4c59c(0x9d30f0068d4bb6d8d75fd01b9b1ae0085a879f44580ab16c5ddf17f9b660f295); /* statement */ \nrequire(!Address.isContract(msg.sender), \"Account not EOA\");c_0xc4c4c59c(0x1a0815e28f539b2198b1113f5fe3d1e9d8f2200b4abf67a636ed23675a83e975); /* requirePost */ \n\nc_0xc4c4c59c(0x854a9280e33762917438c3137fda11f8cc803ff5dfa8ec85d682d1705b56675a); /* line */ \n        _;\n    }\n\n    /**\n     * @dev This function can be called with no data\n     * to deposit an amount of ETH to the caller's balance on L2.\n     * Since the receive function doesn't take data, a conservative\n     * default amount is forwarded to L2.\n     */\n    receive() external payable onlyEOA {\nc_0xc4c4c59c(0xc7118cae74a763128ce2be43342ee199faa025da0c2aa86a2d1fe19bf0952089); /* line */ \n        _initiateETHDeposit(msg.sender, msg.sender, 200_000, bytes(\"\"));\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {c_0xc4c4c59c(0x5b9cd88549ec956d66093059d7363c521ccad7ffc76f83f8712e301430a078a4); /* function */ \n\nc_0xc4c4c59c(0xef37aeb7a333133fac36a56869d863ef51e57b530fc8b1db6a28486752ec1b2d); /* line */ \n        c_0xc4c4c59c(0xae71485c53113d590220930c521238ad8cade1d05025e0caebb0219673044c9d); /* statement */ \n_initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable {c_0xc4c4c59c(0x9be6cdcb92506e03343531cf0147fdee096c8a87a569f2bf26afab71fe814ad3); /* function */ \n\nc_0xc4c4c59c(0xe78393e12fbf97cfe3e193354a375acfa1656486040cbb913e45309dbeef3049); /* line */ \n        c_0xc4c4c59c(0x550390b2431fa00be151081256fcc0a15cc74dab1b7b09425983a5e4d7bbcba9); /* statement */ \n_initiateETHDeposit(msg.sender, _to, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\n     * the deposit.\n     * @param _from Account to pull the deposit from on L1.\n     * @param _to Account to give the deposit to on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _l2Gas,\n        bytes memory _data\n    ) internal {c_0xc4c4c59c(0x81b3b22d54c82d210d6936cb96cd5c5b9f086d06860114934fb448669a0012cb); /* function */ \n\n        // Construct calldata for finalizeDeposit call\nc_0xc4c4c59c(0x7eb50125db7baf83f585bef50d5ac83bd3d04dd94380cd121c5cf1ce4790b48b); /* line */ \n        c_0xc4c4c59c(0x72114d9fbf96e4dce1de8cedd8959d1641976a895443086c0a62fba6ade7e2a7); /* statement */ \nbytes memory message = abi.encodeWithSelector(\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            address(0),\n            Lib_PredeployAddresses.OVM_ETH,\n            _from,\n            _to,\n            msg.value,\n            _data\n        );\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0x6da374799e8626620dac536828c06a023d23889b653828784c46b4a56cae11ad); /* line */ \n        c_0xc4c4c59c(0x1bb0515d213377e10616fcd9f1a614d2c7fd04e9c5ba8de8f0f48187e36ec6b2); /* statement */ \nsendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0x80e5c99e8da6738b7e2874520064d493b1d668f9f7d53dd469e7d0b69cba12a8); /* line */ \n        c_0xc4c4c59c(0x8bd0a2461146831e1c2a11bd26c6483bcbb185d41d5e0dae6e55b0c8c3c8f660); /* statement */ \nemit ETHDepositInitiated(_from, _to, msg.value, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual onlyEOA {c_0xc4c4c59c(0xbe76b0c7d869d5ef740c64b8a29ba46163ed5ea08ccddf0f99a7de9c67b2f958); /* function */ \n\nc_0xc4c4c59c(0xee911716629cccdccd9d2029a40417a23157e8f3008dedfbcdb97d6d819be0e7); /* line */ \n        c_0xc4c4c59c(0x3e0e2e880a4783b152513ea8693960d9593531739de482b376e0bd5ab7454944); /* statement */ \n_initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external virtual {c_0xc4c4c59c(0x44e70170fe06daefdb2342d111acf567fb5b5fef67760149f72be41728cd279b); /* function */ \n\nc_0xc4c4c59c(0xfa81f9b57b057e5378584bef7ffac5fb96b9646c57ad39c77f776b4a6d345d7f); /* line */ \n        c_0xc4c4c59c(0x875097098ea8a57cde492fdbc8d0e0744a9f99f23f42a75456ba7d075391f7de); /* statement */ \n_initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount, _l2Gas, _data);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) internal {c_0xc4c4c59c(0x436a9f6e35ef244cf388465d7991256db3da9f850e3fde304dfb498b364f868f); /* function */ \n\n        // When a deposit is initiated on L1, the L1 Bridge transfers the funds to itself for future\n        // withdrawals. safeTransferFrom also checks if the contract has code, so this will fail if\n        // _from is an EOA or address(0).\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\nc_0xc4c4c59c(0x0c25c3220aeb8606966102ab023ebc2a638272157550f81c878d2f0a4b6c3b66); /* line */ \n        c_0xc4c4c59c(0xd40ff3af1b79168db7a6d45214412feb0c66cb68b7fea3c1bce8168ffd3e41dd); /* statement */ \nIERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n\n        // Construct calldata for _l2Token.finalizeDeposit(_to, _amount)\nc_0xc4c4c59c(0xb03c85379feaf1313a3925f38f1f583a0fe54591a4a10b78294c1a9dabd7d99f); /* line */ \n        c_0xc4c4c59c(0x5554aab7321f3003e43293ef8f1c60bf266b44e5502b4da4b70bd3c804294b5f); /* statement */ \nbytes memory message = abi.encodeWithSelector(\n            IL2ERC20Bridge.finalizeDeposit.selector,\n            _l1Token,\n            _l2Token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // Send calldata into L2\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\nc_0xc4c4c59c(0xd1377577b7820c45977c06dcf95c18f96ecaef237de13ceed19c9b6972ad641e); /* line */ \n        c_0xc4c4c59c(0x0b1f316bddf508642613b6e3570f77266df2b14e040c89738213697a7241e774); /* statement */ \nsendCrossDomainMessage(l2TokenBridge, _l2Gas, message);\n\n        // slither-disable-next-line reentrancy-benign\nc_0xc4c4c59c(0x19388933f439ab6b8ef8ed588dbe3916645468f1ceaa5f661e5d2fea6d0d039a); /* line */ \n        c_0xc4c4c59c(0xa1a252ab811b9d226308ecba73d9cc912b6a2fe7bdf55ba229e6b08076877954); /* statement */ \ndeposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;\n\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0x97a52c8f5858e97536e19547f8b472625286f28e81dd132f19cdc06f54f1e3ac); /* line */ \n        c_0xc4c4c59c(0xca0aff937201289cea4a947ce6f95cef3cdd1c5938443a61e913cd9b8c1b0e3d); /* statement */ \nemit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @inheritdoc IL1StandardBridge\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {c_0xc4c4c59c(0x6919f2a2c7c96c5967bece00b65315eb154b90c72d0e7e768e73fbe594f49a05); /* function */ \n\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0x43fc4f4f2e5f8c397c9315cc13417ca1a78819458224855dc5d496e35c127cda); /* line */ \n        c_0xc4c4c59c(0x4ed3f08671097465da48fad47c0639819a44141df3a7d339d353d070bcd0d844); /* statement */ \n(bool success, ) = _to.call{ value: _amount }(new bytes(0));\nc_0xc4c4c59c(0xf45de628aebbac352c1626d858e1d97ae1ad655fc0c3ad74552554f70b2014f8); /* line */ \n        c_0xc4c4c59c(0x04f3e4217fb00bf11491c820f2f47c83502ebc5bdf08762bf23bd7c2d8da32aa); /* requirePre */ \nc_0xc4c4c59c(0x1f89401866e4e3d4458f279a0e7ec41fa892a88318560508e7877aae5eb4d23f); /* statement */ \nrequire(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");c_0xc4c4c59c(0x5e13ace1d1c4cab381eb2019c9b1a48ec3768cb98a456248e129b53052230ddf); /* requirePost */ \n\n\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0xe5ad1197e6f47b8cfa3d834131aba048ae51f3e1e09f7dd9e50ec8f8eb29a43c); /* line */ \n        c_0xc4c4c59c(0x8e9c68ba716104cd49526db8517156ca31bb2f652e7de5b68dadf70dff9410c0); /* statement */ \nemit ETHWithdrawalFinalized(_from, _to, _amount, _data);\n    }\n\n    /**\n     * @inheritdoc IL1ERC20Bridge\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external onlyFromCrossDomainAccount(l2TokenBridge) {c_0xc4c4c59c(0xfea1fee649e3652d6f879d43f9ff997525c50664ad3539ce90b2a0964708d67b); /* function */ \n\nc_0xc4c4c59c(0x9b6b6260b854729540c6f4ab246ab148addd0b26fcfeeacf219f541447a1602f); /* line */ \n        c_0xc4c4c59c(0x469f229bde28f929b52c0a1aa7f02f74f6ad4b07c4d720b3cbf02415cffcb94e); /* statement */ \ndeposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;\n\n        // When a withdrawal is finalized on L1, the L1 Bridge transfers the funds to the withdrawer\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0x267c124adacf383d85bf27458c78921d9c4c4685c778fce5580cb9eaebe35fe8); /* line */ \n        c_0xc4c4c59c(0x3497852ba3f099d511377d74b92e653c1fb90c10a5ef4f10b7c2fbda5164b74b); /* statement */ \nIERC20(_l1Token).safeTransfer(_to, _amount);\n\n        // slither-disable-next-line reentrancy-events\nc_0xc4c4c59c(0xd50e5a84f78048407f67fddd9bb8b747a2b4298bcc4f836890d7b2a5a2107dbd); /* line */ \n        c_0xc4c4c59c(0xdbab047cefe16dc4b5a0aaeeae0aa4b183c7934c535992caa7b0521940c06065); /* statement */ \nemit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*****************************\n     * Temporary - Migrating ETH *\n     *****************************/\n\n    /**\n     * @dev Adds ETH balance to the account. This is meant to allow for ETH\n     * to be migrated from an old gateway to a new gateway.\n     * NOTE: This is left for one upgrade only so we are able to receive the migrated ETH from the\n     * old contract\n     */\n    function donateETH() external payable {c_0xc4c4c59c(0x73b11f32b2d3cdf693c329c7d571f2788081b5608624034463ffd968d2309819); /* function */ \n}\n}\n"
    },
    "contracts/L2/messaging/L2StandardTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x2421692b(bytes32 c__0x2421692b) pure {}\n\n\n/* Contract Imports */\nimport { L2StandardERC20 } from \"../../standards/L2StandardERC20.sol\";\nimport { Lib_PredeployAddresses } from \"../../libraries/constants/Lib_PredeployAddresses.sol\";\n\n/**\n * @title L2StandardTokenFactory\n * @dev Factory contract for creating standard L2 token representations of L1 ERC20s\n * compatible with and working on the standard bridge.\n */\ncontract L2StandardTokenFactory {\nfunction c_0x508fc111(bytes32 c__0x508fc111) public pure {}\n\n    event StandardL2TokenCreated(address indexed _l1Token, address indexed _l2Token);\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param _l1Token Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    function createStandardL2Token(\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    ) external {c_0x508fc111(0x4630c63dda6a15c0f6058511c7ea9f9e22e4777a7a57f0f68cf29fb201f5870b); /* function */ \n\nc_0x508fc111(0x00d2e95e3c50567febad102270dbd3bbbfc4de72cb88c319666da8dff06d03ff); /* line */ \n        c_0x508fc111(0x940dc98a1d861cc03d30418889842fb5e431b37cb531c738fe958e66c89a10e2); /* requirePre */ \nc_0x508fc111(0xd38972f3b0c23bcc4f310ae461900eac46639e110fc8e494639cd08fceefa1de); /* statement */ \nrequire(_l1Token != address(0), \"Must provide L1 token address\");c_0x508fc111(0xa95acc51e241679ee085ce5e2eb2539cc705c74d753e94e16f8dd0695f0a8354); /* requirePost */ \n\n\nc_0x508fc111(0x0fa8bef43661914969544d8b88572b7cc6be26dfaa8f84e1b4395230135edafe); /* line */ \n        c_0x508fc111(0x889c17833b09e7cde4c4f98b3ec4aaa1f7a1f861a4ae5e8e4c90e1644412e772); /* statement */ \nL2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol\n        );\n\nc_0x508fc111(0x7432c03ab902b7cd36aadb710251e29b1c65726c85da1458331f6384199bc5da); /* line */ \n        c_0x508fc111(0x295f546501ea5a33da641c2a6ff27a81d402a8863837b7c6acafd0de9bf3c9c2); /* statement */ \nemit StandardL2TokenCreated(_l1Token, address(l2Token));\n    }\n}\n"
    },
    "contracts/test-libraries/bridge/TestLib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_CrossDomainUtils } from \"../../libraries/bridge/Lib_CrossDomainUtils.sol\";\n\n/**\n * @title TestLib_CrossDomainUtils\n */\nlibrary TestLib_CrossDomainUtils {\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) public pure returns (bytes memory) {\n        return\n            Lib_CrossDomainUtils.encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\n    }\n}\n"
    },
    "contracts/test-libraries/standards/TestLib_AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/* Library Imports */\nimport { AddressAliasHelper } from \"../../standards/AddressAliasHelper.sol\";\n\n/**\n * @title TestLib_AddressAliasHelper\n */\ncontract TestLib_AddressAliasHelper {\n    function applyL1ToL2Alias(address _address) public pure returns (address) {\n        return AddressAliasHelper.applyL1ToL2Alias(_address);\n    }\n\n    function undoL1ToL2Alias(address _address) public pure returns (address) {\n        return AddressAliasHelper.undoL1ToL2Alias(_address);\n    }\n}\n"
    },
    "contracts/test-libraries/trie/TestLib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_SecureMerkleTrie } from \"../../libraries/trie/Lib_SecureMerkleTrie.sol\";\n\n/**\n * @title TestLib_SecureMerkleTrie\n */\ncontract TestLib_SecureMerkleTrie {\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool) {\n        return Lib_SecureMerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\n    }\n\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bytes32) {\n        return Lib_SecureMerkleTrie.update(_key, _value, _proof, _root);\n    }\n\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool, bytes memory) {\n        return Lib_SecureMerkleTrie.get(_key, _proof, _root);\n    }\n\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\n        public\n        pure\n        returns (bytes32)\n    {\n        return Lib_SecureMerkleTrie.getSingleNodeRootHash(_key, _value);\n    }\n}\n"
    },
    "contracts/test-libraries/trie/TestLib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"../../libraries/trie/Lib_MerkleTrie.sol\";\n\n/**\n * @title TestLib_MerkleTrie\n */\ncontract TestLib_MerkleTrie {\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool) {\n        return Lib_MerkleTrie.verifyInclusionProof(_key, _value, _proof, _root);\n    }\n\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bytes32) {\n        return Lib_MerkleTrie.update(_key, _value, _proof, _root);\n    }\n\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) public pure returns (bool, bytes memory) {\n        return Lib_MerkleTrie.get(_key, _proof, _root);\n    }\n\n    function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\n        public\n        pure\n        returns (bytes32)\n    {\n        return Lib_MerkleTrie.getSingleNodeRootHash(_key, _value);\n    }\n}\n"
    },
    "contracts/test-libraries/rlp/TestLib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPWriter } from \"../../libraries/rlp/Lib_RLPWriter.sol\";\nimport { TestERC20 } from \"../../test-helpers/TestERC20.sol\";\n\n/**\n * @title TestLib_RLPWriter\n */\ncontract TestLib_RLPWriter {\n    function writeBytes(bytes memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeBytes(_in);\n    }\n\n    function writeList(bytes[] memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeList(_in);\n    }\n\n    function writeString(string memory _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeString(_in);\n    }\n\n    function writeAddress(address _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeAddress(_in);\n    }\n\n    function writeUint(uint256 _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeUint(_in);\n    }\n\n    function writeBool(bool _in) public pure returns (bytes memory _out) {\n        return Lib_RLPWriter.writeBool(_in);\n    }\n\n    function writeAddressWithTaintedMemory(address _in) public returns (bytes memory _out) {\n        new TestERC20();\n        return Lib_RLPWriter.writeAddress(_in);\n    }\n}\n"
    },
    "contracts/test-helpers/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// a test ERC20 token with an open mint function\ncontract TestERC20 {\n    string public constant name = \"Test\";\n    string public constant symbol = \"TST\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {}\n\n    function mint(address to, uint256 value) public {\n        totalSupply = totalSupply + value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from] - value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../../libraries/utils/Lib_BytesUtils.sol\";\nimport { TestERC20 } from \"../../test-helpers/TestERC20.sol\";\n\n/**\n * @title TestLib_BytesUtils\n */\ncontract TestLib_BytesUtils {\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_preBytes, _postBytes);\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) public pure returns (bytes memory) {\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\n    }\n\n    function toBytes32(bytes memory _bytes) public pure returns (bytes32) {\n        return Lib_BytesUtils.toBytes32(_bytes);\n    }\n\n    function toUint256(bytes memory _bytes) public pure returns (uint256) {\n        return Lib_BytesUtils.toUint256(_bytes);\n    }\n\n    function toNibbles(bytes memory _bytes) public pure returns (bytes memory) {\n        return Lib_BytesUtils.toNibbles(_bytes);\n    }\n\n    function fromNibbles(bytes memory _bytes) public pure returns (bytes memory) {\n        return Lib_BytesUtils.fromNibbles(_bytes);\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) public pure returns (bool) {\n        return Lib_BytesUtils.equal(_bytes, _other);\n    }\n\n    function sliceWithTaintedMemory(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) public returns (bytes memory) {\n        new TestERC20();\n        return Lib_BytesUtils.slice(_bytes, _start, _length);\n    }\n}\n"
    },
    "contracts/test-libraries/rlp/TestLib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../../libraries/rlp/Lib_RLPReader.sol\";\n\n/**\n * @title TestLib_RLPReader\n */\ncontract TestLib_RLPReader {\n    function readList(bytes memory _in) public pure returns (bytes[] memory) {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_in);\n        bytes[] memory out = new bytes[](decoded.length);\n        for (uint256 i = 0; i < out.length; i++) {\n            out[i] = Lib_RLPReader.readRawBytes(decoded[i]);\n        }\n        return out;\n    }\n\n    function readString(bytes memory _in) public pure returns (string memory) {\n        return Lib_RLPReader.readString(_in);\n    }\n\n    function readBytes(bytes memory _in) public pure returns (bytes memory) {\n        return Lib_RLPReader.readBytes(_in);\n    }\n\n    function readBytes32(bytes memory _in) public pure returns (bytes32) {\n        return Lib_RLPReader.readBytes32(_in);\n    }\n\n    function readUint256(bytes memory _in) public pure returns (uint256) {\n        return Lib_RLPReader.readUint256(_in);\n    }\n\n    function readBool(bytes memory _in) public pure returns (bool) {\n        return Lib_RLPReader.readBool(_in);\n    }\n\n    function readAddress(bytes memory _in) public pure returns (address) {\n        return Lib_RLPReader.readAddress(_in);\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_Bytes32Utils } from \"../../libraries/utils/Lib_Bytes32Utils.sol\";\n\n/**\n * @title TestLib_Byte32Utils\n */\ncontract TestLib_Bytes32Utils {\n    function toBool(bytes32 _in) public pure returns (bool _out) {\n        return Lib_Bytes32Utils.toBool(_in);\n    }\n\n    function fromBool(bool _in) public pure returns (bytes32 _out) {\n        return Lib_Bytes32Utils.fromBool(_in);\n    }\n\n    function toAddress(bytes32 _in) public pure returns (address _out) {\n        return Lib_Bytes32Utils.toAddress(_in);\n    }\n\n    function fromAddress(address _in) public pure returns (bytes32 _out) {\n        return Lib_Bytes32Utils.fromAddress(_in);\n    }\n}\n"
    },
    "contracts/test-libraries/utils/TestLib_MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTree } from \"../../libraries/utils/Lib_MerkleTree.sol\";\n\n/**\n * @title TestLib_MerkleTree\n */\ncontract TestLib_MerkleTree {\n    function getMerkleRoot(bytes32[] memory _elements) public pure returns (bytes32) {\n        return Lib_MerkleTree.getMerkleRoot(_elements);\n    }\n\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    ) public pure returns (bool) {\n        return Lib_MerkleTree.verify(_root, _leaf, _index, _siblings, _totalLeaves);\n    }\n}\n"
    },
    "contracts/L2/predeploys/iOVM_L1BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nfunction c_0x1ca6e368(bytes32 c__0x1ca6e368) pure {}\n\n\n/**\n * @title iOVM_L1BlockNumber\n */\ninterface iOVM_L1BlockNumber {\n    /********************\n     * Public Functions *\n     ********************/\n\n    function getL1BlockNumber() external view returns (uint256);\n}\n"
    },
    "contracts/L2/predeploys/OVM_DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title OVM_DeployerWhitelist\n * @dev The Deployer Whitelist is a temporary predeploy used to provide additional safety during the\n * initial phases of our mainnet roll out. It is owned by the Optimism team, and defines accounts\n * which are allowed to deploy contracts on Layer2. The Execution Manager will only allow an\n * ovmCREATE or ovmCREATE2 operation to proceed if the deployer's address whitelisted.\n */\ncontract OVM_DeployerWhitelist {\n    /**********\n     * Events *\n     **********/\n\n    event OwnerChanged(address oldOwner, address newOwner);\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\n    event WhitelistDisabled(address oldOwner);\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // WARNING: When owner is set to address(0), the whitelist is disabled.\n    address public owner;\n    mapping(address => bool) public whitelist;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Function can only be called by the owner of this contract.\");\n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Adds or removes an address from the deployment whitelist.\n     * @param _deployer Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\n        whitelist[_deployer] = _isWhitelisted;\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\n    }\n\n    /**\n     * Updates the owner of this contract.\n     * @param _owner Address of the new owner.\n     */\n    // slither-disable-next-line external-function\n    function setOwner(address _owner) public onlyOwner {\n        // Prevent users from setting the whitelist owner to address(0) except via\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\n        // any other address that doesn't have a corresponding knowable private key.\n        require(\n            _owner != address(0),\n            \"OVM_DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\"\n        );\n\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment() external onlyOwner {\n        emit WhitelistDisabled(owner);\n        owner = address(0);\n    }\n\n    /**\n     * Checks whether an address is allowed to deploy contracts.\n     * @param _deployer Address to check.\n     * @return _allowed Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\n        return (owner == address(0) || whitelist[_deployer]);\n    }\n}\n"
    },
    "contracts/test-helpers/FailingReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\n/**\n * @title FailingReceiver\n */\ncontract FailingReceiver {\n    /**\n     * @notice Receiver that always reverts upon receiving ether.\n     */\n    receive() external payable {\n        require(false, \"FailingReceiver\");\n    }\n}\n"
    },
    "contracts/test-helpers/Helper_SimpleProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Helper_SimpleProxy {\n    address internal owner;\n    address internal target;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    fallback() external {\n        makeExternalCall(target, msg.data);\n    }\n\n    function setTarget(address _target) public {\n        if (msg.sender == owner) {\n            target = _target;\n        } else {\n            makeExternalCall(target, msg.data);\n        }\n    }\n\n    function makeExternalCall(address _target, bytes memory _calldata) internal {\n        (bool success, bytes memory returndata) = _target.call(_calldata);\n\n        if (success) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": false
    }
  }
}